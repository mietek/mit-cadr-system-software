JERRYB@MIT-MC 07/24/80 17:04:36
To: (BUG LISPM) at MIT-MC
In system 32.2, with microcode 674, on LISP Machine Nine:

Typing (hostat) to the editor in ZTOP mode results in the following:


(hostat)
Site   Name/Status			Subnet #-in #-out abort  lost  crc ramerr bitc  other

>>>>TRAP 4321 (FUNCTION-ENTRY)
The function (:METHOD LIST-TYI-MIXIN TYI) was called with too many arguments.
While in the function (:METHOD LIST-TYI-MIXIN TYI)  (:METHOD ZWEI:EDITOR-STREAM-MIXIN :TYI-NO-HANG)  HOSTAT

(:METHOD LIST-TYI-MIXIN TYI):
   Arg 0 (OPERATION): TYI
   Arg 1 (IGNORE): NIL
   --Extraneous args:--
   Arg 2: T



Date: 23 JUL 1980 2154-EDT
From: SMATT at MIT-AI (Matt BenDaniel)
To: (BUG LISPM) at MIT-AI

Systsem 32.2, Microcode 674
(tv:white-on-black-state) seems to exist, but cannot be called.


Date: 23 JUL 1980 1659-EDT
From: XCONOS at MIT-AI (Alec Destry)
To: (BUG LISPM) at MIT-AI

   Is it intentional that system 32.2 is not (yet) on cadr 11.  This low priority
message courtesy of Alec Destry.

MOON@MIT-MC 07/23/80 15:34:34 Re: Finding out the current font of a window
To: jerryb at MIT-AI
CC: (BUG LISPM) at MIT-MC
There isn't a :CURRENT-FONT message?  There's supposed to be.

You can also use the TV:SHEET-CURRENT-FONT function (macro actually).

Date: 23 JUL 1980 1314-EDT
From: jerryb at MIT-AI (Gerald R. Barber)
To: (BUG LISPM) at MIT-AI

In system 32.2, with microcode 674, on LISP Machine Nine:

[terminal]-D to open the door doesn't work...
Host doesn't respond to attempt to establish Chaos connection .



Date: 23 JUL 1980 1250-EDT
From: jerryb at MIT-AI (Gerald R. Barber)
To: (BUG LISPM) at MIT-AI

In system 32.2, with microcode 674, on LISP Machine Nine:

Cadr9 is getting disk errors causing it to drop dead every 20 minutes
or so.


Date: 23 JUL 1980 0107-EDT
From: jerryb at MIT-AI (Gerald R. Barber)
To: (BUG LISPM) at MIT-AI

In system 32.2, with microcode 674, on LISP Machine Nine:

There doesn't seem to be anyway to find out what the current font of a window is,
eg with flavor pop-up-text-window.  Specifically I want to find out the height of
the font.


Date: 23 JUL 1980 0010-EDT
From: ACW at MIT-AI (Allan C. Wechsler)
To: (BUG LISPM) at MIT-AI

In system 32.2, with microcode 674, on LISP Machine One:

When you trust the n-key rollover too implicitly, and
strike keys nearly simultaneously, some characters
can get lost and some spurious ones can appear.

148}367

That was produced by hitting the digits 1-8 nearly 
simultaneously.  I never went near the } key.

   ---Wechsler


Date: 22 JUL 1980 1746-EDT
From: RICH at MIT-AI (Charles Rich)
To: (BUG LISPM) at MIT-AI

In system 29.95 NWS, with microcode 669, on LISP Machine Eight:
LEFT and RIGHT are protected in GLOBAL, but are not really defined there.


MOON@MIT-MC 07/21/80 20:09:33
To: Batali at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date: 21 JUL 1980 1546-EDT
    From: Batali at MIT-AI (John Batali)
    To: (BUG LISPM) at MIT-AI

    In system 32.2, with microcode 674, on LISP Machine Four:
    REMOBing a symbol more than once causes an error. It looks at
    the CAR of the package-cell-location of the symbol and finds NIL
    (because the symbol was remobed) and then pkg-find-package complains
    thet nil is not a good refname.
    	This is not compatable with MacLISP and anyway, I think that
    it should remove the symbol only from the current package.
Fixed in the source to not cause an error, but return NIL if it wasn't
there and T if it was but is now remobed, as documented.  Note that
"removing the symbol only from the current package" doesn't really make
sense because what do you do if it is inherited from a superior
package?  If you really want it removed only locally from the current
package you may do (remob symbol package).  remob can't be more exactly
compatible with Maclisp since Maclisp doesn't have packages.

Date: 21 JUL 1980 1546-EDT
From: Batali at MIT-AI (John Batali)
To: (BUG LISPM) at MIT-AI

In system 32.2, with microcode 674, on LISP Machine Four:
REMOBing a symbol more than once causes an error. It looks at
the CAR of the package-cell-location of the symbol and finds NIL
(because the symbol was remobed) and then pkg-find-package complains
thet nil is not a good refname.
	This is not compatable with MacLISP and anyway, I think that
it should remove the symbol only from the current package.
	

Date: 21 JUL 1980 1337-EDT
From: ACW at MIT-AI (Allan C. Wechsler)
Subject:  New Keyboard font.
To: (BUG LISPM) at MIT-AI


    Date: 21 July 1980 09:30-EDT
    From: Mike McMahon <MMCM at MIT-AI>
    Sender: TAFT at MIT-AI

        Date: 20 JUL 1980 2144-EDT
        From: ACW at MIT-AI (Allan C. Wechsler)
        This is a reminder that somebody should invent the characters circle-minus
        and circle-slash someday.  Also there are a lot of greek letters still undrawn.
    I drew all the characters on the new keyboard months ago; look at MMCM;NEWKBD FONT.
So we should install it.  I don't know how.

Date: 21 JUL 1980 1248-EDT
From: ACW at MIT-AI (Allan C. Wechsler)
Subject:  Caps-, mode-, and alt-lock.
To: INFO-LISPM at MIT-AI


   Perhaps these could be used to toggle modes in the Editor.

   One might use them to turn filling on or off, or to 
enable abbrevs, or some such.  In Lisp mode one of them might 
be used to put you into Comment Mode or something.

   Those buttons are there, after all.

   ---Wechsler


Date: 21 July 1980 09:30-EDT
From: Mike McMahon <MMCM at MIT-AI>
Sender: TAFT at MIT-AI
To: ACW at MIT-AI
cc: BUG-LISPM at MIT-AI

    Date: 20 JUL 1980 2144-EDT
    From: ACW at MIT-AI (Allan C. Wechsler)
    This is a reminder that somebody should invent the characters circle-minus
    and circle-slash someday.  Also there are a lot of greek letters still undrawn.
I drew all the characters on the new keyboard months ago; look at MMCM;NEWKBD FONT.

Date: 20 JUL 1980 2144-EDT
From: ACW at MIT-AI (Allan C. Wechsler)
To: (BUG LISPM) at MIT-AI


This is a reminder that somebody should invent the characters circle-minus
and circle-slash someday.  Also there are a lot of greek letters still undrawn.

This low-priority annoyance courtesy of
   ---Wechsler


Date: 20 JUL 1980 2135-EDT
From: Moon at MIT-AI (David A. Moon)
Subject: Volunteer labor solicited
To: INFO-LISPM at MIT-AI
CC: cwh at MIT-MC

Someone should convert the contents of the LMDEMO; directory to work in the
new window-system.  Sources are mostly on MC:.

Date: 20 JUL 1980 1814-EDT
From: HIC at MIT-AI (Howard I. Cannon)
To: (BUG LISPM) at MIT-AI

(DEFUN TIME-LESSP (TIME1 TIME2)
  (BIT-TEST -40000000 (%24-BIT-DIFFERENCE TIME1 TIME2)))

Is this code buggy?  Should it be
(bit-test 20000000 ...)?
This seems towork alot better, dividing the 23 bit region in half,
so that large differences don't get confused as being greater.

Date: 20 JUL 1980 0128-EDT
From: XCONOS at MIT-AI (Alec Destry)
To: (BUG LISPM) at MIT-AI

When you want to reset a current process with the mouse, the menu is so constructed
the KILL option is right below the RESET option.  If you jiggle the mouse a little bit,
a common occurence, you sometimes have the menu come up with the kill option
selected and you expecting the reset option selected press the mouse button and kill
your process.  Is there any way this inconvenience could be fixed?  MOON has
suggested having a confirm query attached to the KILL option.

ZVONA@MIT-AI 07/19/80 22:31:51
To: MOON at MIT-MC
CC: (BUG LISPM) at MIT-MC
    MOON@MIT-MC 07/18/80 22:31:23
        Date: 18 JUL 1980 2146-EDT
        From: Zvona at MIT-AI (David Chapman)
        To: (BUG LISPM) at MIT-AI

        In system 30.4, with microcode 671, on LISP Machine Two:

        There is a (setq base 12 ibase 12) on si:warm-initialization-list. Is this intentional?
        This change should have been warned of.
    This is not part of the system.  If it is in the dumped-out band down there
    it is a case of vandalism.  Or it may be done by some program or init file
    you loaded.  I certainly hope whoever did it did it unintentionally.
Nope, this is in vanilla 30.4 immediately after a cold boot.


Date: 19 JUL 1980 1733-EDT
From: Moon at MIT-AI (David A. Moon)
Subject: (cons x) yields no error message
To: (BUG LISPM) at MIT-AI

I have fixed this in the source by making OPTIMIZE check the number of arguments
in the case where the form is being replaced by the result of an optimizer.
There are still a number of functions which in the interpreter take an &REST
argument which is actually required to be at least one argument which this check
will not test; those functions already have checks in their optimizers for too
few arguments.

Date: 19 JUL 1980 1557-EDT
From: Moon at MIT-AI (David A. Moon)
Subject: Use of old keyboards with new window-system
To: INFO-LISPM at MIT-AI

Most of you probably already know this already, but just in case you don't:

There are certain keys used by the new window-system which only exist on the
new large keyboards.  To type those characters on the old keyboards, use the
Top key, as follows:
	Top Esc = System	(used for switching between programs)
	Top Call = Abort	(like control-G in Maclisp)
	Top Return = End	(used for ending input, mail for instance)
	Top H = Help		(this one is not new)

Date: 19 JUL 1980 1500-EDT
From: RG at MIT-AI (Richard Greenblatt)
Subject: microcompiler
To: INFO-LISPM at MIT-AI

AI:LMDOC;MCDOC > is a preliminary poop-sheet on the microcompiler.

Date: 19 JUL 1980 0300-EDT
From: Moon at MIT-AI (David A. Moon)
Subject: New system pre-release
To: INFO-LISPM at MIT-AI

System 32.1 and microcode 674 are tentatively released.  Currently
they only exist on CADR-1, but very shortly they will migrate to
CADR's 6 and 2; if no bugs show up I hope that this system can get
installed on all the machines within a week or so.  That will involve
some disruption to users, although you can of course DISK-RESTORE to
an older band if your programs have not yet been converted to the
latest system (but don't expect great amounts of sympathy for bug
reports!)

In addition to the changes in system 30, mainly involving removing the
vestiges of the old window-system, this system includes a relatively
bug-free new window-system and editor.  The garbage collector works
again.  This system includes the micro-compiler (ask RG if you want to
know how to use it.)  There are some new facilities for transferring
bands between machines which are faster and hopefully more reliable.
The microcode primitives for the old window-system have been removed
(TV-DRAW-CHAR, TV-ERASE, etc.); if you call them unfortunately the
machine will crash rather than giving you an error.  There are the usual
large number of small bug fixes.

Any qfasl file compiled in a system before 30 should be recompiled
in this system, because many symbols have been removed from the GLOBAL
package.  The list is at the end of this message; note that this is
the same list as for system 30 except that UNTYI has also been moved
from GLOBAL to USER.  (It was on the list before but it was not actually
moved due to an oversight.)

Please do not recompile any system programs in worlds older than this,
as that is very likely to cause hidden bugs.

There is a new package, TIME.  Some of the date/time functions that were
formerly in the CHAOS package randomly, are now in the TIME package.
They work better and present a more reasonable interface.  Note that
this includes NWATCH-ON and WHAT-DATE which many people call in their
init files.

The roman numeral keys on the new keyboards will only be used as mouse
buttons if the "mode lock" key, located just below them, is latched down.

The following symbols have been removed from GLOBAL; if you use any of
these in your programs you have a problem and need to convert.  Some of
these symbols are obsolete, a few were misspellings, and some have been
moved into SYSTEM.  A lot of these symbols are used as keywords,
properly requiring a colon prefix, but had been globalized so that old
programs without the colon prefix would work.  Said old programs will
now need to be fixed.

These symbols no longer exist in GLOBAL:

/' /, /; /] /` ACTIVE-WINDOWS CC-LOAD-UCODE-SYMBOLS
COMPLETING-READ-PROMPT-SIMPLE COMPLETING-READ-SIMPLE CONSOLE-IO-PC-PPR
CURRENT-JOB CURRENT-STACK-GROUP DECODE-DEFINITION ED-INITIALIZE
ED-READ-TAG-TABLE ED-REDEFINE-KEYS EDPROP EDT EDVAL EXPOSED-WINDOWS
FILE-COMMAND FILE-COMMAND-BUFFER FILE-COMMAND-CAREFUL FILE-ERROR
FILE-MAPPED-OPEN FILE-PROPERTY-VARIABLES FOR-CADR FORCE-KBD-INPUT
FREEZE-WHO-LINE GET-UNIQUE-ID INHIBIT-AUTOEXPOSE-FLAG
INHIBIT-SCREEN-RESTORATION-FLAG INHIBIT-SCREEN-SAVING-FLAG
INITIAL-STACK-GROUP INTERRUPT KBD-SIMULATED-CLOCK-FCN-LIST
KBD-SUPER-IMAGE-P LOCK-SCREEN-LAYOUT MAKE-TYPEOUT-STREAM MENU-CHOOSE
MENU-CLASS MENU-CREATE MOUSE MULTIPLE-VALUE-PASS-BACK PAINT PC-PPR
PRINT-NAME-CELL-LOCATION PROCESS-FORCED-INPUT
PROCESS-FORCED-INPUT-INDEX PROCESS-INPUT-PROCESS REAL-IO
SCHEDULER-STACK-GROUP SCREEN SELECTED-PROCESS SELECTED-WINDOW
STANDARD-PC-PPR SWITCH-REGISTER TOP-WINDOW TRIVIAL-PROCESS
UNFREEZE-WHO-LINE WHO-LINE-FROZEN WHOSTATE XOR

Also a whole bunch starting with prefixes DRAW-, JOB-, MOUSE-,
PC-PPR-, SCREEN-, and TV-.

These have been moved into the SYSTEM package:

%%HEADER-REST-FIELD %%HEADER-TYPE-FIELD %ARRAY-LEADER-LENGTH
%ERROR-HANDLER-STACK-GROUP %HEADER-TYPE-ARRAY-LEADER
%HEADER-TYPE-BIGNUM %HEADER-TYPE-COMPLEX %HEADER-TYPE-ERROR
%HEADER-TYPE-FEF %HEADER-TYPE-FLONUM %HEADER-TYPE-RATIONAL-BIGNUM
%INITIAL-STACK-GROUP %INITIALLY-DISABLE-TRAPPING ACTIVE-PROCESSES
LENGTH-OF-ATOM-HEAD

Moved into SI:

LOCALLY-KNOWN-DEVICES

These are keywords that were formerly global:

ACTIVATE-P ARG1 ARG2 BINARY BLACK BLINK BLINK-FCN BLINKER-P BLOCK BOTH
BOTTOM BOTTOM-MARGIN CAR-NUM-MODE CAR-SYM-MODE CDR-NUM-MODE
CDR-SYM-MODE CLEAR-INPUT CLEAR-OUTPUT COMPACT-CONS COMPLETE CONFIRM
CONSTRUCTOR DEFAULT-POINTER DEFS DYNAMIC END-LINE-FCN END-SCREEN-FCN
FINISH FOLLOW-P FONT-MAP FONTS FORCE-OUTPUT FORM FRESH-LINE GC
GROUPED-ARRAY HALF-PERIOD HEIGHT IN INCLUDE INTEGRAL-P LEFT LEFT-MARGIN
LINE-IN LINE-OUT LISTEN MORE-FCN MORE-P NAME NOCOMPILE NOCONFIRM NOLOAD
NORELOAD NORMAL OUT PC-PPR PDL PLANE-MASK READ-ONLY READ-POINTER
RECURSIVE REFERENCES REGION-SIZE REGULAR-PDL-AREA REGULAR-PDL-SIZE
RELOAD REPRESENTATION REVERSE-VIDEO-P RIGHT RIGHT-MARGIN ROVING-P SAFE
SELECTIVE SET-PC-PPR SG-AREA SIDEWAYS-P SINGLE SIZE SIZE-MACRO
SPECIAL-PDL-AREA SPECIAL-PDL-SIZE STATIC STRING-OUT STRUCTURE
SWAP-SV-OF-SG-THAT-CALLS-ME SWAP-SV-ON-CALL-OUT TOP TOP-MARGIN UNTYI
UNTYO UNTYO-MARK VISIBILITY VSP WHICH-OPERATIONS WHITE WIDTH WRITE

The following symbols have been added to GLOBAL.  (There may have been
others added since whichever system you are used to using.)
BEEP, INSPECT, %%KBD-HYPER, %%KBD-SUPER,
COND-EVERY, SELECTQ-EVERY, DESTRUCTURING-BIND,
GET-HANDLER-FOR, LOCATE-IN-INSTANCE, SET-IN-INSTANCE, SYMEVAL-IN-INSTANCE,
DEFINE-USER-OPTION-ALIST, DEFINE-USER-OPTION, CHOOSE-USER-OPTIONS,
RESET-USER-OPTIONS, WRITE-USER-OPTIONS,
DEFRESOURCE, WITH-RESOURCE, ALLOCATE-RESOURCE, DEALLOCATE-RESOURCE


Date: 19 JUL 1980 0258-EDT
From: Moon at MIT-AI (David A. Moon)
To: (BUG LISPM) at MIT-AI


(defun foo (x) (cons x))
(compile 'foo)

No error message!!  Generated code calls NCONS.

GJC@MIT-MC 07/18/80 23:43:17 Re: iterated SETF
To: RICH at MIT-MC
CC: (BUG LISPM) at MIT-MC
If you don't know the selector macros at compile time
then you can use the elegant construct of an alist.

Maybe it would be more efficient to use a hashed array,
there sure is a lot of ways you could implement hashed
arrays of one kind or another. If the hash aref and aset
operations sent messages to the hashed array object
(how else would you do it right?), ... sounds like
fun.

-gjc



Date: 18 JUL 1980 2237-EDT
From: MOON at MIT-MC (David A. Moon)
Subject: Iterated SETF
To: RICH at MIT-AI
CC: (BUG LISPM) at MIT-MC, (BUG LISP) at MIT-MC

Since the field definitions can be completely arbitrary, there
can be no possible elegant way of doing this with run-time variable
structure field references.  If you only want
a constant set of field definitions you can use a macro such
as the one GLS suggested, although for clarity you probably don't
want to use a MAPCAR-like syntax; maybe something more like SETQ,
e.g.	(MULTI-SETF <expression-evaluating-to-structure>
		field-name value-expression
		field-name value-expression
		...)
	    =>
	(LET ((.TEMP. <expression-evaluating-to-structure>))
	  (SETF (field-name .TEMP.) value-expression)
	  ...)

MOON@MIT-MC 07/18/80 22:31:23
To: Zvona at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date: 18 JUL 1980 2146-EDT
    From: Zvona at MIT-AI (David Chapman)
    To: (BUG LISPM) at MIT-AI

    In system 30.4, with microcode 671, on LISP Machine Two:

    There is a (setq base 12 ibase 12) on si:warm-initialization-list. Is this intentional?
    This change should have been warned of.
This is not part of the system.  If it is in the dumped-out band down there
it is a case of vandalism.  Or it may be done by some program or init file
you loaded.  I certainly hope whoever did it did it unintentionally.

Date: 18 JUL 1980 2207-EDT
From: MOON5 at MIT-AI (David A. Moon)
Subject: Shift lock key
To: (BUG LISPM) at MIT-AI, RICH at MIT-AI

In system 32 there will be a variable, SI:SHIFT-LOCK-XORS, whose default
value will be NIL.  If you LOGIN-SETQ this to T, holding down both shift
and shift lock will give you the same alphabetic case as holding down
neither (i.e. the keys will OR exclusively rather than inclusively.)
Also the roman numeral keys will only be usurped for the mouse buttons if
"mode lock" (located just below them) is latched down.

Date: 18 JUL 1980 2146-EDT
From: Zvona at MIT-AI (David Chapman)
To: (BUG LISPM) at MIT-AI

In system 30.4, with microcode 671, on LISP Machine Two:

There is a (setq base 12 ibase 12) on si:warm-initialization-list. Is this intentional?
This change should have been warned of.

Date: 18 JUL 1980 1731-EDT
From: JONL at MIT-MC (Jon L White)
Subject: MAPF
To: GLS at MIT-MC, RICH at MIT-MC
CC: GJS at MIT-MC, DANNY at MIT-MC, (BUG LISP) at MIT-MC
CC: (BUG LISPM) at MIT-MC

Say, just a reminder that NIL has snarfed the name MAPF as 
a kind of generalized mapper (see MC:NIL;NEWFUN >, and search
for MAPF).
    Date: 18 July 1980 16:59-EDT
    From: "Guy L. Steele, Jr." <GLS at MIT-AI>
    .  .  . 
    (DEFMACRO MAPF (STRUCT FIELDS LIST)
	(DO ((F FIELDS (CDR F)) . . . 
    .  .  .
    (MAPF A-FOO (FOO-REG FOO-VAL FOO-INDEX) (HACK-UP-A-3-LIST))
Also, is there any intention for this suggestion to take non-constant
lists of fields?
    Date: 18 July 1980 15:58-EDT
    From: Charles Rich <RICH at MIT-AI>
    .  .  . 
    (MAPC #'(LAMBDA (F) (SETF (F STRUC) NIL))
	  '(FIELD1 FIELD2 FIELD3 ...))
For examply, would you want to do
    (MAPC #'(LAMBDA (F) (SETF (F STRUC) NIL))
	  (MUMBLIFY))
?


Date: 18 JUL 1980 1659-EDT
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: RICH at MIT-AI
CC: (BUG LISPM) at MIT-AI, (BUG LISP) at MIT-AI, DANNY at MIT-AI
CC: GJS at MIT-AI

How about

(DEFMACRO MAPF (STRUCT FIELDS LIST)
    (DO ((F FIELDS (CDR F))
         (J 0 (+ J 1))
         (SETS '() (CONS `(SETF (,(CAR F) %%STRUCT%%) (NTH ,J %%LIST%%)) SETS)))
        ((NULL F)
         `(LET ((%%STRUCT%% ,STRUCT) (%%LIST%% ,LIST)) ,@SETS))))

(MAPF A-FOO (FOO-REG FOO-VAL FOO-INDEX) (HACK-UP-A-3-LIST))

?

Date: 18 JUL 1980 1558-EDT
From: RICH at MIT-AI (Charles Rich)
To: (BUG LISPM) at MIT-AI, (BUG LISP) at MIT-AI
CC: DANNY at MIT-AI, GJS at MIT-AI

I am having trouble figuring out an elegant way to write a function
which maps down a list of access functions, (e.g. the fields of
a DEFSTRUCT), performing  a SETF for each one.   For example,
I would like something of the following flavor to work (which
obviously doesn't because F is not evaluated at the right time
in the SETF).

(MAPC #'(LAMBDA (F) (SETF (F STRUC) NIL))
	'(FIELD1 FIELD2 FIELD3 ...))

This seems like a reasonable repetitive action which it should be
easy to specify succintly in the general framework of SETF,
LOCF, etc.

I appeal to the wizards to show me how to do this nicely; or
perhaps this suggests some new macro or extension to SETF.

		Thanks, Chuck.


Date: 18 JUL 1980 0935-EDT
From: XCONOS at MIT-AI (Alec Destry)
Sent-by: NGL at MIT-AI
To: (BUG LISPM) at MIT-AI

MICROCODE 671, SYSTEM 31.1: IN THE EDITOR DOING A SEARCH.   TYPE IN A STRING AND
WANT TO RUBOUT SOME CHARACTERS IN THAT STRING.  INSTEAD RUBOUT DOES NOTHING BUT
ECHOES AS IF IT WERE A NORMAL CHARACTER.  I HAD BEEN LOGGED FOR SOME TIME AND HAD
LOADED VARIOUS FILES.

Date: 18 JUL 1980 0645-EDT
From: XCONOS at MIT-AI (Alec Destry)
To: (BUG LISPM) at MIT-AI

System 31.1, microcode 671: do esc-a and you expect to arrest current-process.
Instead you arrest the keyboard process.  Goodbye world! you have to cold boot.

Date: 18 JUL 1980 0541-EDT
From: XCONOS at MIT-AI (Alec Destry)
To: (BUG LISPM) at MIT-AI

   Microcode 671, system 31.1: if the first argument to make-array (the area) is
T the machine will halt.

Date: 16 July 1980 17:55-EDT
From: Howard I. Cannon <HIC at MIT-MC>
Subject:  Atomic Macros
To: ALAN at MIT-MC
cc: BUG-LISP at MIT-MC, BUG-LISPM at MIT-MC, "GJC@MIT-MC  PSZGJC@MIT-MC  PSZ" at MIT-MC,
    LIL at MIT-MC

I pretty much agree with Alan, and do not think atomic macros should be in 
MacLisp or LMLisp at the moment.

Date: 16 July 1980 17:41-EDT
From: Howard I. Cannon <HIC at MIT-MC>
Subject:  LET macro
To: RICH at MIT-AI
cc: BUG-LISPM at MIT-AI

I strongly agree with DLW about destructuring let.


Date: 16 July 1980 17:40-EDT
From: Alan Bawden <ALAN at MIT-MC>
Subject: LET macro
To: RICH at MIT-AI, BUG-LISPM at MIT-AI

A destructuring LET macro for the LispMachine is available in
AI:LISPM2;LET QFASL.  The file also contains DESETQ and destructuring
LET*.

Date: 16 JUL 1980 1639-EDT
From: JONL at MIT-MC (Jon L White)
Subject: Getting to the bottome of it
To: GJC at MIT-MC
CC: (BUG LISP) at MIT-MC, (BUG LISPM) at MIT-MC, PSZ at MIT-MC

    Date: 14 July 1980 12:05-EDT
    From: George J. Carrette <GJC at MIT-MC>
    Subject: suggested compiler feature.
    (compiler-unwind-protect <form> <protected-forms ...>)
    The semantics of this are simple, during alpha conversion <form>
    is the expression which is the *value*, but the <protected-forms> are
    evaluated even if the alpha conversion of <form> causes some error.

My opinion: Can't hurt anyone, and probably useful to some.  Next case, please.

    Also: atomic-macro-of-the-first-kind.
    Which would have the following actions given that <FOO> has such 
    a property:
    A free <FOO> => <expansion of FOO>
    (setq <FOO> X) => (setf (expansion of FOO> X)
    ((lambda (<FOO>) <FORM>) X) => dissables the macro property of <FOO>
    during the expansion of <FORM>. i.e. LAMBDA is a truely transparent.
    If one wants to (BIND ((<FOO> ...)) ...) then some special BIND
    form must be used. This is of course incompatible with the
    existing semantics of special variables, but perhaps special variables
    should be changed.

    One motivation: for these things in maclisp and lmlisp is an
    implementation of closures with lexically scoped instance
    variables.

Be careful of letting a giant into the house to swat a fly.  I share the
general skeptcism shown by PSZ and ALAN about this feature, particularly
since it looks an awful lot like the discredited idea of READER symbol
macros.  Almost all good from the latter can be accomplished by the
READER character macro idea -- case in point is QUUX's suggestion a
year or two ago to use things like &#FOO to mean things like an instance
of the variable FOO, but with various declarations available for various
values of the character "#".  (e.g., &%FOO might mean "LOCAL" by 
having LAMBDA-list processing look for things like "(&LOCAL FOO)" whereever 
a variable is permitted).

  But more to the point:  Writing things like
    (DEFUN FOO (x) 
        (DECLARE (ACTOR x VAR1 VAR2 ...))
        (LIST VAR1 VAR2))
is a little more tasteful than
    (DEFUN FOO (x) 
        (LIST (INSTANCE-MACRO x VAR1) (INSTANCE-MACRO x VAR2)))
but the right way to accomplish the former is not by admitting any kind
of atomic-macros (as PSZ said, "let hear the case for atomic-macros" -- 
I don't think local closures is that case).  RWK wrote a transformation
package to accomplish this kind of conversion in MACLISP, and both
SCHEME and NIL have a more subtle mechanism for lexically-local variables.
In fact, how soon NIL implements the syntax which permits instance
variables to look like lexically locals depends on whether the lack of
this feature is a bottleneck holding back system development, or just
a minor inconvience.

    Another misdirected line of commentary concerns LET;  whether
one likes the name or not, the destructuring features seem to be
popularly useful.  Recently RMS had an interesting idea about extending
the kind of destructuring specification to be a program rather than
a data-pattern, and a "hairy" atomic-macro scheme will spoil either
one.  E.g;  (RMS-LET ((`(FOO ,x ,y) Z)) ...)        is like
            (RMS-LET (((LIST 'FOO X Y) Z)) ...),    which acts like
            ((LAMBDA (X Y) ...) (CADR Z) (CADDR Z))
or, in the current data-pattern style destructuring
            (LET (( (() X Y) Z ))  ... )            which acts the same way.
Since the atomic-macro idea really isn't the "context-free" idea of a
reader macro, it would open a miasma of expansion/evaluation questions
for these several destructuring contexts.

   Another suggested application of atomic-macros has been for
"symbolic constants" -- perhaps partly alluded to in HIC's comment
    (defatomicmacro MAGIC-VARIABLE ...)
Indeed, SYMBOLIC-CONSTANT is a declaration available in NIL, which
just setq's a variable as a global variable in the interpreter (and
marks it on its property list at toplevel), but which is handily converted 
by the compiler into a constant (rather than a special variable reference).
See MC:NIL;INCUSE >  for a description of how to use the NIL compiler,
and the examples under SYMBOLIC-CONSTANT.  The reason that this
works so well, is that the evaluation context of a SYMBOLIC-CONSTANT
is the same as a variable:
    (DECLARE (SYMBOLIC-CONSTANT PI 3.14159))
    (DEFUN (X PI Y) ...) and (DEFUN (X) (SETQ PI ...) ...)
		==> detectable errors
    (DEFUN FOO () (//$ PI 2))
		==>  (DEFUN FOO () 1.570795) during compilation
         


Date: 16 July 1980 17:08-EDT
From: Daniel L. Weinreb <DLW at MIT-AI>
Subject: LET macro
To: RICH at MIT-AI, BUG-LISPM at MIT-AI

In general, I like the Lisp Machine to be compatible with Maclisp.
However, this particular feature (destructing LET) is one that I'd
prefer not to put in.  The main reason is that it is ill-conceived; LET
is in the business of binding variables over a scope, not of parsing
list structure, and ading that functionality is as elegant as attaching
a bathtub to a bicycle just because someone might want to take a bath.
I belive that I am hardly the only person who feels this way; most of
the Lisp machine hackers I know seem to agree.  Furthermore, this is a
very new Maclisp feature, and "old programs" will not die in droves if
we leave it out.  I'd prefere to put in a DESTRUCTURE function or
special form for this purpose, and make it availible to Maclisp users
by putting it in LIBLSP, for people who either don't like destructuring
LET or want to be compatible or both.

Date: 16 JUL 1980 1613-EDT
From: RICH at MIT-AI (Charles Rich)
To: (BUG LISPM) at MIT-AI

In system `29.95 NWS, with microcode 669, on LISP Machine Eight:
I did a (PACKAGE-DECLARE FOO... (("dir;fn1"))), assuming PKG-LOAD would interpret
the lack of FN2 the same as LOAD, i.e. fasload the QFASL if any, otherwise
the ">" version.  This works fine the first time, but if you do (PKG-LOAD 'FOO)
twice in a row, it asks to load in all the files it fasloaded once again.  It seems
like it is not remembering this case properly.
		-Chuck


Date: 16 JUL 1980 1056-EDT
From: RICH at MIT-AI (Charles Rich)
Subject:  LET macro
To: (BUG LISPM) at MIT-AI

How about making the Lispm LET (and LET*) macro a destructuring
LET compatible with the current default in Maclisp.  This is a very
useful feature which could probably be simply implemented by calling
some of the code for processing DEFMACRO arguments.

Date: 16 JUL 1980 0602-EDT
From: XCONOS at MIT-AI (Alec Destry)
To: (BUG LISPM) at MIT-AI

system 31.1, microcode 671 on cadr 1.  C-z has problems both in the editor and in lisp.
I had just logged in and went to the editor, went into a breakloop and typed

(do ()(())(princ (multiple-value-list (tv:mouse-input)))(terpri))

C-z refused to throw me out of the above do loop.  The same thing happens at top level in lisp.

Date: 15 July 1980 23:41-EDT
From: Howard I. Cannon <HIC at MIT-MC>
Subject:  suggested feature.
To: PSZ at MIT-ML
cc: GJC at MIT-MC, BUG-LISP at MIT-MC, BUG-LISPM at MIT-MC

I think that people perceive symbols when used as special variables
as having some "character" that they carry around with them (much
like declared identifiers in other languages).  If you implement
atomic macros, then you have these symbols that have this character
of expanding into something else when mentioned.  

Now, you might argue that even though that is true, symbols when QUOTED
don't retain any special meaning, and symbols in lambda lists and
setq's are implictly quoted.  Therefore, they should not expand into atomic
macros (I am not proposing that explicitly QUOTEd symbols expand, though
there might be something pleasing about this).  I do not agree with this.
Though it is true that symbols in those positions are not EVALUATED,
they are certainly looked at specially (for specialness, for example,
at least by the compiler).  I therefore think that for consistancy they
should expand if they are atomic macros.  This may of course produce
erroneous results in some circumstances (probably most!).  So what.

Personnally, I don't like destructuring LET either, and I don't
use it (I call it something different if that is the functionality I want).
On the other hand, I don't see atomic macros as being the same thing at all
(of course, I believe treating each thing individually on the basis
of its meri makes sense).  My proposal also makes SET' different from SETQ,
which is probably ok (though I supose there might be some sort of symmetry
argument against the atomic macro thing here).

But, I don't know why I bother explaing this, since you "hate
to see Lisp get cluttered up with bad ideas", you must have already decided
that atomic macros is a bad idea.

--Howard


PSZ@MIT-ML 07/15/80 22:32:15 Re: suggested feature.
To: GJC at MIT-MC, HIC at MIT-MC
CC: (BUG LISP) at MIT-ML, (BUG LISPM) at MIT-ML
I am having a hard time following the argument about how atom-macros
ought to be treated in lambda lists because I have yet to see any
interesting demonstration that they are at all useful and defensible.  I
hate to see Lisp get cluttered up with bad ideas (e.g., the recent
intrusion of automatic destructuring in many macro packages -- forcing
one into explicit dependence on the precise layout of various data
structures) without more of a discussion of what is to be gained.  Would
someone care to present the needed case for this?


Date: 16 JUL 1980 0226-EDT
From: KMP at MIT-MC (Kent M. Pitman)
Subject: Funny symbols/strings
To: (BUG LISP) at MIT-MC, (BUG LISPM) at MIT-MC, NIL at MIT-MC

What would people think of having #\\RETURN, #\\LINEFEED, etc. turn into
the char designated... or can someone suggest a better way to get the effect
of #.(ASCII #\RETURN) which is what I am resorting to now? There doesn't seem
to me any reason that the alist which #\ uses can't include entries like
(... (RETURN . #.(ASCII 13.)) (LINEFEED . #.(ASCII 10.)) ...). Yes, I am
interested in this returning a symbol I can PUTPROP to -- even on machines
that have character objects available. I realize that there may be some 
discussion on this point. Perhaps a different set of keys which would return
char objects if the Lisp had them and something else on the more primitive
Lisps. Comments?
-kmp

ps apologies in advance for duplications of this message


Date: 16 JUL 1980 0117-EDT
From: ALAN at MIT-MC (Alan Bawden)
Subject: Atomic Macros
To: (BUG LISP) at MIT-MC, (BUG LISPM) at MIT-MC, GJC at MIT-MC
To: HIC at MIT-MC, PSZ at MIT-MC
CC: LIL at MIT-MC

Perhaps we should be working towards a "Fusion Macro"?

Seriously, I would like to offer some arguments about atomic macros.
First let me say that I am opposed to adding atomic macros to MacLisp
or LispMachine lisp.  My reasons for this are probably similar to
PSZs: although the feature has some merit, it is really not something
that can be added to the language at this point without causing
complete and total upheaval.

SET and PROGV are one problem.  Another: suppose we say that
(LET ((X 0)) ...) atomicmacroexpands the X to see if it is going to
expand into another symbol.  What if it expands into (MUMBLE 'X)?  Do
we continue to macroexpand, or do we stop and destructure?  (I don't
like destructuring either, but there it is.)  If you think we should
continue to macroexpand then suppose the guy wrote
(LET (((MUMBLE 'X) 0)) ...) in the first place?  If you think we
should destructure then by what right do you differentiate between
X => (MUMBLE 'X) =>Y and X => Y ("=>" indicates one level of
macroexpansion)?

Perhaps you can solve these problems, (I just thought of a way out
myself) but there are going to be others you haven't thought of yet.
In particular you have just screwed every macro writer who ever did
(ATOM FOO) to determine if it was safe to substitute the value of FOO
directly into some code that might evaluate it twice.  ("But nobody in
their right mind would define an atomic macro whose expansion
evaluated with side effects" I can hear several people yelling...  I
know.)

I bet I can think up more.  I bet nobody is willing to put the effort
into implimenting them.  I bet we can continue to live without them.

Now, for those of you who are wondering why I put atomic macros into
LIL if I think they are such losers:

1) In LIL we have no destructuring.

2) LIL has no interpreter where there are symbols that can be passed as
arguments to things like SET and PROGV.

3) We don't let atomic macros do anything in LETs, it is an error to
do (LET ((X 0)) ...) if X is an atomic macro.  This is so that we can
do the right thing when we decide what that is.  I tend to think that
the HIC solution (GJC's "atomic macro of the second kind") is the right one
at the moment.

4) Since LIL is growing from the ground up, we have no commitment to any
other past features that might screw us.

5) We have no users with existing code that this might break.

Basically the point is that this atomic macro thing is a good idea,
but only as something you have in mind from day 1, not something that
you add in 10 years later when you first think of it.

Date: 16 July 1980 00:42-EDT
From: George J. Carrette <GJC at MIT-MC>
Subject:  Bad ideas
To: PSZ at MIT-ML
cc: HIC at MIT-MC, BUG-LISP at MIT-MC, BUG-LISPM at MIT-MC

    Date: 07/15/80 23:22:16
    From: PSZ at MIT-ML
    To:   hic
    cc:   (BUG LISP) at MIT-ML, (BUG LISPM) at MIT-ML, GJC at MIT-ML
    Re:   Bad ideas

    My a priori belief shows through in my phrasing, but I am by no means immune
    to a good argument.  I was really just expressing a desire for some consensus
    on it before it gets installed and I begin to see (dread the thought) things
    like my perfectly reasonable
    	(setq space 3000)
    turn behind my back into
    	(setq 40 3000),
    as I think it likely that such "expanding constants" will be one plausible use
    of the facility you are planning.  Please note that I am not yet prepared to
    argue the details (e.g., whether expansion should happen in quoted contexts,
    implicitly quoted contexts, whether it should be lexically or dynamically
    specified, or any such meaty issues).  I am still searching for a good case
    to be made for the fundamental idea.  Although I have at times had cravings for
    just such a feature, some reflection has so-far dissuaded me (like some
    cravings for giant anchovy pizzas).  Someone please step forward and
    demonstrate a program in which having this feature is a big win, outweighing
    the disadvantage of further weakening the transparency of Lisp.


Well, what I was doing (just so happens in maclisp), was
implementing closures with lexically scoped instance variables,
as apposed to the special variables which the lisp machine uses.

(defclosure foo (a b c d)
	    ((sum 0)) ; def-struct like specs.
     
           ...body ...)

(setq q (make-foo-closure ... defstruct-like specifications ...))

(call q 1 2 3) =>

(lsubrcall t (pointer-slot q) (data-slot q) 1 2 3)

simple eh? What actually gets defined for FOO is an
lsubr which takes as its first argument a HUNK with the
environment.  Since SUM is an instance variable you want
SUM to expand into (CXR <17> DATA) and (SETQ SUM FOO) to
go to (SETF (CXR <17> DATA) FOO). The defstruct-like
instance variable specs are actually used as a defstruct
to define the variable structure. (A HUNK in haclisp, oops, I
mean maclisp)

However, if in the body we have (LET ((SUM 34)) we DON'T want
that to be (LET (((CXR 3 DATA) 34) ...) !!!! 

To further complicate things, I want the so-called ATOM-MACRO
properties to be in effect LOCAL to the BODY only. They
do not want to be global properties.

I know that using these atomic-macros-of-the-first-kind
DOES NOT INTERFERE WITH THE TRANSPARENCY OF LISP.
Note: any SETQ of a special variable does not qualify as
being transparent lisp programming anyway.

HIC may want to use atomic-macros-of-the-SECOND-kind, and so
might I for other purposes. I don't think that one excludes
the other. Although the ones I want would be harder to implement.



PSZ@MIT-ML 07/15/80 23:22:16 Re: Bad ideas
To: hic at MIT-MC
CC: (BUG LISP) at MIT-ML, (BUG LISPM) at MIT-ML, GJC at MIT-ML
My a priori belief shows through in my phrasing, but I am by no means immune
to a good argument.  I was really just expressing a desire for some consensus
on it before it gets installed and I begin to see (dread the thought) things
like my perfectly reasonable
	(setq space 3000)
turn behind my back into
	(setq 40 3000),
as I think it likely that such "expanding constants" will be one plausible use
of the facility you are planning.  Please note that I am not yet prepared to
argue the details (e.g., whether expansion should happen in quoted contexts,
implicitly quoted contexts, whether it should be lexically or dynamically
specified, or any such meaty issues).  I am still searching for a good case
to be made for the fundamental idea.  Although I have at times had cravings for
just such a feature, some reflection has so-far dissuaded me (like some
cravings for giant anchovy pizzas).  Someone please step forward and
demonstrate a program in which having this feature is a big win, outweighing
the disadvantage of further weakening the transparency of Lisp.


Date: 15 July 1980 23:51-EDT
From: Howard I. Cannon <HIC at MIT-MC>
Subject:  suggested compiler feature.
To: GJC at MIT-MC
cc: BUG-LISP at MIT-MC, BUG-LISPM at MIT-MC

The reasoning behind expanding atomic macros in lambda lists (in my mind)
is that you might define something like:
(defatomicmacro MAGIC-VARIABLE
	<the particular magic variable for this program>)

and you could then use MAGIC-VARIABLE all over the place and have
it be replaced automatically (this could be great for macro 
packages and the like, I suspect).  Anyway, that's the basic theory.


Date: 15 July 1980 22:43-EDT
From: George J. Carrette <GJC at MIT-MC>
Subject:  suggested compiler feature.
To: HIC at MIT-MC
cc: BUG-LISP at MIT-MC, BUG-LISPM at MIT-MC

    Date: 15 July 1980 16:13-EDT
    From: Howard I. Cannon <HIC at MIT-MC>
    To:   GJC
    cc:   BUG-LISP, BUG-LISPM
    Re:   suggested compiler feature.

    I meant to imply in my previous message that I think that GJC's
    lambda-list sggstion is also wrong.

I might have to agree with you on that. The reason that I suggested
that LAMBDA push away atomic macro properties is to meet the
objection of EB, that is, that (SETQ <ATOM> ...) only mean to
setq a variable. In the case of a lexically apparent variable
EB could be confident that (SETQ <ATOM> ...)  meant only
a very efficient and simple thing. SETQ of a special variable
would be another thing entirely. 

Implementing the lambda-list suggestion in the interpreter
would be non-trivial. All lambda expressions would have to
have a pointer to the lexical contour in which they
where created. 

Anyway, what is the right thing to do in lambda-lists?



Date: 15 July 1980 16:13-EDT
From: Howard I. Cannon <HIC at MIT-MC>
Subject:  suggested compiler feature.
To: GJC at MIT-MC
cc: BUG-LISP at MIT-MC, BUG-LISPM at MIT-MC

I meant to imply in my previous message that I think that GJC's
lambda-list sggstion is also wrong.


Date: 15 July 1980 16:11-EDT
From: Howard I. Cannon <HIC at MIT-MC>
Subject:  suggested compiler feature.
To: EB at MIT-AI
cc: GJC at MIT-MC, BUG-LISP at MIT-MC, BUG-LISPM at MIT-MC

I think that SETQ should know about atomic macros -- at least it
should give you a warning.  One of the major ideas behind atomic
macros is that you can use the atom without knowing whether or not
it will expand.  Note that the problem also arises when yo use an atomic
macro in a lambda-list.


Date: 15 JUL 1980 1118-EDT
From: BAK at MIT-AI (William A. Kornfeld)
Subject: Joystick mouse
To: (BUG LISPM) at MIT-AI

If it were centered under the space bar it wouldn't get in the way.


Date: 15 July 1980 10:15-EDT
From: John L. Kulp <JLK at MIT-MC>
Subject:  cadr7 joystick mouse
To: CPR at MIT-EE
cc: BUG-LISPM at MIT-MC

My 2 cents...I found it very annoying where it is now.  Perhaps if it were
located in the front of the keyboard, where you could still get at it with
your thumb easily, but it wouldn't get in the way normally, would be more
the right thing.


Date: Tuesday, 15 July 1980  04:55-EDT
From: Chris Ryland <CPR at MIT-EE>
to: (BUG LISPM) at MIT-AI
Subject: cadr7 joystick mouse


    From: cent at MIT-AI (Pandora B. Berman)
    what happened to the mouse buttons? they are kind of useful, i hear
Roman I, II, III take the place of the three buttons (though I'm not
sure typing them quickly doubles them).
    i cannot say strongly enough that whatever its other virtues or vices,
        IT SHOULDN'T BE BELOW THE KEYBOARD. it is simply in the way. a
        lower profile would not help enough to counteract the awkwardness
        of having it in the way. it should be moved. possibly above the keyboard?
        i suppose that either side is to far away for fingers attempting to type.
I disagree strongly.  A touch typist needs to keep her/his hands in
the 'home' position at all times, and having the frob within easy
reach of the right thumb (either thumb?) is JUST the right place for
it, if it could be lowered so that normal typing wouldn't be
interfered with.  Oh well, I guess this is one of those questions of
taste; some will always hate it, and some will love it.  How do you
make a reasonable compromise?  Provide both kinds of mice always with
each LISPM?  (How about people who can't stand the frob right below
the space bar?)

Date: 15 JUL 1980 0445-EDT
From: cent at MIT-AI (Pandora B. Berman)
Subject: cadr7 joystick mouse
To: (BUG LISPM) at MIT-AI

    Date: 15 JUL 1980 0316-EDT
    From: cpr at MIT-AI (Christopher P. Ryland)

    I really like the force-sensitive thumbfrob (frog?) on CADR7.
    Several suggestions (which are probably not news, but anyway..): it really needs
    to have a lower profile so it doesn't get in th way of typing; I guess there's
    a tradeoff in terms of leverage.  It also seems to 'drift' a little when you're
    trying to finely move it.

as one who has to contend with that thing at least as much as anyone else,
due to its location in the lm factory:
i am ambivalent about the joystick as a pointing sort of mouse;
what happened to the mouse buttons? they are kind of useful, i hear
    (i don't use mice much, but it doesn't look like this one has
     any buttonoid facility);
i cannot say strongly enough that whatever its other virtues or vices,
    IT SHOULDN'T BE BELOW THE KEYBOARD. it is simply in the way. a
    lower profile would not help enough to counteract the awkwardness
    of having it in the way. it should be moved. possibly above the keyboard?
    i suppose that either side is to far away for fingers attempting to type.

all in all, why not stick to a regular mouse?

Date: 15 JUL 1980 0316-EDT
From: cpr at MIT-AI (Christopher P. Ryland)
To: (BUG LISPM) at MIT-AI

I really like the force-sensitive thumbfrob (frog?) on CADR7.
Several suggestions (which are probably not news, but anyway..): it really needs
to have a lower profile so it doesn't get in th way of typing; I guess there's
a tradeoff in terms of leverage.  It also seems to 'drift' a little when you're
trying to finely move it.


Date: 15 JUL 1980 0308-EDT
From: cpr at MIT-AI (Christopher P. Ryland)
To: (BUG LISPM) at MIT-AI

In system 29.96 NWS, with microcode 669, on LISP Machine Seven:
Trying to (telnet 'ee t) and failing (apparently, CADR7 can't talk to EE?), then trying
again, and finally hitting BREAK when I got the third 'connect to host:' prompt,
wedged with ARREST in the wholine.  Coldbooting was the only recourse (warm booting
did frob at the disk for a while but the keyboard was forever ignored).


ZVONA@MIT-AI 07/14/80 19:17:51
To: MOON at MIT-MC, HIC at MIT-MC
CC: RMS at MIT-AI, ACW at MIT-MC, (BUG LISPM) at MIT-MC
    MOON@MIT-MC 07/14/80 15:44:41
        Date: 14 July 1980 07:04-EDT
        From: Howard I. Cannon <HIC at MIT-MC>
        To: MOON at MIT-MC
        cc: ACW at MIT-MC, BUG-LISPM at MIT-MC, RMS at MIT-AI

        No, the only way to get rid of that pop-up window is with the mouse.
    ?.  Clicking the mouse on any part of the window partially covered by
    that window makes the pop-up window go away, which seems quite
    straightforward and easy.  I don't see what point there would be to
    a keyboard command to substitute for a non-unwieldy mouse operation.
Some people find all mouse operations inherently unweildy. One of the nice things
about NWS is you never have to use it.


Date: 14 JUL 1980 1921-EDT
From: Moon at MIT-AI (David A. Moon)
To: INFO-LISPM at MIT-AI

Someone deinstalled the new system from CADR-1.  It is reasonable to do
this if something changed in it is interfering with your work and seems
to be broken.  It is NOT reasonable to do this without sending mail
to bug-lispm saying what you did and why.  Bugs that aren't reported
don't get fixed.

Date: 14 JUL 1980 1752-EDT
From: KASS at MIT-AI (Michael H. Kass)
To: (BUG LISPM) at MIT-AI

Two suggestions for future Lisp Machine Software:

1) If mouse movements were related to velocity on 
a log scale, it might be easier to finely position
the mouse while still being able to quickly move
it from one end of the screen to the other.

2) It is often useful to be able to use logical 
predicates on numbers with 0 treated as nil and
anything else treated as t.  In particular, it 
would make hardware simulation cleaner and help 
out when storing boolean quantities in art-1b arrays.

Date: 14 JUL 1980 1729-EDT
From: RICH at MIT-AI (Charles Rich)
To: (BUG LISPM) at MIT-AI

In system `29.95 NWS, with microcode 669, on LISP Machine Eight:
The functions ARG1 and ARG2 are protected in GLOBAL, but their
property list is NIL.  Is this an anachronism?

Date: 14 JUL 1980 1626-EDT
From: TAFT at MIT-AI (Jonathan D. Taft)
Subject: BITBLT arg checking ?
To: (BUG LISPM) at MIT-AI


   While BITBLTing I happened to quote the TV:ALU-FUNCTION argument [ 'TV:ALU-SETA ].
Instead of dying in any reasonable fashion some gross unknown quantity got mashed into
some microinstruction and the machine went off the deep end. Not only was there no
argument check (perhaps OK for speed ?) but apparently the ALU spec was not even
masked to fit into its field. The reason this seems important was because of the degree
of machine death induced. It was not possible to warm OR cold boot from the keyboard,
I had to frob the wire. (It was not a question of number of trys or anything - I can
repeat it.)

MOON@MIT-MC 07/14/80 15:44:41
To: HIC at MIT-MC
CC: ACW at MIT-MC, (BUG LISPM) at MIT-MC, RMS at MIT-AI
    Date: 14 July 1980 07:04-EDT
    From: Howard I. Cannon <HIC at MIT-MC>
    To: MOON at MIT-MC
    cc: ACW at MIT-MC, BUG-LISPM at MIT-MC, RMS at MIT-AI

    No, the only way to get rid of that pop-up window is with the mouse.
?.  Clicking the mouse on any part of the window partially covered by
that window makes the pop-up window go away, which seems quite
straightforward and easy.  I don't see what point there would be to
a keyboard command to substitute for a non-unwieldy mouse operation.

Date: 14 July 1980 14:00-EDT
From: Edward Barton <EB at MIT-AI>
Subject: suggested compiler feature.
To: GJC at MIT-MC, BUG-LISP at MIT-MC, BUG-LISPM at MIT-MC

    Date: 14 JUL 1980 1205-EDT
    From: GJC at MIT-MC (George J. Carrette)
    Also: atomic-macro-of-the-first-kind.
    Which would have the following actions given that <FOO> has such 
    a property:
    A free <FOO> => <expansion of FOO>
    (setq <FOO> X) => (setf (expansion of FOO> X)
    ((lambda (<FOO>) <FORM>) X) => dissables the macro property of <FOO>
    during the expansion of <FORM>. i.e. LAMBDA is a truely transparent.
    If one wants to (BIND ((<FOO> ...)) ...) then some special BIND
    form must be used. This is of course incompatible with the
    existing semantics of special variables, but perhaps special variables
    should be changed.
I'd like to cast a vote against making (SETQ <atom> <exp>) do anything
except SETQ a variable.



Date: 14 JUL 1980 1205-EDT
From: GJC at MIT-MC (George J. Carrette)
Subject: suggested compiler feature.
To: (BUG LISP) at MIT-MC, (BUG LISPM) at MIT-MC

(compiler-unwind-protect <form> <protected-forms ...>)

The semantics of this are simple, during alpha conversion <form>
is the expression which is the *value*, but the <protected-forms> are
evaluated even if the alpha conversion of <form> causes some error.

Also: atomic-macro-of-the-first-kind.

Which would have the following actions given that <FOO> has such 
a property:

A free <FOO> => <expansion of FOO>
(setq <FOO> X) => (setf (expansion of FOO> X)

((lambda (<FOO>) <FORM>) X) => dissables the macro property of <FOO>
during the expansion of <FORM>. i.e. LAMBDA is a truely transparent.
If one wants to (BIND ((<FOO> ...)) ...) then some special BIND
form must be used. This is of course incompatible with the
existing semantics of special variables, but perhaps special variables
should be changed.

One motivation: for these things in maclisp and lmlisp is an
implementation of closures with lexically scoped instance
variables.

The claimed need for "compiler-unwind-protect" is that it is
not kosher for macros to call the compilers macro-expander.

-gjc



JLK@MIT-MC 07/14/80 11:41:04
To: (BUG LISPM) at MIT-MC
The extension listed in the ttyloc for CADR3 should be x6769
This also applies to CADR5.  x3483 doesn't seem to apply to any of the phones in the area.


Date: 14 July 1980 07:04-EDT
From: Howard I. Cannon <HIC at MIT-MC>
To: MOON at MIT-MC
cc: ACW at MIT-MC, BUG-LISPM at MIT-MC, RMS at MIT-AI

No, the only way to get rid of that pop-up window is with the mouse.
I don't consider that to be very convenient.  I think we need a keyboard
command that flushes the thing, and later you can use Terminal 0 S.
I realize that Terminal C-T does that, but I think we need something that
onyl applies to the notification pop-up windows.


MOON@MIT-MC 07/14/80 03:50:45
To: RMS at MIT-AI
CC: ACW at MIT-MC, (BUG LISPM) at MIT-MC
    Date: 13 JUL 1980 0203-EDT
    From: RMS at MIT-AI (Richard M. Stallman)
    To: (BUG LISPM) at MIT-AI

    A version of the NWS documentation says that when a notification window
    appears the user has no choice but to click it and make the window which
    wants to appear appear.

    He ought to be able to make the notification window go away and then
    type TERMINAL 0 S when he wants to see the window which the notification
    was about.

It behaves just as you describe.  Allan, please fix the documentation.

Date: 13 July 1980 13:44-EDT
From: Howard I. Cannon <HIC at MIT-MC>
To: RMS at MIT-AI
cc: BUG-LISPM at MIT-AI

The disk control on CADR8 is broken, and probably should be replaced
if there is a spare around.


Date: 13 JUL 1980 0309-EDT
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

In system `29.95 NWS, with microcode 669, on LISP Machine Eight:

Halts every 20 minutes at (AWAIT-DISK 2) with
XBUS-PAR-ERR and XBUS-NXM-ERR.  Warm booting once
has no visible effect but a second warm boot starts up ok.


Date: 13 JUL 1980 0203-EDT
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

A version of the NWS documentation says that when a notification window
appears the user has no choice but to click it and make the window which
wants to appear appear.

He ought to be able to make the notification window go away and then
type TERMINAL 0 S when he wants to see the window which the notification
was about.


Date: 12 JUL 1980 0233-EDT
From: Moon at MIT-AI (David A. Moon)
Subject: P.S. to previous message
To: INFO-LISPM at MIT-AI

System 30.3 is tentatively installed on CADR-6 as well as CADR-1.

Date: 12 JUL 1980 0220-EDT
From: MOON at MIT-AI (David A. Moon)
Subject: New system pre-release
To: INFO-LISPM at MIT-AI

System 30.3 has been tentatively installed on CADR-1 for the benefit of those
who want to test their programs.  There are a number of incompatible changes
described later in this message which will necessitate recompilation for
some people and actual program changes for those who are still using functions
of the old window-system.  The 30 series system will be installed on most
machines sometime next week, assuming there aren't too many bugs.

Please do not copy this system to any other machine yet (in fact 30.3 will not
boot on a machine without a color screen, but that will be fixed in 30.4,
hopefully tomorrow.)

Please do not recompile any system programs in worlds older than this,
as that is very likely to cause hidden bugs.

Lisp machine systems 30 and above contain only the "new" window system.
The vestiges of the old window system present in previous systems (with
the "nws" designation) have been removed.  In addition, the GLOBAL
package has been cleaned up.  It is advisable that you recompile your
programs in this system before trying to run them, both because of
symbols having changed packages and because of some other changes
including the value of the #\MOUSE-n-n syntax.  If you need help
in converting please contact HIC, Moon, or MMcM.

There is a new package, TIME.  Some of the date/time functions that were
formerly in the CHAOS package randomly, are now in the TIME package.
They work better and present a more reasonable interface.

The following symbols have been removed from GLOBAL; if you use any of
these in your programs you have a problem and need to convert.  Some of
these symbols are obsolete, a few were misspellings, and some have been
moved into SYSTEM.  A lot of these symbols are used as keywords,
properly requiring a colon prefix, but had been globalized so that old
programs without the colon prefix would work.  Said old programs will
now need to be fixed.

These symbols no longer exist in GLOBAL:

/' /, /; /] /` ACTIVE-WINDOWS CC-LOAD-UCODE-SYMBOLS
COMPLETING-READ-PROMPT-SIMPLE COMPLETING-READ-SIMPLE CONSOLE-IO-PC-PPR
CURRENT-JOB CURRENT-STACK-GROUP DECODE-DEFINITION ED-INITIALIZE
ED-READ-TAG-TABLE ED-REDEFINE-KEYS EDPROP EDT EDVAL EXPOSED-WINDOWS
FILE-COMMAND FILE-COMMAND-BUFFER FILE-COMMAND-CAREFUL FILE-ERROR
FILE-MAPPED-OPEN FILE-PROPERTY-VARIABLES FOR-CADR FORCE-KBD-INPUT
FREEZE-WHO-LINE GET-UNIQUE-ID INHIBIT-AUTOEXPOSE-FLAG
INHIBIT-SCREEN-RESTORATION-FLAG INHIBIT-SCREEN-SAVING-FLAG
INITIAL-STACK-GROUP INTERRUPT KBD-SIMULATED-CLOCK-FCN-LIST
KBD-SUPER-IMAGE-P LOCK-SCREEN-LAYOUT MAKE-TYPEOUT-STREAM MENU-CHOOSE
MENU-CLASS MENU-CREATE MOUSE MULTIPLE-VALUE-PASS-BACK PAINT PC-PPR
PRINT-NAME-CELL-LOCATION PROCESS-FORCED-INPUT
PROCESS-FORCED-INPUT-INDEX PROCESS-INPUT-PROCESS REAL-IO
SCHEDULER-STACK-GROUP SCREEN SELECTED-PROCESS SELECTED-WINDOW
STANDARD-PC-PPR SWITCH-REGISTER TOP-WINDOW TRIVIAL-PROCESS
UNFREEZE-WHO-LINE WHO-LINE-FROZEN WHOSTATE XOR

Also a whole bunch starting with prefixes DRAW-, JOB-, MOUSE-,
PC-PPR-, SCREEN-, and TV-.

These have been moved into the SYSTEM package:

%%HEADER-REST-FIELD %%HEADER-TYPE-FIELD %ARRAY-LEADER-LENGTH
%ERROR-HANDLER-STACK-GROUP %HEADER-TYPE-ARRAY-LEADER
%HEADER-TYPE-BIGNUM %HEADER-TYPE-COMPLEX %HEADER-TYPE-ERROR
%HEADER-TYPE-FEF %HEADER-TYPE-FLONUM %HEADER-TYPE-RATIONAL-BIGNUM
%INITIAL-STACK-GROUP %INITIALLY-DISABLE-TRAPPING ACTIVE-PROCESSES
LENGTH-OF-ATOM-HEAD

Moved into SI:

LOCALLY-KNOWN-DEVICES

These are keywords that were formerly global:

ACTIVATE-P ARG1 ARG2 BINARY BLACK BLINK BLINK-FCN BLINKER-P BLOCK BOTH
BOTTOM BOTTOM-MARGIN CAR-NUM-MODE CAR-SYM-MODE CDR-NUM-MODE
CDR-SYM-MODE CLEAR-INPUT CLEAR-OUTPUT COMPACT-CONS COMPLETE CONFIRM
CONSTRUCTOR DEFAULT-POINTER DEFS DYNAMIC END-LINE-FCN END-SCREEN-FCN
FINISH FOLLOW-P FONT-MAP FONTS FORCE-OUTPUT FORM FRESH-LINE GC
GROUPED-ARRAY HALF-PERIOD HEIGHT IN INCLUDE INTEGRAL-P LEFT LEFT-MARGIN
LINE-IN LINE-OUT LISTEN MORE-FCN MORE-P NAME NOCOMPILE NOCONFIRM NOLOAD
NORELOAD NORMAL OUT PC-PPR PDL PLANE-MASK READ-ONLY READ-POINTER
RECURSIVE REFERENCES REGION-SIZE REGULAR-PDL-AREA REGULAR-PDL-SIZE
RELOAD REPRESENTATION REVERSE-VIDEO-P RIGHT RIGHT-MARGIN ROVING-P SAFE
SELECTIVE SET-PC-PPR SG-AREA SIDEWAYS-P SINGLE SIZE SIZE-MACRO
SPECIAL-PDL-AREA SPECIAL-PDL-SIZE STATIC STRING-OUT STRUCTURE
SWAP-SV-OF-SG-THAT-CALLS-ME SWAP-SV-ON-CALL-OUT TOP TOP-MARGIN UNTYI
UNTYO UNTYO-MARK VISIBILITY VSP WHICH-OPERATIONS WHITE WIDTH WRITE

The following symbols have been added to GLOBAL.  (There may have been
others added since whichever system you are used to using.)
BEEP, INSPECT, %%KBD-HYPER, %%KBD-SUPER,
COND-EVERY, SELECTQ-EVERY, DESTRUCTURING-BIND,
GET-HANDLER-FOR, LOCATE-IN-INSTANCE, SET-IN-INSTANCE, SYMEVAL-IN-INSTANCE,
DEFINE-USER-OPTION-ALIST, DEFINE-USER-OPTION, CHOOSE-USER-OPTIONS,
RESET-USER-OPTIONS, WRITE-USER-OPTIONS,
DEFRESOURCE, WITH-RESOURCE, ALLOCATE-RESOURCE, DEALLOCATE-RESOURCE

Date: 12 JUL 1980 0128-EDT
From: BAK at MIT-AI (William A. Kornfeld)
Subject:  Compiler screwage
To: (BUG LISPM) at MIT-AI

In system 29.95:

When compiling the function:

(defun foo ()
  (let ((a-variable 3))
    (let ((func #'(lambda () a-variable)))
      (funcall func)
      a-variable)))

the compiler gives the warning:

<<When compiling FOO>>
Warning: A-VARIABLE declared special.

What really happens is that A-VARIABLE is declared special in FOO-INTERNAL-G0034
and not in FOO.  (The code, of course, loses because A-VARIABLE is NOT special in
FOO.)  If the compiler is not smart enough to fix this error by either passing the
variable to the internal function or declaring it special in the outer function,
it should at least print a correct warning.

MOON@MIT-MC 07/11/80 19:39:43
To: RICH at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date: 11 JUL 1980 1450-EDT
    From: RICH at MIT-AI (Charles Rich)
    To: (BUG LISPM) at MIT-AI

    In system `29.95 NWS, with microcode 669, on LISP Machine Eight:
    It would be nice if in the case of a File Not Found error (from LOAD),
    if there was a way to continue with a different file name.
    I tried control-C, but that just retries the same filename.  Meta-C
    did not seem like the right thing to try, right?
The only way provided currently is to c-N up to the place where the file
name came in and do a c-R supplying the same function and new args, or
else change the arg sitting there and do a c-m-R (the former is usually easier
since in the non-window error-handler changing an arg is painful.)

MOON@MIT-MC (Sent by MOON5@MIT-MC) 07/11/80 16:55:07 Re: ALAN's bug report: :TAGS losing half the files.
To: (BUG TAGS) at MIT-MC
CC: (BUG LISPM) at MIT-MC
Oh, now I understand how I was getting totally screwed the other day
while trying to edit lisp machine code in Emacs using the tags files,
from which lots of files seemed to be missing.  All the tags files
will probably have to be regenerated by hand (the lists of files that
go in them, that is.)

Date: 11 JUL 1980 1450-EDT
From: RICH at MIT-AI (Charles Rich)
To: (BUG LISPM) at MIT-AI

In system `29.95 NWS, with microcode 669, on LISP Machine Eight:
It would be nice if in the case of a File Not Found error (from LOAD),
if there was a way to continue with a different file name.
I tried control-C, but that just retries the same filename.  Meta-C
did not seem like the right thing to try, right?
			Thanks, Chuck.


Date: 10 JUL 1980 1802-EDT
From: MMcM at MIT-AI (Mike McMahon)
To: (BUG LISPM) at MIT-AI

(AR-2 2D-BIT-ARRAY -1 LARGISH-NUMBER) dies in various graceless ways
trying to complain about the second argument.  Apparently something has
a bad data type, because it usually claims #<DTP-EXTENDED-NUMBER nnn>
for that, but sometimes ILLOP's if nnn is out of range.


Date: 10 JUL 1980 1724-EDT
From: MMcM at MIT-AI (Mike McMahon)
To: (BUG LISPM) at MIT-AI

The error message for (cdadr '(foo bar)) is deceptive, claiming that bar
was the argument to cdadr.  Since information has presumably been lost,
the message should be modified to be less commital.


Date:  9 JUL 1980 1937-EDT
From: Zvona at MIT-AI (David Chapman)
Subject: obnoxious overoptimizing compiler bug
To: (BUG LISPM) at MIT-AI

In system 29.96 NWS, with microcode 669, on LISP Machine Two:

(defun foo (x) (and (memq x '(foo bar baz)) t))
Is compiled so that if x memq '(foo bar baz) the result of that call is returned, rather
than t.
(defun bar (x) (and (memq x '(foo bar baz)) 'gazork)) is, of course, compiled properly.
This is not what AND is documented as doing. FOO is actually a reasonable thing to want
to do, to get a pure predicate, so that, eg, we could see if a and b had the same foo
value with (eq (foo a) (foo b)).

Date:  8 JUL 1980 1824-EDT
From: RSG at MIT-AI (Robert S. Giansiracusa)
To: (BUG LISPM) at MIT-AI

CADR-3, NWS

Is there any way to change the way the FLOATING-UNDERFLOW error gets handled?
The default is to trigger an error; it would be very nice if I could just get
the underflowed number to be treated as ZERO -- ie:
  (TIMES 1.0s-14 1.0s-14) ==> 0.0s0  instead of producing an error.

Tnx .. Bob

Date: 7 July 1980 16:43-EDT
From: Howard I. Cannon <HIC at MIT-MC>
Subject:  Reverse-video-p, 29.95 NWS
To: DLA at MIT-EE
cc: BUG-lispm at MIT-AI

    Date: 7 Jul 1980 1204-EDT
    From: Dave Andre <DLA at MIT-EE>
    To:   bug-lispm at MIT-AI
    Re:   Reverse-video-p, 29.95 NWS

    When drawing lines and bitblting in a widow which is reverse-video-p, 
    the meanings of tv:alu-ior and tv:alu-andca are reversed.  This doesn't
    seem to affect characters (although I haven't hacked with them much).
No, the meanings of tv:alu-ior and tv:alu-andca certainly are not reversed!!
There are two instance variables, tv:char-aluf and tv:erase-aluf which are
normally set to ior and andca, but in reverse video mode are set to andca
and ior, respectivly.  If you want to be completely accurate, you should be
using these variables.


Date:  7 Jul 1980 1204-EDT
From: Dave Andre <DLA at MIT-EE>
Subject: Reverse-video-p, 29.95 NWS
To: bug-lispm at MIT-AI

When drawing lines and bitblting in a widow which is reverse-video-p, 
the meanings of tv:alu-ior and tv:alu-andca are reversed.  This doesn't
seem to affect characters (although I haven't hacked with them much).
-------

Date:  7 JUL 1980 1000-EDT
From: HES at MIT-AI (Howard Shrobe)
To: (BUG LISPM) at MIT-AI

In system 29.96 NWS, with microcode 669, on LISP Machine Two:

When loading the file ai:dpl;window qfasl I get a message 
PACKAGE NIL DOESN'T EXIST CREATE? (about 75% of the way throught the file).

There is nothing in the source that should cause this.  In fact if the file is compile
from an editor buffer everything works fine.

howie


Date:  6 JUL 1980 0015-EDT
From: Henry at MIT-AI (Henry Lieberman)
To: (BUG LISPM) at MIT-AI

In system 29.95 NWS, with microcode 669, on LISP Machine Four:

I tried DRIBBLE-START and DRIBBLE-END, and have some problems with it.
First, error messages and interaction with the error handler do not go to the file.
I would like to have a mode in which this is the case. (or write a function
myself to do this, how should I go about it?)
Second, rubbed out typed input remains in the file. At least, the rubouts
should go in the file too, so you could tell what's been rubbed out. 


Date:  5 JUL 1980 2012-EDT
From: Moon at MIT-AI (David A. Moon)
Subject: Room 936
To: CADR at MIT-AI, (BUG LISPM) at MIT-AI

On several occasions recently I have found room 936 unlocked.  This room
contains several items of high theft value and should be kept locked at
all times except when someone is there.

Date:  5 JUL 1980 1858-EDT
From: SHIPMN at MIT-AI (David W. Shipman)
To: (BUG LISPM) at MIT-AI


How about supporting fasd/fasl for instances? I wrote some
code to do it (see SPEECH;QFHACK >) but its not exactly
clean and probably doesn't cover all the cases.


Date:  4 JUL 1980 1717-EDT
From: johan at MIT-AI (Johan de Kleer)
To: (BUG LISPM) at MIT-AI

In system 29.95 NWS, with microcode 669, on Xerox Machine 1:

I think it is a misfeature that the following does not work.

(defstruct (foo) ((a 10)))  [ or (defstruct (foo) ((a 10 0))) ]
(make-foo)

Admittedly

(defstruct (foo :fixnum) ((a 10)))
(make-foo)

works,
but ...


Date: 4 July 1980 15:19-EDT
From: Mike McMahon <MMCM at MIT-AI>
Subject: INFO-ZWEI
To: INFO-LISPM at MIT-AI
cc: INFO-ZWEI at MIT-AI

I have created this mailing list, primarily for periodic announcements
of new commands and features in the LISP Machine editor.  There seems
to be a large information gap here.  Please add yourself if you are
interested.  Some of you on BUG-ZWEI might want to put yourself here
instead.  In a few days time, i shall mail summaries of commands that
(1) do not exist in EMACS and (2) are new to NZWEI.

Date:  4 JUL 1980 0218-EDT
From: Moon at MIT-AI (David A. Moon)
Subject: CADR-12 won't boot when powered off
To: (BUG LISPM) at MIT-AI

This is a software problem due to the order in which things are loaded,
causing the who-line to be referenced before the initialization that
turns on the sync program.  The problem presumably occurs on all other
machines running this band.  It will be fixed in system 30.

MOON@MIT-MC 07/02/80 19:14:27 Re: File system locking bug
To: (BUG LISPM) at MIT-MC
CC: GLS at MIT-MC
    Date: 2 July 1980 15:22-EDT
    From: Mike McMahon <MMCM at MIT-AI>
    Subject:  Apparent process-lock bug
    To: GLS at MIT-AI
    cc: BUG-LISPM at MIT-AI

        Date:  2 JUL 1980 1026-EDT
        From: GLS at MIT-AI (Guy L. Steele, Jr.)
        Subject: Apparent process-lock bug
        To: (BUG ZWEI) at MIT-AI
        If I do C-X C-F, and while it is waiting in the NET WAIT state I hit [ABORT],
        then retry the C-X C-F, it claims that some lock is already locked by the process
        (the contents of the lock is a window, and so is the new value).
        Evidently the locking is not properly UNWIND-PROTECTed?
    The editor uses the normal filesystem interface, it has no locks of its own.
    Are you sure the lock contents were a window, and not a process, such as
    #<PROCESS ZMACS-WINDOW-PROCESS 105>?

This has been a known bug for at least a year.  For some reason Howard hasn't
got around to fixing it.

Date: 2 July 1980 15:22-EDT
From: Mike McMahon <MMCM at MIT-AI>
Subject:  Apparent process-lock bug
To: GLS at MIT-AI
cc: BUG-LISPM at MIT-AI

    Date:  2 JUL 1980 1026-EDT
    From: GLS at MIT-AI (Guy L. Steele, Jr.)
    Subject: Apparent process-lock bug
    To: (BUG ZWEI) at MIT-AI
    If I do C-X C-F, and while it is waiting in the NET WAIT state I hit [ABORT],
    then retry the C-X C-F, it claims that some lock is already locked by the process
    (the contents of the lock is a window, and so is the new value).
    Evidently the locking is not properly UNWIND-PROTECTed?
The editor uses the normal filesystem interface, it has no locks of its own.
Are you sure the lock contents were a window, and not a process, such as
#<PROCESS ZMACS-WINDOW-PROCESS 105>?

Date:  1 JUL 1980 2246-EDT
From: ACW at MIT-AI (Allan C. Wechsler)
To: (BUG LISPM) at MIT-AI

In system 29.96 NWS, with microcode 669, on LISP Machine Seven:

Low priority:  In some system to come, will there be a way of 
making the mouse cursor disappear while you're not using
the mouse?  Maybe it should time out or something.

   ---Wechsler


JLK@MIT-MC 07/01/80 17:34:45
To: (BUG LISPM) at MIT-MC
CADR10, NWS 29.95

(1) in DIRED if you get an error because you can't connect to the specified machine,
the file device defaults is left permanently as DIR: causing all subsequent operations
such as ^X^F to lose (even before you specify a filename!).  Clearly an UNWIND-PROTECT
is needed somewhere, but even so, it would be nice if when the editor tries to
discover a reasonable file default to print atop the echo area, that it was a bit
more clever about the case where the defaults have gotten wedged or the default
is a non-existant file.

(2) I couldn't send this mail from the LISP machine, which I found very annoying,
because even though I was sending the mail to MC, it insisted that it had to
open a connection to AI, and died in STANDARD-ALLOCATE or whatever.

(3) In general, better handling of file errors is needed, especially in the
editor.  I don't think it is reasonable for the user to ever get a LISP error
break in the editor unless there is a bug (or you executed something like
evaluate region or M-).  The editor should give you a nice file-not-found,
or Host-down message in the echo area and leave you in the editor to try
again.  When sending mail, it should try various hosts if AI or MC are
down (maybe it does, but it never gets to the code...)


Date:  1 JUL 1980 0314-EDT
From: xconos at MIT-AI (Alec Destry)
Sent-by: ___026 at MIT-AI
To: (BUG LISPM) at MIT-AI

Type <back-next>-c in editor to call a macro and hit control-g to get out of the
that command.  You will get an error saying:

  the object #<zmacs-window zmacs-window-1 6146344 exposed> received a :done-with-mode-line
message which went unclaimed.  the rest of the message was NIL.
While in the function si:unclaimed-message <- nzwei:disappear-mini-buffer-window

  You also get hung with NIL in the wholine.

Date: 30 JUN 1980 2102-EDT
From: Moon at MIT-AI (David A. Moon)
Subject: Changing your default base
To: GLS at MIT-AI
CC: INFO-LISPM at MIT-AI

Note that you cannot expect to win by doing (SETQ BASE 10. IBASE 10.), because when
the machine is warm-booted it has no way to know whether the current value of those
symbols is the value you want, or some random value that they were temporarily bound
to at the time it crashed.  If you want change of base to work through warm-booting,
you must:	(ADD-INITIALIZATION "BASE" '(SETQ BASE 10. IBASE 10.) '(:NOW))
which will re-evaluate the form upon warm-boot.  I don't think there is any
trivial way to make this get un-done when you log out (but presumably most people
cold boot instead of logging out.)

Warm-booting is a last-resort mechanism and you can't expect perfect cleanliness
in its behavior, especially if you know how it works!

Date: 30 JUN 1980 1708-EDT
From: BAK at MIT-AI (William A. Kornfeld)
To: (BUG LISPM) at MIT-AI

Mouse-left on CADR9 for the console in 921 is inoperative.  Three different mouses 
were tried and failed so it is definitely not a problem with the mouse itself.  Other
mouse buttons function correctly.


MOON@MIT-MC 06/30/80 14:33:47
To: johan at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date: 30 JUN 1980 1226-EDT
    From: johan at MIT-AI (Johan de Kleer)
    To: (BUG LISPM) at MIT-AI

    In system 29.95 NWS, with microcode 669, on Xerox Machine 1:

    [1] In compiling (selectq var (#,bar ...) ...) the compiler makes the
    assumption that bar is a list, this is wrong.  In this situation a
    better thing to do is for the compiled code to first test bar's type and
    then do an eq or memq depending on that type.
Bleagh, that would surely be wrong; the listification in selectq is
syntactic, not a run time thing.  There is no good solution to this,
as far as I can tell; we are paying a price here for excessive use of
syntax.  A suitable kludge is to put an extra level of parentheses around
the #,bar to ensure that the macro cannot think it is a list.

    [2] For my application however when I have #,bar I want bar to be
    evaluated at read time within the package of the file that is being
    compiled.   The defs file for that package will have set that variable
    to something reasonable.
Use #. to get something evaluated at read time.  You will still have similar
problems with SELECTQ in that the expansion of the macro will vary depending
on whether or not the value of BAR is a list.

Perhaps what you really want is SELECT, i.e.
	(SELECT var
	  (BAR ...)
	  ...)

Date: 30 JUN 1980 1226-EDT
From: johan at MIT-AI (Johan de Kleer)
To: (BUG LISPM) at MIT-AI

In system 29.95 NWS, with microcode 669, on Xerox Machine 1:

[1] In compiling (selectq var (#,bar ...) ...) the compiler makes the
assumption that bar is a list, this is wrong.  In this situation a
better thing to do is for the compiled code to first test bar's type and
then do an eq or memq depending on that type.

[2] For my application however when I have #,bar I want bar to be
evaluated at read time within the package of the file that is being
compiled.   The defs file for that package will have set that variable
to something reasonable.





Date: 28 JUN 1980 1650-EDT
From: RMS at MIT-AI (Richard M. Stallman)
To: GLS at MIT-AI, (BUG LISPM) at MIT-AI

There is one other form of return, MULTIPLE-VALUE-RETURN,
and no reason not to expect there might be others some day.
If someone can come up with a better solution that satisfies
all the conflicting goals, it's fine with me.

Date: 28 JUN 1980 1613-EDT
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: RMS at MIT-AI
CC: (BUG LISPM) at MIT-AI, GLS at MIT-AI

In system 29.95 NWS, with microcode 669, on LISP Machine Eight:

RETURN-FROM-T seems to be implemented only in the compiler,
and not even correctly then, because the symbol RETURN-FROM-T
occurs only in the COMPILER package.  So when everything really
works, I'll convert; for now, I'm just letting SELECT! lose
and I put in explicit RETURN-FROM's instead of sinple RETURN's
to circumvent the bug.


Date: 28 JUN 1980 1602-EDT
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: RMS at MIT-AI
CC: (BUG LISPM) at MIT-AI, GLS at MIT-AI

In system 29.95 NWS, with microcode 669, on LISP Machine Eight:

The function RETURN-FROM-T does not exist in this latest version
of the LISP Machine software, and is not defined in QFCTNS
(which is where PROG and RETURN and RETURN-FROM are).  So what's
the story?


Date: 28 JUN 1980 1556-EDT
From: GLS at MIT-AI (Guy L. Steele, Jr.)
Subject: RETURN-FROM-T
To: RMS at MIT-AI
CC: GLS at MIT-AI, (BUG LISPM) at MIT-AI

This all seems like an incredible kludge, saying (RETURN-FROM FOO (RETURN-LIST BAR))
and so on.  Nevertheless it is in the manual, I guess (but RETURN-FROM-T is not).
Okay, I'll fix my code (under mild protest -- why not just RETURN-LIST-FROM?
or are six other kinds of RETURN anticipated around which one might wrap
RETURN-FROM?).

rms@MIT-MC (Sent by WGD@MIT-MC) 06/28/80 00:19:57
To: GLS at MIT-MC, (BUG LISPM) at MIT-MC
The way to return from a PROG T is with RETURN-FROM-T,
which is different from RETURN-FROM T in precisely the manner
you are asking for.  It is a feature that RETURN-FROM
affects a RETURN inside it; this way, constructs like
(RETURN-FROM FOO (RETURN-LIST BAR)) are possible,
which there would be no other way to express.

Probably PROG T should be replaced with something else
that doesn't cause confusion with normal PROGs.


MOON@MIT-MC 06/28/80 00:06:31 Re: New-style DO consing
To: (BUG LISPM) at MIT-MC
CC: RSG at MIT-MC
I guess it could be changed to cons a fixed amount when entered,
and not cons again on each iteration.  Someone should do that.

MOON@MIT-MC 06/27/80 23:49:06
To: RSG at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date: 27 JUN 1980 2308-EDT
    From: RSG at MIT-AI (Robert S. Giansiracusa)
    To: (BUG LISPM) at MIT-AI

    On CADR-12, 29.95 NWS, ucode 669:

    Typed to interpreter:

    (do () (()) )

    runs fine.

    (do ((foo 5)) (()) )

    runs ok for about 10 seconds, then starts consing more and more until after about
    one minute the disk light is on almost full time.  I have no idea what it is consing,
    but by calling (ROOM T) I could tell that memory was being eaten up at the rate of
    about a few hundred thousand words per minute.
New-style DO in the interpreter conses.  There is no way it can avoid
doing this (the particular special case you give could be done without
consing, but the general case cannot be.)  It has to cons tables of the
variables and their values so it can assign them in parallel.
If you want your code to run efficiently you should compile it.

Date: 27 JUN 1980 2308-EDT
From: RSG at MIT-AI (Robert S. Giansiracusa)
To: (BUG LISPM) at MIT-AI

On CADR-12, 29.95 NWS, ucode 669:

Typed to interpreter:

(do () (()) )

runs fine.

(do ((foo 5)) (()) )

runs ok for about 10 seconds, then starts consing more and more until after about
one minute the disk light is on almost full time.  I have no idea what it is consing,
but by calling (ROOM T) I could tell that memory was being eaten up at the rate of
about a few hundred thousand words per minute.

Date: 27 JUN 1980 1708-EDT
From: GLS at MIT-AI (Guy L. Steele, Jr.)
Subject: AAAARRRRRrrrggggghhhhhhh!!!!!!!
To: (BUG LISPM) at MIT-AI
CC: (BUG LISP) at MIT-AI, GLS at MIT-AI, GJS at MIT-AI, nil at MIT-MC

In system 29.95 NWS, with microcode 669, on LISP Machine Eight:

RETURN-FROM is incorrectly implemented, I claim.
Consider this piece of code:

(DEFUN FOO ()
  (PROG ()
	(PRINT 'A)
	(PROG T ()
	      (PRINT 'B)
	      (RETURN-FROM T (PROGN (PRINT 'C) (RETURN)))
	      (PRINT 'D))
	(PRINT 'E)))

The LISP Machine Manual claims that a PROG with name T is
invisible to the RETURN function, and can be returned from
only with RETURN-FROM T.  Therefore, I would expect FOO to
print the symbols A, B, and C, and then return from the
outer PROG.  However, it prints A, B, C, and E!  Evidently
the fact that RETURN occurs within an argument to RETURN-FROM T
causes it to exit the inner PROG, not the outer.

This is an **enormous** screw, and wasted over an hour of my time.
I have a macro, which I believe is written according to the approved
stype, using PROG T:

(defmacro select! (item . clauses)
  `(prog t (%%item%%)
	 (setq %%item%% ,item)
      retry-select!
	 (select %%item%%
	   ,@(forlist (clause clauses)
	       `(,(car clause) (return-from t (progn ,@(cdr clause)))))
	   (otherwise
	       (setq %%item%%
		     (cerror t () ':wrong-type-argument
			     "The selector ~S was not found in a SELECT! construct."
			     %%item%%))
	       (go retry-select!)))))

This is a version of SELECT that provides its own OTHERWISE clause
and arranges to retry with a correctable error if the key is not known.
I need a PROG to make a loop.  However, if a RETURN occurs in a clause
to SELECT!, I want it to return from whatever PROG surrounds SELECT!

In the interpreter, the problem is that RETURN-FROM binds RETPROGDESC
and then cretinously calls EVAL, giving it a consed-up RETURN form.
Of course, if the argument to the consed-up RETURN form contains a RETURN,
as here, things get really fouled up.  The fix is that RETURN-FROM
should evaluate its argument **first**, before binding RETPROGDESC,
and then cons up a form (RETURN '<the-result>) to eval if it must be done
that kludgy way.

I have no idea how the compiler manages to screw up the same way.


Date: 27 JUN 1980 1650-EDT
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

In system 29.95 NWS, with microcode 669, on LISP Machine Eight:

Tracing RETURN just bites the bag utterly without warning.  It gets
fouled up by a PROG in the tracing routine.


Date: 27 JUN 1980 1242-EDT
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI

In system 29.95 NWS, with microcode 669, on LISP Machine Eight:

Disk error:
Unit 0 cyl 33 surf 6 sect 10
status (read-compare-difference) overrun transfer-aborted

C-C didn't retry -- it was hung in NIL state.  Warm-boot won.


Date: 27 JUN 1980 1131-EDT
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI, GJS at MIT-AI, Fahlman at CMU-10A

In system 29.95 NWS, with microcode 669, on LISP Machine Eight:

It is *extremely* annoying that when you warm-boot the LISP Machine,
BASE and IBASE get reset to 8.  This has been the source of innumerable
screws.  Please fix it so that it only resets them if they are unreasonable
(10. is not unreasonable!).


Date: 26 June 1980 17:03-EDT
From: Howard I. Cannon <HIC at MIT-MC>
To: JLK at MIT-AI
cc: BUG-LISPM at MIT-AI

If you set the variable SI:DISK-SHOULD-READ-COMPARE to T on
both machines, then the transfer stands a better chance of working.
We don't yet understand why, but empirically I have never seen
a transfer fail in this mode.  Please let me know if it does.


Date: 26 JUN 1980 1517-EDT
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

In system 29.95 NWS, with microcode 669, on LISP Machine Eight:

If you are in the editor, and say C-X C-S to save a buffer, and then
go to another window via [SYSTEM] S or [SYSTEM] L or whatever, while
the write-out proceeds, then when you [SYSTEM] E back to the editor
it is in an Output Hold state.
(1) [TERMINAL] [HOLD OUTPUT] does not unstick this situation as advertised.
(2) The only way I've found to unstick it is [SYSTEM] L (ed).
(3) When you unstick it, it claims that the channel is "in illegal state for delete"
    and gives an error.


Date: 26 June 1980 13:28-EDT
From: Mike McMahon <MMCM at MIT-AI>
To: XCONOS at MIT-AI
cc: BUG-LISPM at MIT-AI

    XCONOS@MIT-AI 06/26/80 01:17:24
    (setq :random-list '((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((a)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

       WHEN COMPILED IN THE EDITOR WILL HALT THE MACHINE.  THIS LIST IS
    1000. LEVELS DEEP (1000. OPEN PARENTHESES IN SUCCESSION FOLLOWED BY
    1000. CLOSE PARENTHESES IN SUCCESSION.)
This causes a pdl overflow inside read, error handling of which is pretty poor.

Date: 26 JUN 1980 1138-EDT
From: JLK at MIT-AI (John L. Kulp)
To: (BUG LISPM) at MIT-AI

In system 29.95 NWS, with microcode 669, on LISP Machine Eleven:

I tried for several hours today at various times to transfer bands into this machine.
In particular, I tried getting the 28.0 Macsyma band off of CADR1.  Every time the
transfer completed normally, but the machine always halts when I try to use that
band.  It would be nice if band transfers could be made to work or if someone could
figure out a way to transfer data reliably over the Chaosnet.



Date: 25 JUN 1980 1052-EDT
From: JOHAN at MIT-AI (Johan de Kleer)
To: (BUG LISPM) at MIT-AI

Both CADR2 and CADR8 are broken.  Someone obviously power cycled CADR8 and
failled to turn fans back on last night.  CC-TEST-MACHINE finds
some errors.  CADR2 gets a continuous stream of lisp errors when booting or ILLOP's
depending on the band you choose to boot from.  It shows no errors
with the diagnostics.
johan

Date: 25 June 1980 09:22-EDT
From: Howard I. Cannon <HIC at MIT-MC>
Subject:  New window syste
To: INFO-LISPM at MIT-AI

I have seen examples of some people's new window system code, and have
noticed a very common occurance -- the mixing of old and new window system
symbols in the same piece of code.  This works now, because both window
systems are loaded into the new window system world, but will not work
as soon as we build a new window system only version, which will probably
be system 30.  In order to insure not falling into this trap, there is
a very simple rule: Any symbol beginning with TV- belongs to the old window
system, and about 98% of new window system variables are in the TV package.
Therefore, in some trivial cases replacing TV- with TV: does the trick
(e.g. TV-ALU-IOR --> TV:ALU-IOR).  For some things it's harder.  The
class of primitives (TV-DRAW-LINE, TV-DRAW-CHAR, TV-ERASE) have
analogs in the new window system, but these should not be used.  In most
cases, they want to be replaced with messages sent to the window
of interest (which might be TERMINAL-IO if no window is being used
explicitly).  The messages are :DRAW-LINE, :DRAW-CHAR, and :DRAW-RECTANGLE,
respectivly.  [Note: some of these messages only appear in worlds
later than 29.27 -- if you need them, though, I can point you at a file to
load].

In the latter case, the reason for not using the primitives directly are
too detailed to get into here, but I'd of course be happy to explain
it to anyone who is interested.  I am also available for small amounts of
help in converting your system -- especially getting started.

--Howard


Date: 24 JUN 1980 1051-EDT
From: HES at MIT-AI (Howard Shrobe)
To: (BUG LISPM) at MIT-AI

In system 29.95 NWS, with microcode 669, on LISP Machine Two:
In reference to the bug message which Johan sent just previously,
I have isolated the bug and it was my fault.  I had accidently deleted
a defwrapper in my code which was essential for creating a "view" 
(a private type of window).  the last line of the file ic;nwsdls
created one of these and thereby locked the system up.

check with me for further info.

hes.

Date: 24 JUN 1980 0959-EDT
From: johan at MIT-AI (Johan de Kleer)
To: (BUG LISPM) at MIT-AI

In system 29.95 NWS, with microcode 669, on LISP Machine Eight:

Reproducable ILLOP (tried on both CADR2 and CADR8 -- so presumably a software problem).

PC = 20212 (which is same PC at which my earlier THROW NIL NIL example ILLOP's).

To recreate:

In the editor read in ic;nwsdls >

In lisp
(load "ic;daedfs")
(load "ic;ncoord")

In the editor Compile buffer containing nwsdls.

An ILLOP will occur while compiling the buffer.

johan


Date: 24 JUN 1980 0225-EDT
From: cent at MIT-AI (Pandora B. Berman)
Subject: zapping out of ledit
To: (BUG LISPM) at MIT-AI, (BUG EMACS) at MIT-AI

i was hacking xlisp/ledit, supduping from cadr7 (all right, i know i'm
ignoring the wonderful facilities i have access to on cadrs by hacking
maclisp, but that's not the issue). 
whenever i tried to save a function in the ledit buffer to read into
the lisp when i returned there, by typing M-z, which is supposed to do
that, the screen flashed and otherwise ignored me. i had to use alt-z
to get my functions saved up for perusal by the lisp. is this maybe a
bug with the new keyboards (there is one on cadr7)?

MOON@MIT-MC 06/23/80 15:06:06
To: johan at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date: 22 JUN 1980 1814-EDT
    From: johan at MIT-AI (Johan de Kleer)
    To: (BUG LISPM) at MIT-AI

    In system 29.95 NWS, with microcode 669, on LISP Machine Two:

    (defun foo nil
      (condition-bind ((nil (throw nil nil)))
    		  (barf)))


    Compile it and then type (foo) and you will get an ILLOP at PC 20212.
    I tried this on two machines, and both do the same thing.

T and NIL are not valid tag arguments to throw.  I will investigate
why you get an illop rather than a trap.

Date: 23 JUN 1980 0333-EDT
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

In system 29.95 NWS, with microcode 669, on LISP Machine Seven:

I have twice got "Response over control connection was for wrong channel"
in simple file operations in ZWEI.

If some one will write down what information I ought to extract when
this happens, I will be glad to obey.

Suggestion: an error handler command which writes the
error message and a backtrace into a file and mails it
to BUG-LISPM.  For reliability, this could open a chaosnet
connection to a special simple server.  Then it would not
be screwed by any lossage in the file system.
Individual error condition names could specify that this
be done automatically, and could also contain functions to
print out any other interesting data.  The bug report server
could also supply forms to print out data on the basis
of the error condition name.


Date: 22 JUN 1980 2015-EDT
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

Date: 21 JUN 1980 2137-EDT
From: LPD at MIT-AI (L. Peter Deutsch)
Subject: Interlisp things I miss on the Lisp Machine
To: RMS at MIT-AI
CC: teitelman at PARC-MAXC

First let me say that there aren't very many things of this kind, and there are quite
a few LM things I will miss going back to Interlisp (backquote and decent macros,
screen editor, wonderful and simple manual, FORMAT, CATCH/THROW, closures,
instances, remote file system).  However, here are some things I still miss even
after five months of acculturation:

1) Masterscope.  The LM has no tools at all except text searches and WHO-CALLS for
finding out facts about programs, or selectively editing places where certain
conditions (perhaps partly syntactic and partly requiring more complex testing)
apply.

2) Structure editor.  Although I have become quite fond of the screen editor and
will miss it, I also miss the fact that I can't write Lisp programs that edit
things (programs or data).  I'm sure there are hooks for this in ZWEI, but they
aren't in the manual.  Also, I have yet to be convinced that text editing is
the right model for programs editing programs (although ZWEI does much better
about editing list structure than I would ever have predicted), and I know it
isn't right for programs editing data.

3) Better editor/evaluator/file system integration.  It bothers me that when I
edit something, I have to remember to tell the system to re-eval or recompile it.
It bothers me that updating of the compiled file doesn't happen automatically
(although PKG-LOAD will do this for packages, I don't know how to make it happen
for non-packaged programs).  It bothers me that the transition time between the
editor and listener is a couple of seconds, and that ctrl-alt evaluation,
Evaluate Region, and the ordinary listener all feed different typescripts.
A minor nuisance is that there doesn't seem to be a way to update compiled code
files incrementally.

4) History and the ability to edit my input.  I find myself having to choose
between typing stuff I want to evaluate into the editor and using Meta-Top-E
(in which case the typescript is ephemeral and I wind up cluttering up some
file with the input), or going out to the listener (in which case I can't
recover and edit my input in the case of an error, or re-execute it).

5) Performance.  Yes, I know the LM is twice as fast as a KA-10, but so is
Maxc, and even though Interlisp runs slower than Maclisp if you don't block-
compile, it's quite competitive on non-numeric block-compiled programs,
which are what I usually work with.  The thing that really kills me, though,
is paging.  The problem is that the address space is enormous, and since
there is no garbage collector, data structures wind up sprawling over many,
many pages.  I have an instance of this in the current program I'm working
on -- I do a lot of CONSes, most (but not all) of which become garbage,
and the remainder skip from one page to another.  Yes, I know I can use areas,
but a garbage collector would be much preferable.  I also have a feeling
that something is taking a long time -- I will run a benchmark on Maxc
when I go back and see how it compares.

Hope this answers your question adequately.  I'll be happy to amplify.

Peter


Date: 22 JUN 1980 1814-EDT
From: johan at MIT-AI (Johan de Kleer)
To: (BUG LISPM) at MIT-AI

In system 29.95 NWS, with microcode 669, on LISP Machine Two:

(defun foo nil
  (condition-bind ((nil (throw nil nil)))
		  (barf)))


Compile it and then type (foo) and you will get an ILLOP at PC 20212.
I tried this on two machines, and both do the same thing.


MOON@MIT-MC 06/22/80 02:46:20 Re: Thousands of iteration macros
To: GLS at MIT-AI
CC: (BUG LISPM) at MIT-MC
I don't think these are really a good idea.  The names you propose are
not expressive of the function performed, the macros don't don't do anything
substantially better than what you can do already, and if you try to
put in all the possible cross combinations it will quickly become apparent
that you are much better off with a syntactic approach more like LOOP
(LIBLSP;LOOP) where you don't try to pack the entire program into a single
quasi-German word.

MOON@MIT-MC 06/22/80 02:05:27 Re: Overstrikes
To: (BUG LISPM) at MIT-MC
RMS's mail about overstrikes strikes me as entirely excessive hair.
Why don't we make backspace normally display as <backspace> in the
editor, unless the file has a Backspace:T property in its -*- line.
Thus those who don't intend to use backspaces won't be screwed by them.

Date: 21 JUN 1980 2057-EDT
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

RG was screwed for hours today because he had Q backspac Q
in his file and it looked like just a Q.  It took a long time
to track down what was going on.

I wonder whether there is any reason to allow overprinting
in the middle of Lisp code.  Perhaps a backspace character
not inside a comment, string or vertical bars should be an
error in READ.

If we do want to allow overprinting in symbols in a program,
then we should clean it up.  We could have canonicalization
a la Multics.  This could be done by READ, or the editor
could maintain all data in canonical form.  The former is
probably the easiest, since READ has to scan all the characters
anyway and could have arbitrary hair tacked onto the backspace
character without slowing the normal case.  Backspaceing
past the end of a symbol or past the beginning would still
be screws which ought to be detected as errors.

The cleanest solution of all is to make ZWEI keep all text
in canonical form all the time.  The commands that operate
on characters would have to move over an entire sequence
of overstriking as one character.  There is an easy way to do
this: choose a character to represent "a bunch of overstrikes".
With each line that contains overstrikes, keep a list
(on the line's plist) associating buffer pointers with lists
of characters to overstrike.  Each buffer pointer points
at a "bunch of overstruck chars" character.  When TV-LINE-OUT
sees a "bunch of overstruck chars" character, it refers to
the list of buffer pointers to see what to print.
All editing commands automatically treat the overstrike
as a single character.  There might want to be a special
hack for the word and list commands to decide on the
syntax of the overstrike based on what was overstruck,
but aside from these and the Backspace command to create an
overstrike, no editing functions would need to know about them.

the only lossage is that reading in a file has to find these
overstrikes and convert them.  This would be slow.  So, we
create a file property saying whether there is overstriking.
If there isn't, then backspace displays like <backspace>,
not as overstriking.  If there is, then scan for overstrikes
when reading the file in.  The Backspace command to create
an overstrike could require that the file property be set.

Date: 21 JUN 1980 1455-EDT
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI, (BUG LISP) at MIT-AI, nil at MIT-MC

I have made two changes to FORMAT for the LISP Machine only.
The changes have been documented in LMMAN;FD.STR >, and in
the FORMAT documentation string in the code.

(1) ~:| performs a :CLEAR-SCREEN operation on the output stream,
    if that stream supports that operation.  Otherwise it behaves
    just like ~|, outputting n formfeeds.  (This at the request of HES.)

(2) In the ~<...~:;...~> construction, if a second numeric parameter is given
    to the ~:;, it is the width of the line and is used instead of the stream's
    claimed line width, if any.  (Recall that the first numeric parameter
    is a number to be subtracted from the width before doing the comparison.)
    Also, to make this work, I modified FORMAT-STRING-STREAM to support the
    READ-CURSORPOS operation in a half-assed way: it just searches back from
    the end of the string-so-far for a return, linefeed, or form, and calls
    that distance the x cursorpos, and always says y=0.  This makes ~<...~:;...~>
    to a string work.  Tabs will mess everything up, however; it isn't smart.

    Also, to make this work when you are dribbling to a file, I modified the
    code for DRIBBLE-IO to support READ-CURSORPOS also, by passing the buck
    to the previous I/O stream.

Both FORMAT and DRIBBL have been recompiled.


Date: 21 JUN 1980 1234-EDT
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: DLW at MIT-AI
CC: GLS at MIT-AI, (BUG LISPM) at MIT-AI, nil at MIT-MC

    Date: 21 June 1980 00:31-EDT
    From: Daniel L. Weinreb <DLW at MIT-AI>

    The FORLIST (et al) idea sounds good except that the name
    FOR rather than DO does not particularly suggest the
    functionality of returning a list.  The existing precedent
    in the naming of the mapping functions is not too helpful either,
    unfortunately.

I agree.  Better names are solicited.  (Having the word
MAP in the name would be ideal, but lead to confusion with
the existing MAP functionals.)

Actually, it's not obvious whether FORARRAY should return
a list of results or an array of results!  The one I use
returns a list, but...

I might suggest the series of names
	[LIST-|ARRAY-|<empty>]DO[LIST|ARRAY|TIMES|PACKAGE|...]
the prefix indicating the kind of result returned, and the
suffix the thing iterated over; thus
	FORLIST => LIST-DOLIST
	FORARRAY => LIST-DOARRAY
	FORARRAY returning an array => ARRAY-DOARRAY
(LIST-DOTIMES (I N) I) produces (0 1 2 ... N-1): the APL iota function.
DOPACKAGE would be the DOLIST equivalent of MAPATOMS.  There could
be others.

Date: 21 JUN 1980 0937-EDT
From: XCONOS at MIT-AI (Alec Destry)
To: (BUG LISPM) at MIT-AI

On lisp machine 1, 29.95 nws with microcode 669. you are in the editor in dired mode.
If you view some files that look like qfasl files you get hung in such a way that only
<call> will get you out.  When you go back to the editor you discover there was an error
saying that some argument to plus, nil, was of the wrong type.  The editor immediately
resets itself and leaves you at dired top level.  The files I was looking at were:
  ai:mini;diag magtap and ai:mini;pnlbod drw

Date: 21 June 1980 02:27-EDT
From: Howard I. Cannon <HIC at MIT-MC>
To: XCONOS at MIT-AI
cc: BUG-NWS at MIT-AI, BUG-lispm at MIT-AI

    Date: 20 June 1980 23:24-EDT
    From: Alec Destry <XCONOS at MIT-AI>
    To:   BUG-LISPM at MIT-AI

    At any time you are in the editor with the mouse in the scroll bar, type
    <call>.  You will get hung with NIL in the wholine and will have to cold-boot.
This bug has been fixed in the source.  Note that typing ESC/Control-Clear
or Terminal/Control-Clear-Input will oftentimes unwedge such situations (this is
of course an emergency measure only, and not a cure all).  You might try this
before the drastic action of warm or cold booting.  Please report the bugs, though,
since any time you need to use these keyboard commands a bug has been encountered.

--Howard


Date: 21 June 1980 00:31-EDT
From: Daniel L. Weinreb <DLW at MIT-AI>
To: GLS at MIT-AI, BUG-LISPM at MIT-AI

The FORLIST (et al) idea sounds good except that the name
FOR rather than DO does not particularly suggest the
functionality of returning a list.  The existing precedent
in the naming of the mapping functions is not too helpful either,
unfortunately.

JLK@MIT-MC 06/20/80 23:46:44 Re: Random Fact
To: (BUG LISPM) at MIT-MC
There are about 1200 QFASL files around with an average size of 3 blocks
(I guess this is a rough way to estimate the amount of code that exists
currently for the LISP machine).


Date: 20 JUN 1980 2324-EDT
From: XCONOS at MIT-AI (Alec Destry)
To: (BUG LISPM) at MIT-AI

At any time you are in the editor with the mouse in the scroll bar, type
<call>.  You will get hung with NIL in the wholine and will have to cold-boot.

Date: 20 JUN 1980 1622-EDT
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

In system 29.95 NWS, with microcode 669, on LISP Machine One:

Some handy little macros I've found it useful to invent, and propose
for adoption:

FORLIST: just like DOLIST, but uses MAPCAR instead of MAPC, i.e. returns a list of results
	of evaluating the body.
DOARRAY: just like DOLIST, but iterates over a 1-d array.
FORARRAY: the obvious combination.

I suppose one might want FORTIMES as well...


Date: 20 JUN 1980 1158-EDT
From: LPD at MIT-AI (L. Peter Deutsch)
To: (BUG LISPM) at MIT-AI

In system 27.90 nws, with microcode 667, on LISP Machine Four:
If I am in the initial Lisp listener and I type (ed) and then some
characters for the editor, the characters get echoed/gobbled by the
Lisp listener and the (ed) appears not to be executed, at least
sometimes.  However, if I don't type ahead, everything works fine.
Is this a bug or a change in philosophy?


Date: 20 JUN 1980 0333-EDT
From: Moon at MIT-AI (David A. Moon)
To: (BUG LISPM) at MIT-AI

In system 29.95 NWS, with microcode 669, on LISP Machine Seven:

Someone broke cc-disk-analyze by changing the arguments to cc-type-out.
Maybe other callers of that are broken too

Date: 19 JUN 1980 1850-EDT
From: XCONOS at MIT-AI (Alec Destry)
To: (BUG LISPM) at MIT-AI

Go into an empty editor buffer and do ^t.  It will give you an error
saying some argument to array-leader, nil, was of the wrong type
the function expected an array.

Type in a two characters and do ^t and a rubout and you get:
  Recenter type point left point outside the window.  While in the function nzwei:redisplay <-
nzwei:redisplay-all-windows <- (method nzwei:editor edit).  This error will not go away
when you type ^z.

Date: 19 JUN 1980 1611-EDT
From: LPD at MIT-AI (L. Peter Deutsch)
To: (BUG LISPM) at MIT-AI

In system 29.95 NWS, with microcode 669, on LISP Machine Seven:
I got a stack overflow, did a warm boot, and the machine wedged itself
into FLUSHED state from which nothing except a cold boot could extract it.
(CALL, BREAK, and warm boot were totally ineffective.)


MOON@MIT-MC 06/19/80 16:10:25
To: jim at MIT-AI
CC: (BUG LISPM) at MIT-MC, GJC at MIT-AI
    Date: 19 JUN 1980 0442-EDT
    From: jim at MIT-AI (James E. O'Dell)
    To: (BUG LISPM) at MIT-AI, GJC at MIT-AI

    Why doesn't defvar take 3 arguments, 1) the variable name. 2) initial value, and
    3) a documentation string? It seems that the current definition only wants 2.

Because rather than put in a half-baked scheme like that we are not doing
anything until we come up with a more general system for keeping track
of such things.

Date: 19 JUN 1980 0442-EDT
From: jim at MIT-AI (James E. O'Dell)
To: (BUG LISPM) at MIT-AI, GJC at MIT-AI

Why doesn't defvar take 3 arguments, 1) the variable name. 2) initial value, and
3) a documentation string? It seems that the current definition only wants 2.


Date: 19 June 1980 04:01-EDT
From: Howard I. Cannon <HIC at MIT-MC>
To: Moon at MIT-AI
cc: BUG-LISPM at MIT-AI

I'm seriously thinking of taking out the feature whereby you can do things like
try to spl;it screen from one screen to another.  It really doesn't work (and
probably can't work, especially if the screens are different sizes and
differing number of bits per pixel).  I guess I'll make it do something smarter...


Date: 19 JUN 1980 0013-EDT
From: Moon at MIT-AI (David A. Moon)
To: (BUG LISPM) at MIT-AI

In system 29.95 NWS, with microcode 669, on LISP Machine One:

Using the Split Screen option in the system menu to move a supdup
(or any window with full-screen-hack-mixin) from the CPT to the
color screen loses.  The reason is that :set-superior does not
first adjust the edges to fit within the new superior.  Then when
the edges are set, AFTER changing the superior, the erasing
of the old margins references outside of the screen array.

Date: 18 JUN 1980 1005-EDT
From: RICH at MIT-AI (Charles Rich)
To: (BUG LISPM) at MIT-AI

In system 29.95 NWS, with microcode 669, on LISP Machine Twelve:
It seems to me that (PKG-LOAD 'foo) should load the files
for that package into the package FOO.  Presently, the system
prints out messages for each file saying that it has been loaded
into USER.


MOON@MIT-MC (Sent by CENT@MIT-MC) 06/18/80 01:42:27
To: MMcM at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date: 17 JUN 1980 2252-EDT
    From: MMcM at MIT-AI (Mike McMahon)
    To: (BUG LISPM) at MIT-AI

    In system 29.96 nws, with microcode 669, on LISP Machine Six:
    MAKE-AREA updates (AREA-NAME <new-area>) but does not extend the array-leader of that
    array, so (G-L-P #'AREA-NAME) is not longer EQUAL to AREA-LIST.
    I don't know if this is really a bug in STORE, so i have left it alone.

The array does not have an array leader.  The real bug is that no one
is in charge of fixing the cdr-code.  Hmm, those two lists are supposed
to be EQ, not EQUAL.  Will add this to my list of things to do.

Date: 17 JUN 1980 2252-EDT
From: MMcM at MIT-AI (Mike McMahon)
To: (BUG LISPM) at MIT-AI

In system 29.96 nws, with microcode 669, on LISP Machine Six:
MAKE-AREA updates (AREA-NAME <new-area>) but does not extend the array-leader of that
array, so (G-L-P #'AREA-NAME) is not longer EQUAL to AREA-LIST.
I don't know if this is really a bug in STORE, so i have left it alone.


Date: 17 JUN 1980 1440-EDT
From: LPD at MIT-AI (L. Peter Deutsch)
To: (BUG LISPM) at MIT-AI

In system 27.7, with microcode 663, on LISP Machine Three:
After PACKAGE-DECLARE prompted me for whether I wanted a file compiled and I said Yes,
it "compiled" the file all right, but the definitions written on the QFASL file were
the interpreted ones, not the compiled ones!


Date: 17 JUN 1980 0919-EDT
From: RICH at MIT-AI (Charles Rich)
To: (BUG LISPM) at MIT-AI

In system 29.95 NWS, with microcode 669, on LISP Machine Two:

It would be an improvement if ADD-INITIALIZATION returned
a corresponding deletion form so that it could
be used inside of LOGIN-EVAL.

Date: 16 JUN 1980 0408-EDT
From: Moon at MIT-AI (David A. Moon)
Subject:  :PRINT -> :PRINT-SELF
To: (BUG LISPM) at MIT-AI

I have changed (in the source) all flavors, classes, and named-structures in
the system that handle the :PRINT message to accept :PRINT-SELF synonymously.
I suppose there are some of these in user code, too.

This is in preparation for the soon-to-occur change by which the printer will
send :PRINT-SELF instead of :PRINT, and the :PRINT message will be recycled
as a stream operation.

Date: 15 JUN 1980 0023-EDT
From: RMS at MIT-AI (Richard M. Stallman)
Subject: Incompatible change to PROG
To: INFO-LISPM at MIT-AI

Soon PROG will bind all the variables in parallel
instead of sequentially.  This only makes a difference
if you have initializations which depend on other
variables bound by the same PROG.

If you want to bind variables sequentially, use PROG*,
which is presently the same as PROG and will not change.

Old QFASL files will continue to work as before.
The change takes effect only when the program is recompiled.

I plan to create LET* and DO*, which will both do sequential
binding like PROG*, at some time in the future.

Date: 14 JUN 1980 1421-EDT
From: johan at MIT-AI (Johan de Kleer)
To: (BUG LISPM) at MIT-AI

In system 27.92 nws, with microcode 667, on LISP Machine Two:

I got something like

--> Error in mouse process, using cold load stream <--

TRAP 6164 in function TV:(STACK-FRAME-PRINT)
The second argument to LDB, NIL was of wrong type.

Date: 14 JUN 1980 0522-EDT
From: XCONOS at MIT-AI (Alec Destry)
To: (BUG LISPM) at MIT-AI

On system 27.92 nws with microcode 667
Walk up to cadr 1, login in and do an inspect with the mouse.  In about five
minutes you will get the following:

--> error in the scheduler, using the cold-load stream<--

>>>>trap 7002 (argtyp symbol pp t)
The argument to get-pname, (item, tv:symbol-property-list (si:flavor #<flavor si:vanilla-flavor internal-info 317202> source-file-name files:|ai:lispm2;flavor >|)), was of the wrong type.
The function expected a symbol.
While in the function string-length <- (method tv:follow-list-structure-blinker blink) <- (method tv:follow-list-structure-blinker combined blink)

string-length:
   arg 0 (string): (item, tv:symbol-property-list (si:flavor #<flavor si:vanilla-flavor internal-info 317202> source-file-name files:|ai:lispm2;flavor >|))

->

Date: 13 June 1980 04:58-EDT
From: Howard I. Cannon <HIC at MIT-MC>
To: RWK at MIT-AI
cc: BUG-LISPM at MIT-AI

    Date: 13 June 1980 03:30-EDT
    From: Robert W. Kerns <RWK at MIT-AI>
    To:   BUG-LISPM at MIT-AI

    In system 28.82 nws, with microcode 666, on LISP Machine Four:

    It would be nice if tho wholine displayed which process it was looking
    at, especially if you've done ESCAPE n W.  That would be a lot more
    useful than the date!

    Also, what does state FLUSHED mean?  It seems to be the state this
    editor buffer sits in, which seems a little useless a thing to tell the user.
The latest version of the new window system has most of this fixed.  We are
up to about .93 now, so the one you were using is old.


Date: 13 JUN 1980 0330-EDT
From: RWK at MIT-AI (Robert W. Kerns)
To: (BUG LISPM) at MIT-AI

In system 28.82 nws, with microcode 666, on LISP Machine Four:

It would be nice if tho wholine displayed which process it was looking
at, especially if you've done ESCAPE n W.  That would be a lot more
useful than the date!

Also, what does state FLUSHED mean?  It seems to be the state this
editor buffer sits in, which seems a little useless a thing to tell the user.


Date: 13 JUN 1980 0035-EDT
From: LPD at MIT-AI (L. Peter Deutsch)
To: (BUG LISPM) at MIT-AI

In system 27.6, with microcode 667, on LISP Machine One:
If the pdl overflows, ctrl-z still halts the machine or throws it into
an infinite loop (can only extricate by warm boot).


Date: 11 JUN 1980 0823-EDT
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

It is written that atoms in do variable lists will
be temporary variables to be initialized to NIL.

Date: 11 JUN 1980 0811-EDT
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

I've finally changed the sources to make PROG bind in parallel.
In the next couple of days I'll go through all the tag tables
again to change any PROGs to PROG*'s if necessary.


Date: 11 JUN 1980 0733-EDT
From: JIM@MC
Sent-by: jim at MIT-AI
To: (BUG LISPM) at MIT-AI

(defun  foo (x)
	(do ((a x (+ 1 x)) c)
	    ((> a 10) c)
          (setq c (cons a c))))

Loses both  evaluated and compiled  because of the  ATOM in the variable
initialization part of the do. I wanted a temporary named  c with initial value ().

Date: 11 JUN 1980 0640-EDT
From: ACW at MIT-AI (Allan C. Wechsler)
To: (BUG LISPM) at MIT-AI

In system 27.92 nws, with microcode 667, on LISP Machine Six:

Context:  Just logged in.

Action:  Tried to do a split-screen with a Peek on the top and
         an Editor on the bottom.

Symptom: Hung in "activate" state.

   --- Wechsler


Date: 10 JUN 1980 1353-EDT
From: Nis at MIT-AI (H. Keith Nishihara)
To: (BUG LISPM) at MIT-AI

cadr6 microcode 667 system 27.92nws
seems to be unable to handle very long lines in the editor
happened when i read LISPM1;UCADR 667SYM into the buffer and 
tried to move the cursor down a page


Date: 10 JUN 1980 0557-EDT
From: JIM at MIT-AI (James E. O'Dell)
To: (BUG LISPM) at MIT-AI


On LISPM 1 with system 27.6 and microcode 667, try loading in
mc:lmmax;loader >. It will invariably get a Chaos net error of some
form or another, usually a LOS: Connection does not exist.

This file loads in easily on the SPEECH machine right next to CADR-1

Date:  9 JUN 1980 1133-EDT
From: JLK at MIT-AI (John L. Kulp)
To: (BUG LISPM) at MIT-AI

In system 27.1, with microcode 667, on LISP Machine Eight:

Band 2 contains the result of a failed attempt to copy a band from CADR 7, which
claims to have been completed successfully but wont run.  I am leaving it there
for anyone who cares to do a post mortem.


MOON@MIT-MC 06/08/80 18:46:38
To: Henry at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date:  8 JUN 1980 1644-EDT
    From: Henry at MIT-AI (Henry Lieberman)
    To: (BUG LISPM) at MIT-AI

    Is there a variant of APPLY which takes a function, and a
    (unevaluated) list of arguments, and applies the function, evaluating
    the arguments as necessary according to the kind of function, 
    [if there's a &quote arg, etc.] I would like to apply a function to 
    some arguments without having to go thru the hair of interpreting the 
    lambda list myself, and there might be a function in the interpreter
    that already does this?

I believe that is called EVAL.

Date:  8 JUN 1980 1644-EDT
From: Henry at MIT-AI (Henry Lieberman)
To: (BUG LISPM) at MIT-AI

Is there a variant of APPLY which takes a function, and a
(unevaluated) list of arguments, and applies the function, evaluating
the arguments as necessary according to the kind of function, 
[if there's a &quote arg, etc.] I would like to apply a function to 
some arguments without having to go thru the hair of interpreting the 
lambda list myself, and there might be a function in the interpreter
that already does this?


Date:  8 JUN 1980 0201-EDT
From: acw at MIT-AI (Allan C. Wechsler)
To: (BUG LISPM) at MIT-AI

In system 27.90 nws, with microcode 667, on LISP Machine Six:
ZWEI:SAVE-ALL-FILES when invoked from cold-load-stream complains
about lack of a minbuffer window.  Since this is an obvious
scenario (poor loser bails out at 15,000 feet) perhaps it should be
taken care of.
  --ACW


Date:  7 JUN 1980 0705-EDT
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

I just came across a list of things to do to the Lisp machine
which I wrote down after visiting PARC last year.
Some of them are or might be still interesting.

1) Make the mouse blinker show it, if only a keyboard command
is allowed right now.

2) Do ^F's in multi-font files get ignored properly when
reading the file from Lisp (not into the editor)?

3) Does compiling out of an editor buffer ignore fonts?

[I recall that these used to lose]

4) Bolder window borders might look good.  Perhaps
also inverse-video window label lines.  Is there a problem
with not having fonts that look good in inverse video?

In the latest prepress, when you are supposed to type
a confirmation for a command, the mouse blinker changes to
a box with a question mark in it and no mouse commands are allowed.
Try editing a font and quitting.  I find it very effective.

The "more above" and "more below" lines in scrolling windows
might look good in inverse video also.

Date:  7 JUN 1980 0201-EDT
From: BAK at MIT-AI (William A. Kornfeld)
To: (BUG LISPM) at MIT-AI

The monitor on CADR5 suddenly flashed very brightly for a second or so and
then got dim.  No one was using the machine or tinkering with the CADR itself.
There was no power glitch - CADR3 did not do anything unusual.

MOON@MIT-MC 06/07/80 01:23:46
To: JLK at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date:  5 JUN 1980 0803-EDT
    From: JLK at MIT-AI (John L. Kulp)
    To: (BUG LISPM) at MIT-AI

    In system Macsyma 27.6, with microcode 667, on LISP Machine One:

    H's WORM program no longer works (it gets hung up with the wholine saying
    "Background Process").  Selecting the background process window and typing
    at it doesn't seem to do anything interesting.  This was a nice demo...

I fixed some software rots in WORM and WORM6 and made them work in the
new window system (only).  I didn't do WORM7, someone should do it the
next time they are on a color machine and feel like doing something.
If we're really going to save this program and should be recoded and made
not to have 3 copies of itself.

Date:  7 JUN 1980 0103-EDT
From: Moon at MIT-AI (David A. Moon)
To: (BUG LISPM) at MIT-AI

Someone should fix the fact that you can't use stack groups with sequence breaks
turned on.  Specifically, STACK-GROUP-RETURN sometimes switches to a stack
group belonging to another process rather than to the one that called.  Somehow
the switching due to scheduling is getting mixed in with explicit user stack
group "calling".

Date: 6 June 1980 23:08-EDT
From: Howard I. Cannon <HIC at MIT-MC>
To: cube at MIT-AI
cc: BUG-LISPM at MIT-AI

    Date: 6 June 1980 22:39-EDT
    From: cube at MIT-AI
    To:   BUG-LISPM at MIT-AI

    In system 27.84 nws, with microcode 667, on LISP Machine Two:

    When split-screen in the system menu is used on the color screen,
    the text in the layout window is not in a color font.
This should be fixed in the latest version of NWS, where I
completely redid fonts.


Date:  6 JUN 1980 2239-EDT
From: cube at MIT-AI
To: (BUG LISPM) at MIT-AI

In system 27.84 nws, with microcode 667, on LISP Machine Two:

When split-screen in the system menu is used on the color screen,
the text in the layout window is not in a color font.

Date:  5 JUN 1980 0803-EDT
From: JLK at MIT-AI (John L. Kulp)
To: (BUG LISPM) at MIT-AI

In system Macsyma 27.6, with microcode 667, on LISP Machine One:

H's WORM program no longer works (it gets hung up with the wholine saying
"Background Process").  Selecting the background process window and typing
at it doesn't seem to do anything interesting.  This was a nice demo...


Date:  2 JUN 1980 0052-EDT
From: DANNY at MIT-AI (W. D. Hillis)
To: (BUG LISPM) at MIT-AI

in 27.84 
If the first arg to make-array (the area) is T the machine crashes with no indication of
what caused the problem.


Date:  1 JUN 1980 1718-EDT
From: RG at MIT-AI (Richard Greenblatt)
To: INFO-LISPM at MIT-AI

CADR-1 (in Room 907) now has a color monitor system
compatible in all respects with that of CADR-2.

Date: 31 MAY 1980 0149-EDT
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

I just hacked GRIND to print backquotes the way they were typed in.
I'm not sure I understand the purpose of all the LOC arguments
passed around inside grind, so I may not have done the right thing with them.
Are they there for the NWS examine window?
Would someone who knows what they are for please check this over?
Also perhaps document why they are there.
Search for grind-comma to find my changes.


Date: 30 MAY 1980 1125-EDT
From: XCONOS at MIT-AI (Alec Destry)
To: (BUG LISPM) at MIT-AI

  Walk up to lisp machine 9 (system 27.7, microcode 663.) and type (si:gc-flip-now).
It thinks for a while and types out "flushing oldspace...", then halts.

Date: 30 MAY 1980 0631-EDT
From: JONL at MIT-MC (Jon L White)
Subject: READ flushing atom delimiters
To: MOON at MIT-MC
CC: (BUG LISP) at MIT-MC, INFO-LISPM at MIT-MC

    Date: 30 May 1980 00:23-EDT
    From: David A. Moon <Moon at MIT-AI>
      .  .  .  I f the delimiter is a "useless" or "whitespace" character,
    it will be thrown away, rather than being UNTYI'ed back into the stream
    so that it can be TYI'ed later.  This will happen regardless of whether 
    the symbol or number is seen at top level or is inside of an expression,
      .  .  .
    Certain programs, such as reader macros, may be broken by this.  For them,
    a special variable which they may bind is provided.
    If READ-PRESERVE-DELIMITERS is bound non-NIL around a call to READ,
    all delimiters are preserved regardless of whether they are whitespace
    or meaningful characters.  .  .  .
    I would like to request a compatible change to Maclisp, to avoid 
    divergence and incompatibility on this point.
As it happens, GSB and I made this change to one version of a recent XLISP,
probably about version 1984 or so, but had to take it back when GSB
found he didn't have the time to accomodate his LMS and COBOL code.
What we were hoping to do was provide an additional function, say,
READ-AND-BREAK-CHAR, which would return both the item read and the
termination character.  For backwards compatibility, someone may raise
an objection to not haveing a "backwards-compatible-switch" (i.e.
READ-PRESERVE-DELIMITERS), but for future use, the explicit request
to return the termination character seems like a better approach for
those very few programs which want it.  Any comments?


Date: 30 MAY 1980 0023-EDT
From: Moon at MIT-AI (David A. Moon)
Subject: Change to READ
To: INFO-LISPM at MIT-AI
CC: (BUG LISP) at MIT-AI

In the next Lisp machine system released, the way READ deals with delimiting
characters for those S-expressions that need one (symbols, numbers) will be
subtly changed.  If the delimiter is a "useless" or "whitespace" character,
it will be thrown away, rather than being UNTYI'ed back into the stream
so that it can be TYI'ed later.  This will happen regardless of whether the symbol
or number is seen at top level or is inside of an expression, and regardless of
whether input is being read from the keyboard or from a file.  This was chosen
after much consideration and dithering, because it is simpler and more
understandable than a scheme where the delimiter is sometimes retained and
sometimes discarded.

Certain programs, such as reader macros, may be broken by this.  For them,
a special variable which they may bind is provided.  If READ-PRESERVE-DELIMITERS
is bound non-NIL around a call to READ, all delimiters are preserved regardless
of whether they are whitespace or meaningful characters.  I believe there are
no programs other than LMS (which doesn't run on the Lisp machine currently)
which care about this.  However, if you have a problem with this change
READ-PRESERVE-DELIMITERS should make it easy to fix your code.

This change obviates most of the need for the function SI:READ-FOR-TOP-LEVEL,
however that function is still around for the purpose of ignoring unmatched
close parentheses and because there are many places that call it.

I would like to request a compatible change to Maclisp, to avoid divergence and
incompatibility on this point.

Date: 28 MAY 1980 1840-EDT
From: LPD at MIT-AI (L. Peter Deutsch)
To: (BUG LISPM) at MIT-AI

In system 27.7, with microcode 666, on LISP Machine Four:
I did a Fasl Update from the editor and while it was writing the new QFASL
file I got the message "COMPILE: Compiler recursively entered, you may lose."
If there's anything worse than the message "You will lose", it's the
message "You may lose"!  It leaves me with no clue whatever as to what
the system actually did to me, or under what circumstances the wrong
thing might happen in the future, or what I need to do to keep from
losing.

Quite apart from this general problem, I don't have any model of how the
system decides whether a function needs to be recompiled, or even how it
decides which functions belong on a given file!  There is a nice simple
model of this in Interlisp.  I'm inclined not to use Fasl Update (even
though it provides a function I want very much) again because of this.

I also consider it a bug that the compiler can't be called recursively.
I can guess why this is so -- probably something having to do with the
compiler building structures in its temporary area and assuming they
won't be molested.  It's interesting that we had exactly the same
problem in Dorado Interlisp, only much worse since we were even more
paranoid about avoiding creation of temporary structures: we called it
the "shared global resources problem".  It results from not having a
garbage collector that (in our case) works or (in your case) runs at
acceptable cost.


Date: 27 MAY 1980 1929-EDT
From: XCONOS at MIT-AI (Alec Destry)
To: (BUG LISPM) at MIT-AI

%gc-flip will halt the machine if run which is why (gc-flip-now)
will halt the machine.

MOON@MIT-MC 05/26/80 22:38:07
To: johan at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date: 26 MAY 1980 1927-EDT
    From: johan at MIT-AI (Johan de Kleer)
    To: (BUG LISPM) at MIT-AI

    In system 27.84 nws, with microcode 667, on LISP Machine Two:

    PKG-LOAD seems broken.  For example, (PKG-LOAD 'ETHER 'SI:COMPILE) indeed
    calls COMPILE-FILE-ALIST but then goes and loads all the old qfasl files.
    Furthermore when no qfasl file exists, it just loads (not compiling) the source.

The reason you are losing is that your package declaration
is misformatted; you must say QFASL in the file name if you want the file to be
compiled.  See pages 179-180 of the Jan79 version of the manual.

Why are you saying "SI:" on the COMPILE keyword?

I don't know what you mean by "loads all the old qfasl files", since if it recompiled
the previous versions of the qfasl files wouldn't exist any more.

Date: 26 MAY 1980 1927-EDT
From: johan at MIT-AI (Johan de Kleer)
To: (BUG LISPM) at MIT-AI

In system 27.84 nws, with microcode 667, on LISP Machine Two:

PKG-LOAD seems broken.  For example, (PKG-LOAD 'ETHER 'SI:COMPILE) indeed
calls COMPILE-FILE-ALIST but then goes and loads all the old qfasl files.
Furthermore when no qfasl file exists, it just loads (not compiling) the source.


CWH@MIT-MC 05/23/80 22:55:00
To: (BUG LISPM) at MIT-MC
    MOON@MIT-MC 05/23/80 04:11:34 Re: Your complaints about compiling
    The compiler does have a mode where it compiles to both a qfasl file
    and to memory.  I don't know whether it works; probably it doesn't
    since I don't think it's ever been used.

I have tried using this, and it seems to work for vanilla functions.  It
loses with defmethods in the old class system, and in a few other cases
which I've forgotten.  I haven't tried it with the flavor system.
If this could be made to work, I would use it frequently.


Date: 23 May 1980 21:44-EDT
From: Howard I. Cannon <HIC at MIT-MC>
Subject:  display on cadr1
To: JERRYB at MIT-AI
cc: BUG-LISPM at MIT-AI

The +5 volt power supply on CADR1 appears to be slightly frying
and is quite clearly intermittantly bad (I saw the led's sort
of fade in and out in sync with the monitor losing sync!!).  I suggest
it remain powered off until this gets fixed.


Date: 23 MAY 1980 1856-EDT
From: JERRYB at MIT-AI (Gerald R. Barber)
Subject: display on cadr1
To: (BUG LISPM) at MIT-AI

The display on cadr1 seems to be in bad shape.  Intermitently it seems to loose 
horizontal deflection.  However, when this happens it doesn't listen to the keyboard
and in the cases when the problem goes away the machine is left dead.  It seems to be
insensitive wrt which system is running.

MOON@MIT-MC 05/23/80 04:11:34 Re: Your complaints about compiling
To: LPD at MIT-AI
CC: (BUG LISPM) at MIT-MC
Perhaps you want the functions qc-file and qc-file-load.  Compiling
from a buffer rather than the file it came from wouldn't be any faster,
so we don't bother implementing it.  You might well want to compile
a buffer that hadn't been written out and make a qfasl file, but then
when you did write it out the source would look newer than the qfasl
and the automatic tools would think the qfasl had to be compiled over again.

The compiler does have a mode where it compiles to both a qfasl file
and to memory.  I don't know whether it works; probably it doesn't
since I don't think it's ever been used.

Date: 23 MAY 1980 0331-EDT
From: LPD at MIT-AI (L. Peter Deutsch)
To: (BUG LISPM) at MIT-AI

The present editor interface to the compiler provides two compilation modes, namely:
1) buffer -> memory
2) file -> file
To invoke (2) you also have to have the file loaded into a buffer.

I find (2) an annoyance, and very often want one of the following:
3) buffer -> memory AND file
4) file -> memory AND file (without having to load a buffer)

What are the chances the compiler could be arranged so that all combinations implied
by the foregoing could be provided?  (I.e. input from either file or buffer,
output to any combination of memory and file.)


MOON@MIT-MC 05/23/80 03:12:21 Re: Keys in 936
To: info-lispm at MIT-AI
The key to room 38-301 disappeared from room 936 some time ago and
has not been brought back.  Apparently some users have been borrowing
that key and using it as their personal key.

I would like to point out that those keys are there NOT for the
convenience of random users who feel like getting into some room,
but rather for use in emergencies so that we can get into every
room where Lisp machines are and where the Chaosnet goes.  Without
those keys, if the network breaks, well, tough, we can't fix it
and no one can get any work done, until we can get into the room
in question some other way.

So, please do not remove any keys from 936.  And if you feel you
must remove them anyway, please bring them back as soon as possible.
And if you forgot to return the 38-301 key, please return it now,
preferably anonymously.

Date: 23 MAY 1980 0311-EDT
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

In system 27.7, with microcode 666, on LISP Machine Four:

C-M-R in the error handler ought to extract the symbol from the fef pointer
and then get the current definition of that symbol as the function to
retry calling.  It is very natural to want to retry calling a
function right after fixing a bug in it with the editor.


Date: 23 MAY 1980 0220-EDT
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

In system 27.7, with microcode 666, on LISP Machine Four:

I was not using the net at the moment, and got a background window
saying that a connection was in a LOS-RECEIVED state.
Maybe this can happen legitimately if AI crashes or something, but
I seemed to be left with no window selected (NIL in who line).


Date: 23 MAY 1980 0003-EDT
From: JIS at MIT-AI (Jeffrey I. Schiller)
To: CPR at MIT-AI
CC: (BUG LISPM) at MIT-AI

The file is (almost) up to date, but the machines won't claim
to be from the right place until someone installs another system
revison. I will do this tomorrow or when I return from Washington.
		-Jeff

Date: 22 MAY 1980 2316-EDT
From: cent at MIT-AI (Pandora B. Berman)
Subject: more on lost keys
To: (BUG LISPM) at MIT-AI

    Date: Wednesday, 21 May 1980  09:47-EDT
    From: CPR at MIT-EE

    Well, if it's lost, I'm loathe to replace it, since I'm responsible
    for all those keys.  I did get another for RG, but getting another
    which will probably be misplaced is somewhat painful.  Public keys
    are never a good idea....

Well, gang, the key has not yet reappeared, so we are down one public key.
it will not be replaced. (if anyone has the 38-301 key from 936, with the
red tag labelling it, you can still return it. no questions asked.)

Date: 22 MAY 1980 1918-EDT
From: CPR at MIT-AI (Chris Ryland)
To: (BUG LISPM) at MIT-AI

Can someone update the EECS LispM's phones and room #?
They're really in 38-350 (the consoles I mean) and the phone there I forget
(JIS, you remember the 38-344 terminal bullpen phone?)  Thanks.

Date: 22 MAY 1980 1802-EDT
From: MOON at MIT-MC (David A. Moon)
Subject: &IGNORE
To: JONL at MIT-MC, CWH at MIT-MC, WGD at MIT-MC
CC: (BUG LISP) at MIT-MC, (BUG LISPM) at MIT-MC


Why don't you simply fix the Ncomplr bug which causes code such as
   (defun foo (x y z)
       y  ;y is ignored
       (frob x z))

to get a "bound but never used" error for y?  This is the construct
we use in the Lisp machine.

Date: 22 MAY 1980 1727-EDT
From: JONL at MIT-MC (Jon L White)
Subject: &IGNORE
To: CWH at MIT-MC, WGD at MIT-MC
CC: (BUG LISP) at MIT-MC, (BUG LISPM) at MIT-MC

    Date: 21 May 1980 23:26-EDT
    From: Carl W. Hoffman <CWH at MIT-MC>
    Subject: Ugliness ...
	WGD@MIT-MC 05/21/80 06:32:07 Re: Ugliness ...
	    I think this referencing of unused "vestigials" as opposed to 
    .  .  .  
It should be pretty trivial to implement, in all systems (LMLisp, 
Multics maclisp, PDP10 maclisp)  a simple DECLAREation for IGNORE, with
the same scoping and utility of the current SPECIAL declaration;
note that this is not the same as an & keyword.  The distinction
come when one consideres the rather optional, advisory nature of
IGNORE (simply not see some warning message), and the "hard-core"
nature of &OPTIONAL and &REST (etc.).  While there is no conceivable
purpose to be served by trying to bind (), and it should be permissible
as an "ignored variable", the local declaration form allows ignored
variables with mnemonic content;  I'd be happy to do it in maclisp
(has already been done in the NIL compiler) - would take hardly 10
minutes -  would there be cooperation from the other places?

Date: 22 MAY 1980 1409-EDT
From: HENRY at MIT-AI (Henry Lieberman)
Subject:  Control-Meta-, and Control-,
To: GLS at MIT-AI
CC: (BUG LISPM) at MIT-AI

ZTOP uses these characters. I request that
they be reserved for use by ZTOP [or some
other characters on the new keyboard - any 
suggestions?].

Date: 22 MAY 1980 1331-EDT
From: GLS at MIT-AI (Guy L. Steele, Jr.)
Subject: Spped of new window system
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

In system 27.84 nws, with microcode 667, on LISP Machine Six:

The new window system is absolutely wonderful now that I am
used to it.  The only thing that is annoying is its occasional
slowness.  The system often hesitates a shade too long when
reacting to a mouse command.  Also, creating a SUPDUP window
takes about forever.  I would recommend the following things
to avoid minor but frequent annoyances.  I don't know which of
them are practical.

(1) Have a pre-computed ED window and unconnected SUPDUP window
in the cold load, which can be used when one is first needed.
These plus the initial LISP listener are often all that one needs
for a LISP Machine session, and if the cost of creating these
would be eliminated it would be wonderful.

(2) The system menu is used so often that maybe it and some of
the associated software should be locked down in memory or
micro-compiled.

(3) 90% of all system menu references go through the SELECT choice,
I find.  I suggest that the default meaning of MOUSE-LEFT-CLICK
be to go directly to the window selection menu.  In the editor,
this would not be available, much as single-right is unavailable
for the system menu.  Also, once on one machine there were escape
commands for "go to an ED window", "go to a SUPDUP window", etc.
that were super-great--those should be standard.

(4) The menu for Save or Kill Buffers is really neat.  However,
it should be more clever.  If I kill three buffers, I often
have to type three carriage returns, because it doesn't realize
that the default buffer after killing buffer j is about
to be killed as buffer j+1.

Keep up the good work!


Date: 22 MAY 1980 1045-EDT
From: cpr at MIT-AI (Chris Ryland)
To: (BUG LISPM) at MIT-AI

There is a key to the LISPM console room (38-350) hanging from the window side
of the shelves on the column in the middle of the machine room (38-301).  Please
be sure to return it when you're done with it; there are already some keys
missing which I'm accountable for.


Date: 22 MAY 1980 0315-EDT
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

I've implemented a new fasl file format
which is twice as fast to load (on QFCTNS).
I'm working on a convenient scheme for converting QFASL files.
See RMS;IMGDMP and IMGLD.


MOON@MIT-MC 05/21/80 20:38:45
To: LPD at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date: 21 MAY 1980 1011-EDT
    From: LPD at MIT-AI (L. Peter Deutsch)
    To: (BUG LISPM) at MIT-AI

    In system 27.7, with microcode 663, on LISP Machine Three:
    If I evaluate something which comes out as type DTP-INSTANCE-HEADER,
    it prints out the value correctly, but then goes into a (microcode?)
    loop which can only be interrupted by a warm boot.

DTP-INSTANCE-HEADER is an internal type, it is not valid for functions
to return a value of this type.  How are you managing to see this
data type?  There must be a bug somewhere.

Presumably the "microcode loop" is actually the machine halting because
of an illegal data type being found somewhere or stored somewhere.

Date: 21 MAY 1980 1607-EDT
From: rg at MIT-AI (Richard Greenblatt)
To: INFO-LISPM at MIT-AI

 John Purbrick's force sensitive joystick "mouse" is available
for trial use.   For the time being, it will live in his office,
and anyone who want to try it out can drop by, pick it up, and plug
it in directly in place of the regular mouse.
  This mouse may be particularily suitable for controlling certain
kinds of parameters as opposed to pointing on the screen, altho
it seems to work out fairly well for pointing as well.
  There is some hope that this kind of mouse could eventually
be built directly into the keyboard (as suggested by Carl Hewitt),
and thus be accessible without removing your hands from the keyboard.

Date: 21 MAY 1980 1320-EDT
From: LPD at MIT-AI (L. Peter Deutsch)
To: (BUG LISPM) at MIT-AI

In system 27.7, with microcode 666, on LISP Machine Four:
It appears that if you APPLY a function which takes a &REST arg,
the arg is bound to the actual list supplied as the argument,
not to a copy materialized on the stack.  This actually makes a
difference sometimes, and I think the documentation should be
fixed (last paragraph on p. 8 of the manual).


Date: 21 MAY 1980 1011-EDT
From: LPD at MIT-AI (L. Peter Deutsch)
To: (BUG LISPM) at MIT-AI

In system 27.7, with microcode 663, on LISP Machine Three:
If I evaluate something which comes out as type DTP-INSTANCE-HEADER,
it prints out the value correctly, but then goes into a (microcode?)
loop which can only be interrupted by a warm boot.


Date: 21 MAY 1980 0256-EDT
From: cent at MIT-AI (Pandora B. Berman)
Subject: crufty display
To: (BUG LISPM) at MIT-AI

the console to CADR8 is very crufty. random short horizontal lines appear
all over the screen and stay, especially when editing, and in general 
things look pretty bad. i think these problems may be due to an undebugged  
tv board; jlk was working on one on this machine earlier tonight. but the 
console has other problems -- it has always been at best barely in focus. 
can we possibly find another one that works and get this one fixed, instead 
of subjecting the hardware crew (among others) to continued eyestrain?
(it should be noted that  helps, but only somewhat and only temporarily; 
it does not erase all the lines, and when i start typing again more lines 
appear.)

Date: 20 MAY 1980 0943-EDT
From: RSG at MIT-AI (Robert S. Giansiracusa)
To: (BUG LISPM) at MIT-AI

The terminal on CADR-9 in rool 921 dropped dead a couple of days ago -- lost
sync stability (characters were fuzzy and vibrated) then, upon a warm-boot,
wend dead altogether and never came back.

Date: 20 MAY 1980 0118-EDT
From: Agre at MIT-AI (Philip E. Agre)
To: (BUG LISPM) at MIT-AI

In system 26.4, with microcode 618, on LISP Machine Two:
In Zwei, despite the fact that C-) claims to be undefined, it acts like C-9.

Date: 20 MAY 1980 0019-EDT
From: cent at MIT-AI (Pandora B. Berman)
Subject: 38-301 room keys
To: (BUG LISPM) at MIT-AI

the key to the course six machine room which resided in 936 tech sq. has
disappeared. that key was the only way several members of the lisp machine
group (the people who build and maintain lisp machines) including me, can
get access to cadrs 10 and 11. i have been informed that possibly users of
those machines borrowed the key so they could get at the terminal in the
machine room. that should not be happening; that key is for access for work 
on the hardware, and there are several course six people around (such as
cwh and jis) who have keys and can let in users who need to be in there.
if anyone out there has the key, please return it.

my apologies to those of you who have seen this  plaint before.

Date: 19 MAY 1980 2119-EDT
From: Moon at MIT-AI (David A. Moon)
To: (BUG LISPM) at MIT-AI

I have moved some of LMIO;DISK into LMIO;DLEDIT

Date: 19 MAY 1980 1705-EDT
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

In system 27.82 nws, with microcode 666, on LISP Machine Six:

>>TRAP 6262 (TRANS-TRAP)
The function SUPDUP:TYPEOUT-NET-ERROR is undefined.
While in the function APPLY  EH:SIGNAL-1  SIGNAL

APPLY:
   Arg 0 (FN): SUPDUP:TYPEOUT-NET-ERROR
   Arg 1 (ARGS): 1285


Date: 19 MAY 1980 1644-EDT
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

In system 27.82 nws, with microcode 666, on LISP Machine Six:
It would be a trivial hack but a significant convenience if
the sub-menu for the CREATE option of the system menu,
SUPDUP AI, SUPDUP MC, and SUPDUP ML were separate explicit
options in addition to just SUPDUP.  99.99% of all supdup
creations go to one of those three hosts, and it would be nice
if you could do it all with the mouse and save some keystrokes.


Date: 18 May 1980 22:30-EDT
From: Henry I. Collins <HIC at MIT-MC>
Subject:  Warm Boot meets the New Window System
To: Jis at MIT-AI
cc: BUG-LISPM at MIT-AI

The bug whereby warm booting would leave all processes flushed has been
fixed a long time ago.  Perhaps you were using an old version?

Please send New Window Systsme bugs/features to BUG-NWS


Date: 18 MAY 1980 2200-EDT
From: Jis at MIT-AI (Jeffrey I. Schiller)
Subject:  A suggestion for ZWEI
To: (BUG LISPM) at MIT-AI

(ZWEI:SAVE-ALL-FILES) is a win. I suggest that another function also be
defined, one that doesn't attempt any interaction with the window system
and can be used from the cold load stream, with minimum console
interaction.  This function should basically dump all modified buffers
into one large file with some mnemonic name (like <UDIR>;ZWEI LOSS)
where the buffers are separated by a mode line indicating what buffer it
is. In this way if a dead machine can be brought back to life, an
attempt can be made to dump the modified buffers without possibly
overwriting a good (but old version) of a file with utter gubbish (in
the even the buffer wasn't in any reasonable state). 

I know that ">" and version number should make this unnecessary but:

1) Not everybody had a directory and uses ">" (not a good argument)

2) Sometimes I encounter and resurect a machine that was left as
   hopeless by the previous user. I am hesitant to write his files
   out because he might not know that I did so, and I might write out
   a bad copy... If ZWEI LOSS (maybe the "LOSS" should be replaced by
   <UNAME> for USERSn) showed up the user in question could notice it,
   and peruse it to see if he wants anything. 

I suggest this function be named EMERGENCY-SAVE-BUFFERS or some such
name to indicate its bailing out nature... 

			-Jeff


Date: 18 MAY 1980 2152-EDT
From: Jis at MIT-AI (Jeffrey I. Schiller)
Subject:  Warm Boot meets the New Window System
To: (BUG LISPM) at MIT-AI

In general I feel that warm booting should not be considered the
cure all to window hangitude (as it was in the old window system).
HOWEVER, machines sometime crash for whatever reason, it is not reasonable
to expect the average user to be able to use CC to bring his machine back
to life. Therefore the machine should attempt to do something reasonable
when a warm boot occurs. I agree that after a warm boot a user shouldn't
expect the world to be too consistent, but things should at least for
the most part work well enough 80% of the time so that he can write out
his/her buffers. Just for the helluvit I did a (%HALT) from the Initial
Lisp Listener and then warm booted the machine, boom I was dead in the
water, it appears that every process in the universe is hung in a FLUSHED
state (lossage left over from the old window system) this is not
acceptable and should probably be fixed before this window system
is officially released.

			Yours in flames...
			Jeff


Date: 17 MAY 1980 1713-EDT
From: Henry at MIT-AI (Henry Lieberman)
To: (BUG LISPM) at MIT-AI

In system "26.20 Daedalus", with microcode 618, on LISP Machine Two:

(DESCRIBE FONTS:CPTFONT) causes an array out-of-bounds error.


Date: 17 MAY 1980 1329-EDT
From: JONL at MIT-MC (Jon L White)
Subject: varieties of "NETS" for catching
To: CWH at MIT-MC, GSB at MIT-MC
CC: NIL at MIT-MC, (BUG LISP) at MIT-MC, (BUG LISPM) at MIT-MC

    Date: 15 May 1980 13:43-EDT
    From: Alan Bawden <ALAN at MIT-MC>
    To: CWH at MIT-MC
	CWH@MIT-MC 05/15/80 01:45:26
	(*CATCH '(A B C) (COMPUTE)) in MacLisp means to catch throws to any one of
	the tags A, B, C.
    Really?  (Amazing, it really does work that way!)  That is not an
    advertized feature as far as I can tell.  Perhaps someone should
    document it somewhere.
During the late summer of 1978, the NIL/MACLISP/LISPM community seemed to
reach agreement about the names and functionalities of the various catchers.
Although this included  lists of tags, as well as a single atomic tag, as
argument to CATCH and CATCH-BARRIER, it was never fully documented in
maclisp's LISP NEWS.  The general idea was that the name *CATCH was to
be a temporary expedient until we could expunge all usages of the
restrictive old-style CATCH.  Then, we'd re-introduce the name CATCH with
the new winning syntax (as in *CATCH) and advertise its "tag-list"
extension.  This has not yet been done for maclisp.  NIL has all these 
features right now (along with a macro defintion for *CATCH which merely 
turns it into CATCH), and shortly then we'll be able to say that maclisp's 
catchers are a copy of NIL's.
   By the bye, CATCHALL was invented for just the reason which GSB pines
for - to intercept all THROWs and inspect them.  The idea was that if the
"inspection test" fails, the CATCHALL function merely does a THROW (or is
it a "*THROW"?) with the given tag and value, in order to continue the 
throwing.  Admittedly this lets an unseen-throw-tag error occur higher in 
the stack than one would like, but . . .


Date: 16 MAY 1980 1716-EDT
From: Batali at MIT-AI (John Batali)
To: (BUG LISPM) at MIT-AI

In system 27.7, with microcode 663, on LISP Machine One:
The tv screen suddenly sprouted two vertical light lines.

Date: 16 MAY 1980 0913-EDT
From: cpr at MIT-AI (Chris Ryland)
To: (BUG LISPM) at MIT-AI

In system 27.77 NWS, with microcode 661, on LISP Machine Ten:

telnetting to EE with second arg T (imlac simluation), and KKing gets an
 ERROR: 3 is illegal packet opcode, received for connection #<CHAOS connection...>
 While in the function CHAOS:STREAM-INTERNAL  SUPDUP:NVT-NETI  (METHOD SUPDUP:BASIC-NVT TYPEOUT-TOP-LEVEL)


Date: 16 MAY 1980 0331-EDT
From: RMS at MIT-AI (Richard M. Stallman)
To: INFO-LISPM at MIT-AI

WHen new versions are installed, it will be possible to
decompose a list by saying (setf (list a b) foo)
or (setf (cons a b) foo), etc.  list* is also allowed.
Quoted arguments to cons or list are ignored so
an arbitrary backquote pattern can be used:
(setf `(a ,b c ,d) foo) sets b to the cadr and d to the cadddr
doing nothing about a and c.  Multiple levels of list structure work.
If foo evaluates to an atom you get an error.

Eventually there will be a match predicate macro which will
check that the a and c are there without setting the variables b or d.

Date: 16 MAY 1980 0307-EDT
From: rms at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

I did some metering on fasloading LMIO;GRIND.
It takes about 16 seconds.
Calls to intern use up 5 seconds.
Starting and stopping use up 6 seconds
 (this includes checking the file plist).
All the rest of the computation uses about 5 seconds.
I didn't succeed in measuring time spent waiting for the net
but I could see from the who line that it was only a few percent.

The average time per call to intern was 31 msec.
An intern which does no swapping takes only 4msec,
leaving 27 msec of swapping for each of 160 interns,
which adds up to 4 seconds of swapping.  Chances are
that interns accounted for most of the swapping done.

Loading QFCTNS took a total of 39.5 seconds, of which
6.5 were starting and stopping, 13 went for 700 interns,
and the remaining 20 seconds were the rest of the work.
The smaller average time per intern is probably because this
file is several whacks and thus many interns are repeated
with the necessary pages already in core.  This suggests that
the duplicate interns caused by whacks aren't costing much.

This seems to indicate that there is no point in trying to
speed up intern except possibly by a rearrangement of the data structure.
Rewriting fasload and possibly changing the fasl file format
could gain a factor of two for QFCTNS; three perhaps for a larger file.
Reducing the number of times it is necessary to wait for a reply
while opening and closing a file could greatly speed up loading
a lot of small files.


Date: 16 MAY 1980 0259-EDT
From: Henry at MIT-AI (Henry Lieberman)
To: (BUG LISPM) at MIT-AI

In system 27.77 NWS, with microcode 663, on LISP Machine Eight:

Systems having the NWS should have a feature in (STATUS FEATURES)
so that programs can tell whether they've got the NWS. Or is there
something else to test NEW-WINDOW-SYSTEM-P?


Date: 16 MAY 1980 0121-EDT
From: Jis at MIT-AI (Jeffrey I. Schiller)
To: (BUG LISPM) at MIT-AI

In system 27.80 nws, with microcode 666, on LISP Machine Six:
Typing <Terminal><Help> (new keyboard) caused the message
[Process KBD ESC got an error] (or some such thing)

Upon investigation the following was determined... 
The Process specified above was indeed in an error handler what it was
complaining about was that TV:POP-UP-FINGER-WINDOW was unbound.

		-Jeff


Date: 15 MAY 1980 1746-EDT
From: JLK at MIT-AI (John L. Kulp)
To: (BUG LISPM) at MIT-AI

In system 27.77 NWS, with microcode 661, on LISP Machine Ten:
I did ^X^B and pointed at a buffer and clicked KILL in the small menu and
got an error CURRENT-COMMAND unbound in closure while in EDIT-IN-MINI-BUFFER


Date: 15 MAY 1980 1743-EDT
From: JLK at MIT-AI (John L. Kulp)
To: (BUG LISPM) at MIT-AI

In system 27.77 NWS, with microcode 661, on LISP Machine Ten:
In the editor I did Meta-X ? and moused View XGP Queue and then
moused VARIABLE SET and it died in COMPLETING-IS-OK-P and deleted
everything in the buffer.  Also, there were about 5 dead blinker
skins left hanging around the screen during the above.


Date: 15 MAY 1980 1626-EDT
From: LPD at MIT-AI (L. Peter Deutsch)
To: (BUG LISPM) at MIT-AI

In system 27.7, with microcode 663, on LISP Machine Seven:
Some or all of my type-ahead problems are clearly due to an
unreasonably small input buffer (apparently about 30 characters).


Date: 15 MAY 1980 1421-EDT
From: LPD at MIT-AI (L. Peter Deutsch)
To: (BUG LISPM) at MIT-AI

In system 27.7, with microcode 663, on LISP Machine Seven:
Sometimes ZWEI thinks there is still stuff in the keyboard buffer,
and doesn't update the screen, when actually there is nothing there.
This only seems to happen when I type ahead.  Also, a few times a run
of characters at the end of some typeahead just plain gets lost.
(I didn't type that much ahead -- maybe 30 or 40 characters.)


MOON@MIT-MC 05/15/80 13:56:59
To: CWH at MIT-MC
CC: (BUG LISPM) at MIT-MC
    CWH@MIT-MC 05/15/80 01:45:26
    To: (BUG LISPM) at MIT-MC
    (*CATCH '(A B C) (COMPUTE)) in MacLisp means to catch throws to any one of
    the tags A, B, C.  If the Lispm supports this extension, it is broken in
    system 27.6 on CADR-11.  If not, then *CATCH should barf when given a
    non-atomic first arg.

This is some random feature invented by GLS or JONL; the Lisp machine has
never claimed to have any such feature.  Note that if you are throwing
out of (COMPUTE) then *CATCH is in fact never getting called (not that it
looks at its arguments anyway).

I suppose there is no complelling reason why the Lisp machine couldn't do this.
You could also implement it yourself easily enough with CATCH-ALL.

Date: 15 MAY 1980 1828-EDT
From: JLK at MIT-AI (John L. Kulp)
To: (BUG LISPM) at MIT-AI

In system 27.77 NWS, with microcode 661, on LISP Machine Ten:
In the window error handler are EDIT, SET ARG, or SEARCH supposed to work?
They all die in various ways for me.  EDIT wedges the world in the NIL state,
SEARCH dies the second time you use it (and never finds anything the first time),
SET ARG just feeps which presumably means its not implemented?  Also it would
be nice to have a thin (one-line) window telling you want the mouse clicks
do in any situation, if anything.


Date: 15 MAY 1980 1759-EDT
From: JLK at MIT-AI (John L. Kulp)
To: (BUG LISPM) at MIT-AI

In system 27.77 NWS, with microcode 661, on LISP Machine Ten:
ditto wrt BARFOLA


Date: 15 MAY 1980 1756-EDT
From: JLK at MIT-AI (John L. Kulp)
To: (BUG LISPM) at MIT-AI

In system 27.77 NWS, with microcode 661, on LISP Machine Ten:
After doing Meta-X Var Set and specifying the variable name, the
first letter you type is not echoed until after you type the next
char.  Also setting ZOWIE Flag doesn't do anything, whether or
not HACKS is loaded (yeah, I know its random, but it should be
flushed or fixed -- its more random to have a hack that doesn't work).


CWH@MIT-MC 05/15/80 01:45:26
To: (BUG LISPM) at MIT-MC
(*CATCH '(A B C) (COMPUTE)) in MacLisp means to catch throws to any one of
the tags A, B, C.  If the Lispm supports this extension, it is broken in
system 27.6 on CADR-11.  If not, then *CATCH should barf when given a
non-atomic first arg.


Date: 14 MAY 1980 2346-EDT
From: jerryb at MIT-AI (Gerald R. Barber)
To: (BUG LISPM) at MIT-AI

In system 27.80 nws, with microcode 663, on LISP Machine One:

In Zwei, with a form like:

TV:(defmethod ... )

ctl-meta A and ctl-top-C etc, don't find the right thing.


Date: 14 MAY 1980 2049-EDT
From: jerryb at MIT-AI (Gerald R. Barber)
To: (BUG LISPM) at MIT-AI

In system 27.80 nws, with microcode 663, on LISP Machine One:

In Zwei with the following code fragment with the cursor sitting in the left
most position on the line with the form (TV:KBD-INITIALIZE) a <meta>-.
causes an error: Cannot coerce (NOT (BOUNDP 'CURRENT-PROCESS)) to a string.


(DEFUN LISP-REINITIALIZE (&OPTIONAL (CALLED-BY-USER T))
  (SETQ INHIBIT-SCHEDULING-FLAG T)		;In case called by the user
  (SETQ ALPHABETIC-CASE-AFFECTS-STRING-COMPARISON NIL)
  (OR (FBOUNDP 'INTERN) (FSET 'INTERN #'INTERN-OLD))
  (OR (FBOUNDP 'FSET-CAREFULLY) (FSET 'FSET-CAREFULLY #'FSET-CAREFULLY-COLD-LOAD))
  (SETQ DEFAULT-CONS-AREA WORKING-STORAGE-AREA)	;Reset default areas.
  (AND (FBOUNDP 'NUMBER-GC-ON) (NUMBER-GC-ON))	;This seems to work now, make it the default
  (SETQ CONDITION-HANDLERS NIL)
  (COND ((NOT (BOUNDP 'CURRENT-PROCESS))	;Very first time around
	 (SETQ SCHEDULER-EXISTS NIL
	       CURRENT-PROCESS NIL
	       INHIBIT-CLOCK-INTERRUPTS NIL)
	 (TV:KBD-INITIALIZE)))			;*** PACKAGE WILL NEED TO BE FLUSHED LATER ***
  (TV:INITIALIZE-WIRED-KBD-BUFFER)		;*** PACKAGE WILL NEED TO BE FLUSHED LATER ***


Date: 14 MAY 1980 1553-EDT
From: GLS at MIT-AI (Guy L. Steele, Jr.)
Subject: Quux never satisfied with DRIBBLE
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

In system 27.7, with microcode 663, on LISP Machine Nine:

DRIBBLE ought to take an extra argument saying whether interactions with the
error handler and QUERY-IO should be dribbled or not.  I have uses for
both cases, so it needs to be a switch.


Date: 14 MAY 1980 1145-EDT
From: GLS at MIT-AI (Guy L. Steele, Jr.)
Subject: DRIBBLE-START
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

In system 27.7, with microcode 663, on LISP Machine Nine:

The dribble package doesn't really do the right thing in some sense.
If one types F O O [rubout] [rubout] R O B, then what goes
into the dribble file is F O O R O B.  Either rubbed-out
things should not appear, or else [rubout]s and [form]s and
all that gicky stuff should appear.  I would prefer the former.
(PDP-10 MacLISP arranges not to echo a character until it has
"really" been accepted by the reader in some sense.)


Date: 13 MAY 1980 1610-EDT
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

In system 27.79 nws, with microcode 661, on LISP Machine Six:
Regarding previous message about STREAM-MIXIN :TYI -- the
same goes for :TYI-NO-HANG.  Better check all the operations
to see where any other discrepancies are.


Date: 13 MAY 1980 1609-EDT
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

In system 27.79 nws, with microcode 661, on LISP Machine Six:

The function DRIBBLE-START fails to work.  This seems to be
because when a :TYI operation is done on the DRIBBLE-IO stream,
it passes along the single argument to TYI.  According to the
LISP Machine Manual, p. 164, the :TYI operation is supposed to
accept an optional argument saying what to do at EOF.  However,
the method STREAM-MIXIN :TYI in file BASWIN does not seem to
permit this argument.  Therefore when one tries to dribble
one gets the error that too many arguments were given to the
method.


Date: 13 MAY 1980 1415-EDT
From: LPD at MIT-AI (L. Peter Deutsch)
To: (BUG LISPM) at MIT-AI

As a long-time Interlisp user, and also one of the original users of Lisp 1.5,
I have found it annoying to say the least that both Interlisp and Mac/LMLisp
have chosen to "improve" functions by twiddling arguments and syntax while
keeping the same name.  This tactic makes it maximally inconvenient to
transport programs between machines, since they must be edited rather than
having the disagreements handled with macros.  The CASEQ/SELECTQ flak
is only one of many, many examples (NTH, MAPxxx, ERROR, DECLARE, PUTPROP,
GET, and a number of conventions in the reader are the other things of
this sort that I ran into when contemplating moving my LMLisp program
back to Interlisp.)

Date: 13 MAY 1980 1315-EDT
From: GLS at MIT-AI (Guy L. Steele, Jr.)
Subject: CASEQ
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI, ALAN at MIT-AI, nil at MIT-MC

TO set the record straight, JONL is *not* entirely at fault
on the name of CASEQ.  I believe that I pumped for that.
The reason was not merely to be trivially different from
the LISP Machine.  RMS seems to think that the LISP Machine
is always right and any deviation therefrom is gratuitously
perverse.  If he thinks my motivations are that simple-minded,
then I am greatly offended.
The true reason was as follows: the LISP Machine indeed introduced
SELECTQ before MacLISP introduced CASEQ.  However, the name SELECTQ
was already in use, by InterLISP, to mean something slightly
different.  Hence the LISP Machine was ignoring precedent and
chose to use the same name to mean a slightly different thing
(the primary distinction being that the InterLISP version does
not use a keyword T or OTHERWISE, but just has the last argument
form be the OTHERWISE case).  Now I happen to agree with the
change in semantics -- it is convenient to be able to omit the
default case, as for a COND, and it is more readable when the
default case is present.
HOWEVER, it seemed injudicious to use the name SELECTQ because that
would make it gratuitously more difficult to convert InterLISP
software to MacLISP.  My hope at the time was that we could all
agree on this and make things maximally easy for everyone.  Now it
is probably too late.
Historical note:  SELECT also means something in InterLISP, and also
in LISP 1.5... and the InterLISP version does not mean the same thing
as the LISP 1.5 version!!!
A secondary reason (but not an overriding one) is that every language
except LISP calls this construction a "case statement".  It would
probably aid the spread of LISP if we did not gratuitously choose
different names for concepts which actually are not unique to LISP
but are already widespread.
In any case, I put to you this question: is it more incompatible
to use a different name for almost-the-same thing, or to use the
same name for not-quite-the-same-thing?

Date: 12 MAY 1980 0508-EDT
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

On the machine in Moon's office,
MHS was compiling a function in the editor and the machine
died, with ARREST in the who line, and would not respond to a warm boot.
Before the attempt to warm boot, the mouse was not being tracked.
He was using the default band.

MOON@MIT-MC 05/11/80 23:37:52 Re: CASEQ
To: (BUG LISPM) at MIT-MC
CC: ALAN at MIT-MC
I think it would be best if those programs that need CASEQ in order to
work define it for themselves, since there is no advantage to it other
than Maclisp compatibility.  I don't think we should incorporate every
name Jonl dreams up into the system.  Admittedly it would be slightly more
convenient if it was predefined, but it only takes a few seconds
to define it.

Date: 11 MAY 1980 1817-EDT
From: RSG at MIT-AI (Robert S. Giansiracusa)
To: (BUG LISPM) at MIT-AI

CADR-1 seems to have some bad memory chip(s).  It suddenly started dying every
10 minutes or so on 5/11/80 at about 18:00.  It would halt with run light on,
read a DTP-TRAP word, or make miscellaneous other screwups.

Date: 10 May 1980 22:06-EDT
From: Alan Bawden <ALAN at MIT-MC>
To: RMS at MIT-AI
cc: BUG-LISPM at MIT-MC

    Date: 10 MAY 1980 2113-EDT
    From: RMS at MIT-AI (Richard M. Stallman)

    Having two names on the Lisp machine, SELECTQ and CASEQ, for
    constructs which are slightly different in a subtle way would be
    great lossage, because nobody would remember the difference and
    everyone would try to use them interchangeably and get screwed.

NO! NO! NO!

	I am not suggesting we introduce a fully compatable CASEQ on the
LispMachine.  I am suggesting the following:

(defmacro caseq stuff `(selectq . ,stuff))

There would be no problem with people being confused, and we wouldn't
even have to advertize it to the world, it's just that it is silly
have to replace all the CASEQs in a working MacLisp program just to
get it to work on the LispMachine.


Date: 10 MAY 1980 2117-EDT
From: Gyro at MIT-AI (Scott W. Layson)
Subject:  (format "~:@C" char)
To: (BUG LISPM) at MIT-AI

In system 27.7, with microcode 663, on LISP Machine Nine:
... goes into an infinite loop if char is , because it thinks
it's Top- (Top- (Top- ... instead of Top-/.  "Top-/" is of
course ambiguous, on the old keyboards anyway, but ambiguity
is better than infinite looping.


Date: 10 MAY 1980 2113-EDT
From: RMS at MIT-AI (Richard M. Stallman)
To: ALAN at MIT-AI, (BUG LISPM) at MIT-AI

    ALAN@MIT-MC 05/09/80 19:53:52
        RMS@MIT-AI 05/09/80 18:04:47
            Date:  9 MAY 1980 1634-EDT
            From: ALAN at MIT-AI (Alan Bawden)

            In system 27.79 nws, with microcode 661, on LISP Machine Six:
            The LispMachine should support CASEQ.

        What7s wrong with SELECTQ?

    Nothing is wrong with SELECTQ.  But MacLisp has this thing called
    CASEQ which I use because it does the right thing with regard to
    fixnums and it was once advertized that CASEQ would be understood by
    the compiler.  I cannot have SELECTQ expand into a CASEQ because CASEQ
    will not let me mix fixnums and symbols.  The solution is obvious, on
    the LispMachine CASEQ should be a macro that expands into a SELECTQ.

Having two names on the Lisp machine, SELECTQ and CASEQ, for
constructs which are slightly different in a subtle way would be
great lossage, because nobody would remember the difference and
everyone would try to use them interchangeably and get screwed.
If SELECTQ has deficiencies with fixnums, let's just fix that.

The Lisp machine had SELECTQ and the Maclisp people decided to
introduce a gratuitous incompatibility by having something slightly
different and calling it CASEQ.  So now there is pressure on
the Lisp machine to follow them in this gratuitous change.  They make
lots of gratuitous changes and this will happen every time.  If we in
general adopt these changes for the sake of compatibility, we'll be
dragged on a wild goose chase.  We ought to decide that we won't adopt
such changes, and that the way to achieve compatibility is for
Maclisp/NIL not to make them in the first place.

Date:  9 MAY 1980 2302-EDT
From: BAK at MIT-AI (William A. Kornfeld)
Subject:  Old window system lossage
To: (BUG LISPM) at MIT-AI

When SUPDUPing and then finishing with <BACKNEXT>Q, the initial lisp listener window
is selected.  I think a more reasonable behavior would be to select the next window
down on ACTIVE-WINDOWS.  The idea is to "pop back" into what you were doing before
invoking the SUPDUP.  I'm not sure what SUPDUP in the new window system does about this.


Date:  9 MAY 1980 2302-EDT
From: BAK at MIT-AI (William A. Kornfeld)
Subject:  Old window system lossage
To: (BUG LISPM) at MIT-AI

When SUPDUPing and then finishing with <BACKNEXT>Q, the initial lisp listener window
is selected.  I think a more reasonable behavior would be to select the next window
down on ACTIVE-WINDOWS.  The idea is to "pop back" into what you were doing before
invoking the SUPDUP.  I'm not sure what SUPDUP in the new window system does about this.


Date:  9 MAY 1980 2130-EDT
From: LPD at MIT-AI (L. Peter Deutsch)
To: (BUG LISPM) at MIT-AI

In system 27.6, with microcode 661, on LISP Machine One:
The compiler lossage with rebinding DEFAULT-CONS-AREA struck again --
this time I had a macro that did a MAKE-SYMBOL (without INTERNing)
and the symbol header apparently got made in the compiler work area,
although since the machine goes into a microcode loop every time it
tries to print the symbol out I don't have much hope of tracking it
down in detail....


ALAN@MIT-MC 05/09/80 19:53:52
To: RMS at MIT-AI
CC: (BUG LISPM) at MIT-MC
    RMS@MIT-AI 05/09/80 18:04:47
        Date:  9 MAY 1980 1634-EDT
        From: ALAN at MIT-AI (Alan Bawden)

        In system 27.79 nws, with microcode 661, on LISP Machine Six:
        The LispMachine should support CASEQ.

    What7s wrong with SELECTQ?

Nothing is wrong with SELECTQ.  But MacLisp has this thing called
CASEQ which I use because it does the right thing with regard to
fixnums and it was once advertized that CASEQ would be understood by
the compiler.  I cannot have SELECTQ expand into a CASEQ because CASEQ
will not let me mix fixnums and symbols.  The solution is obvious, on
the LispMachine CASEQ should be a macro that expands into a SELECTQ.

Date:  9 MAY 1980 1634-EDT
From: ALAN at MIT-AI (Alan Bawden)
To: (BUG LISPM) at MIT-AI

In system 27.79 nws, with microcode 661, on LISP Machine Six:
The LispMachine should support CASEQ.

Date:  9 MAY 1980 0611-EDT
From: SHIPMN at MIT-AI (David W. Shipman)
To: (BUG LISPM) at MIT-AI

Howie,
  How about generating the messages ':mouse-enters and ':mouse-leaves in the new
default-mouse-handler? They indicate when the mouse enters and leaves a window and
the methods default to no-ops. I've found them to be useful.

					--Dave

MOON@MIT-MC 05/07/80 22:22:20
To: GLR at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date:  7 MAY 1980 0714-EDT
    From: GLR at MIT-AI (Jerry Roylance)
    To: (BUG LISPM) at MIT-AI


    FDEFINE (?) believes GLR;GLR LISPM is GLR;GLR > (possibly mistaking it for 
    a QFASL file)

File names are canonicalized into that form for purposes of keeping track
of where things live.  I don't think it's possible to do this "right"
in the face of conflicting file-naming conventions in ITS.  Probably something
could be done to make this particular case (login init files)
work a little better.

MOON@MIT-MC 05/07/80 22:20:39
To: GLR at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date:  7 MAY 1980 0721-EDT
    From: GLR at MIT-AI (Jerry Roylance)
    To: (BUG LISPM) at MIT-AI


    Could not successfully login to CADR-6.  It would
    start snarfing files down but would randomly get stuck
    with "CHAOS buffer" in the wholine and some percentage of
    the file read.  I tried several times in all three LODs --
    the hardware might be flaky.

You were probably running a recent microcode (UCADR 661 e.g.) with
an old-window system world which does not work correctly with it.
The 27.1 that existed on CADR-6 last I checked has this problem.
The installed band on CADR-6 (new window-system), and a more
recent old-window-system available elsewhere (27.6?) have this fixed.

It is also quite likely that even in the new window-system if you
turn off sequence-breaks when running with recent microcode you will
cause this symptom, due to not having the latest version of SI:SB-ON.
Did you do so?

Date:  7 MAY 1980 0721-EDT
From: GLR at MIT-AI (Jerry Roylance)
To: (BUG LISPM) at MIT-AI


Could not successfully login to CADR-6.  It would
start snarfing files down but would randomly get stuck
with "CHAOS buffer" in the wholine and some percentage of
the file read.  I tried several times in all three LODs --
the hardware might be flaky.



Date:  7 MAY 1980 0714-EDT
From: GLR at MIT-AI (Jerry Roylance)
To: (BUG LISPM) at MIT-AI


FDEFINE (?) believes GLR;GLR LISPM is GLR;GLR > (possibly mistaking it for 
a QFASL file)


Date:  7 MAY 1980 0120-EDT
From: RMS at MIT-AI (Richard M. Stallman)
To: HENRY at MIT-AI, (BUG LISPM) at MIT-AI

The compiler does not open-code THROW, so how can it have
such problems?

Date:  7 MAY 1980 0106-EDT
From: HENRY at MIT-AI (Henry Lieberman)
Subject:  Moon's compiler bug
To: (BUG LISPM) at MIT-AI

I have also observed similar problems in the 
case of THROW. I believe I reported this a long
time ago.

Date:  6 MAY 1980 2202-EDT
From: Moon at MIT-AI (David A. Moon)
Subject: Compiler bug
To: (BUG LISPM) at MIT-AI

The following compiler bug appears to be hard to fix, so I will content
myself with just reporting it.

Nothing anywhere in the compiler makes any attempt to unbind special
variables bound by contours unwound through by RETURN-FROM.  The
following is about the simplest case that exhibits this lossage:
	(SPECIAL FOOSP)
	(DEFUN FOO1 (X)
	    (DO () (NIL)
	      (LET ((FOOSP X))
		(RETURN)))
	    (CONS FOOSP X))

The (RETURN) turns into (RETURN-FROM-T (RETURN)) because the LET turns into
an SPROG.  In general, any GO or RETURN that passes "through" any special
bindings does not unbind them.  The only things I can find that do unbind
special bindings are function-exit and *THROW (in the microcode), and
falling off the end of a contour (and simple RETURN which turns into the
same thing.)

Needless to say it would be a good idea to fix this since it isn't hard for
it to introduce a subtle bug into someone's code (the example was rendered
down from a much more complicated function involving multiple bindings and
unwind-protects which didn't quite work.)

MOON@MIT-MC 05/06/80 21:16:03
To: LPD at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date:  6 MAY 1980 1622-EDT
    From: LPD at MIT-AI (L. Peter Deutsch)
    To: (BUG LISPM) at MIT-AI

    In system 26.4, with microcode 618, on LISP Machine Two:
    TRACE won't trace a DTP-SELECT-METHOD -- claims it's not a function.

This was fixed months ago.  Why isn't CADR-2 running a 27.xx series system?

Date:  6 MAY 1980 1622-EDT
From: LPD at MIT-AI (L. Peter Deutsch)
To: (BUG LISPM) at MIT-AI

In system 26.4, with microcode 618, on LISP Machine Two:
TRACE won't trace a DTP-SELECT-METHOD -- claims it's not a function.


Date:  5 MAY 1980 2213-EDT
From: RMS at MIT-AI (Richard M. Stallman)
Subject: FORMAT
To: INFO-LISPM at MIT-AI

Since FORMAT is now as hairy and ugly as TECO,
I have written a more Lispy replacement, RMS;OUTPUT >.
It may be more verbose for simple things, but ought to
yield more readable code for anything complicated
since you use the ordinary Lisp control constructs.


Date:  3 MAY 1980 2050-EDT
From: Agre at MIT-AI (Philip E. Agre)
To: (BUG LISPM) at MIT-AI

In system 26.3, with microcode 618, on LISP Machine Two:
I'm getting random wedgings on cadr-2 when trying to write stuff to the
color screen.  I'm using a function (HOWIES-BITBLT, written long ago by
Howie Shrobe) that writes directly into the color screen's bit array.
Generally, it gets a random amount of the way through putting my diagram
on the screen, and then cadr-2 stops with the run light on, responding
to warm boots but not to the call button.  HOWIES-BITBLT lives in
AI:AGRE;BWBITB >.

GSB@MIT-ML 05/03/80 13:44:26 Re: FORMAT - lowercasification
To: JLK at MIT-MC
CC: (BUG LISPM) at MIT-ML
I think the most general way to do this is to have an operator which
sets a "casification switch" - probably one of 4 states:  no hacking,
uppercasify, lowercasify, and capitolize first non whitespace then
revert to lowercase.  FORMAT could do this by making STANDARD-OUTPUT
into a stream which does this and sends it to the previous STANDARD-OUTPUT.
Comments?  Suggestions?


JLK@MIT-MC 05/03/80 10:04:24 Re: FORMAT
To: GSB at MIT-MC
CC: (BUG LISPM) at MIT-MC
I had the occassion to want the equivalent of EMACS Meta-C command in
format (also Meta-L).  The case in point was some routine returned
an uppercasified string which I wanted to print in lowercase, or
initial-letter-capitalized.  Does this exist?  If not, would it
be reasonable as a modification of ~A (i.e. : means lowercasify,
@ means upper casify, and :@ means Meta-C -- or is this syntax
already used?)?  I think this would be more terse than putting
a function call around the argument.  Also, I wanted this in MACLISP.


Date:  2 MAY 1980 0106-EDT
From: Henry at MIT-AI (Henry Lieberman)
To: (BUG LISPM) at MIT-AI

In system 27.6, with microcode 661, on LISP Machine One:

(ARGLIST 'FOOARRAY)

where FOOARRAY is an array returns ("DIM-1") where perhaps
a more reasonable thing is a list whose length is the
number of dimensions.


Date: 28 APR 1980 1717-EDT
From: rg at MIT-AI (Richard Greenblatt)
To: (BUG LISPM) at MIT-AI

  System 27.5 has a serious bug and should not be used.
Please copy 27.6 (now on cadrs 4,7,8) to any machine currently
running 27.5.
  The problem had to do with the combination of a change to
MAKE-SYMBOL and the corresponding change to INTERN not getting
made.  (Or actually made but not installed since that function
starts out as PKG-INTERN and gets moved to INTERN during initialization.).
This could result in symbols, pnames, etc getting created in
temporary areas followed by all kinds of lossage.  The recently
reported GC drop-deadage was due to this.
  27.6 also has other fixes and improvements.  It makes use of
the new microcode assisted STRING-EQUAL and STRING-SEARCH-CHAR.
This is noticable when reading large files into the editor.


Date: 28 APR 1980 0905-EDT
From: jim@mc at MIT-AI
To: (BUG LISPM) at MIT-AI

Walk up to CADR-4 and type (si:gc-flip-now). It will think for a few minutes,
type out a message about flippling, then the mode-line will read TYI....
but you can't cause the machine is hung. The code says this is a user-callable
function.

Date: 28 APR 1980 0309-EDT
From: HIC at MIT-AI (Howard I. Cannon)
To: (BUG LISPM) at MIT-AI

Sorry, that meant to say "never reuse the rqb if it is not a short array"

Date: 28 APR 1980 0306-EDT
From: HIC at MIT-AI (Howard I. Cannon)
To: MOON at MIT-AI, RG at MIT-AI
CC: (BUG LISPM) at MIT-AI

I just fixed a bug in GET-DISK-RQB causing it to never reuse the same RQB.
I suspect that this will cause things like partition transfers to work somewhat
faster.


Date: 27 APR 1980 1942-EST
From: Agre at MIT-AI (Philip E. Agre)
To: (BUG LISPM) at MIT-AI

In system 26.3, with microcode 618, on LISP Machine Two:
The ZWEI text mode, the command M-Q (Fill or Adjust Paragraph) doesn't know
that the paragraph's over when there's a period in column 1.  This causes
it to create a huge mess of a paragraph over some random large chunk of a file
rather than just justifying the paragraph.  For example, with the cursor at "_":

.c Start
.br
.ablock 4
.sp 2
In system 26.3, with microcode 618, on LISP Machine Two:
The ZWEI text mode, the command M-Q (Fill or Adjust Paragraph) doesn't know
that the paragraph's over when there's a period in column 1.  This causes
it to create a huge mess of a paragraph over some random large chunk of a file
rather than just justifying the paragraph.  For example, with the cursor at "_":
.sp 2
More text here in a new paragraph.
.sp 1
.c End 




.c Start
.br
.ablock 4
.sp 2 In system 26.3, with microcode 618, on LISP Machine Two: The ZWEI
text mode, the command M-Q (Fill or Adjust Paragraph) doesn't know that
the paragraph's over when there's a period in column 1.  This causes it
to create a huge mess of a paragraph over some random large chunk of a
file rather than just justifying the paragraph.  For example, with the
cursor at "_": .sp 2
More text here in a new paragraph.
.sp 1
.c End 



Date: 25 APR 1980 0948-EST
From: Quux,DP at MIT-MC
Sent-by: GLS at MIT-MC
Subject: Last most final note on DO-NAMED and Lexical CATCH
To: (BUG LISP) at MIT-MC, (BUG LISPM) at MIT-MC, NIL at MIT-MC
To: rpg at SU-AI, rod at SU-AI

The latest poop:

    Date:  9 APR 1980 21:08-EST
    From: Daniel L. Weinreb <DLW at MIT-AI>
    Subject: Yet another note on lexical CATCH
    To: BUG-LISP) at MIT-MC, (BUG LISP) at MIT-MC, (BUG LISPM) at the S-1 NIL compiler in fact
    implements a construct called PROG-BODY with precisely those semantics;
    PROG is then turned into a nested LET and PROG-BODY.  This was done
    to concentrate all knowledge of variable bindings into one place --
    the catch, and END ends it (but not in the usual sense!).
    ^_ 
    Date: 16 April 1980 01:49-EST
    From: John L. Kulp <JLK at MIT-MC>
    Subject:  Name for lexical CATCH
    To: GLS at MIT-MC

    Let's not flush old-stye DO, and let's not in the usual
    sense!).
    ^_ 
    Date:  9 APR 1980 1935-EST
    From: JONL at MIT-AI>
    Subject: DO-NAMED
    To: BUG-LISP at MIT-AI, BUG-LISPM at MIT-MC (David A. Moon)
    Subject: GLS would like the construct we're X) ...) isn't so bad...
    But since we're talking about it, has anyone given thought recently
    to actually flushing the old-style DO syntax?  It certainly becomes
    less useful if you have DOTIMES and a couple orders of magnitude slower than the
    pop/jump sequence of a named prog and return.  *THROWs outside the
    context where they should be BLOCK, with EXIT used to mean a
    lexical throw.  Thus
    which could be called "*CATCH"; you could be called "*CATCH"; you could have merely one version
    of each special form, and then put a *CATCH around it if you need
    a named escape expression.  This functionality in all these forms, either with different
    function names (DO versus DO-NAMED) or different syntaxes (DOTIMES or REPEAT, and old-style DO flushable?
    ^_   
    Date: 15 April 1980 13:51-EST
    From: MOON at MIT-MC (David A. Moon)
    Subject: GLS would like to push again for hairiferous DO
    To: GLS at MIT-MC (Robert W. Kerns)
    Sent-by: ___024 at MIT-MC
    Subject: Lexical Catch/*THROW instead?  This means it must either punt or resort to keywords.  I think even people who "would
    never ever use" LOOP would agree that LOOP, ask GSB for a copy of the documentation.

    As far as this argument degerate into an argument over names?
    ^_    
    Date: 15 April 1980 04:59-EST
    From: RWK at MIT-MC (Robert W. Kerns)
    Sent my feelings on this issue of how DO/PROG could be done in order
	this haggling, part of which I think comes out of the fact that these forms, why
    not "subroutinize out" the functionality into a new special form,
    which could be called "*CATCH"; you could have merely one way (named PROG and
    DO-NAMED) of saying it.  I'm not sure that I would go so far as to take to have more than one way (named PROG and THROW was affected, so writing an automatic converter 
    was trivial.
    ^_
    Date: 9 April 1980 21:16-EST
    From: Richard M. Stallman <RMS at MIT-AI>
    Subject:  Old-style DO flushable?

    Why don't we let this argument degerate into an the
    pop/jump sequence of a named prog and return.  *THROWs outside the
    context where they should be allowed would find the *CATCH above them,
    unlike the construct we're: Lexical CATCH and named constructs
    ^_
    Date: 15 APR 1980 0419-EST
    From: MOON at MIT-MC (David A. Moon)
    Subject: GLS would like a winner.  I'm considering adding it to Rutgers
    Lisp under the name of maclisp CATCH and THROW.  Is it time to
    introduce RPTQ (or REPEAT) and take to have more than one way (named PROG and
    DO-NAMED) of form if form returns normally or
    the value returned from it if that gives you any basis for comparison.)
    form1 form2 ...) like DO is now but doesn't allow
	 return or the
    like for the associated throw, which is slightly distasteful.
    HOOK perhaps.  Hmm. sounds good.
    -------
    ^_   
    Date: 15 April 1980 23:49-EST
    From: "Guy L. Steele, Jr." <GLS at MIT-AI>
    Subject: Lexical CATCH and named constructs
    To: BUG-LISP at MIT-AI, BUG-LISPM at MIT-AI, nil at MIT-MC (David A. Moon)
    Subject: GLS would like to push again for hairiferous DO
    To: GLS at MIT-MC, (BUG LISP) at MIT-MC

	Maybe do it with various kinds of parentheses:

	    [SETQ X {CAR (IF [OR (CAR (IF [OR (CAR X)
				 (AND (CDR X) (RETURN-FROM "[" 3))
				 (RETURN-FROM "{" 5)]
			     [RETURN-FROM specifying name (or just a RETURN-FROM "[" 3))
				 (RETURN-FROM "{" 5)]
			     [RETURN-FROM: Kent M. Pitman <KMP at MIT-MC (Robert W. Kerns)
    ^_
    Date: 16 April 1980 22:40-EST
    From: Kent M. Pitman <KMP at MIT-MC>
    Subject:  DOTIMES
    But at least some, myself included, feel the future, each of
    which would have to have two versions for a very 
    simple REPEAT syntax
    ^_
    Date: 8 April 1980 20:43-EST
    From: Daniel L. Weinreb <DLW at MIT-AI>
    Subject: DO-NAMED
    To: BUG-LISP at MIT-AI, BUG-LISPM at MIT-AI

    Let's not flush old-style DO-NAMED GORILLA ...)
    ^_   
    Date: 12 April 1980 21:08-EST
    From: Daniel L. Weinreb 
    <DLW at would be best in anything by forcing people to stop using
    the old forms.

    ^_    
    Date: 11 APR 1980 0337-EST
    From: JPG at MIT-MC (David A. Moon)
    Subject: GLS would like the construct we're looking for.
    ^_


Date: 25 April 1980 04:39-EST
From: James E. O'Dell <JIM at MIT-MC>
Subject: FILLARRAY
To: MOON at MIT-MC, JIM at MIT-MC
cc: BUG-LISPM at MIT-MC

I will have to figure out more of what is actually going into those arrays
and decide if they elements ever want to be negative, thanks.

Date: 24 April 1980 14:55-EST
From: "Guy L. Steele, Jr." <GLS at MIT-AI>
Subject: DEFVAR and DEFCONST
To: INFO-LISPM at MIT-AI


    From: David Chapman <ZVONA at MIT-AI>

    I sometimes change the value of a constant in the source and then would like to
    be able to use c-t-c to reset it. GLS's suggestion would not allow this.

    MOON@MIT-MC 04/21/80 20:25:32 Re: DEFVAR and DEFCONST
	I would recommend that DEFCONST not always reinitialize the variable
	involved, but should complain if the variable is bound and is
	not EQUAL to the newly computed value?
    Why?  The point of DEFCONST is to be the one that always reinitializes
    it, so that you can change the value.  What did you have in mind with
    this suggestion?

Having this sort of error-check would guarantee consistency in the case that
a DEFCONST for a given constant appeared in more than one file (which would
be useful for various reasons).  Maybe there should be a third thing --
but it seems to me that a "constant" should be constant.  My suggestion
would allow you to change the constant, but only after an error break.
Maybe the criteria for giving an error should be the same as those for
giving an error in FDEFINE.

HIC@MIT-MC 04/24/80 13:13:44
To: JIM at MIT-MC
CC: (BUG LISPM) at MIT-MC
It is a bug that FILLARRAY and LISTARRAY don't work, and it
will be fixed.  As MOON points out, it might not be fastm
but it will be MacLisp compatible.


MOON@MIT-MC 04/24/80 12:39:13 Re: FILLARRAY
To: JIM at MIT-MC
CC: (BUG LISPM) at MIT-MC
Yes, FILLARRAY and LISTARRAY should work for multi-dimensional arrays.
One reason we haven't done this is that Lisp machine arrays are not
stored in the same order as Maclisp arrays.  Probably it would be best
for these functions to operate in the Maclisp-compatible row-major
order rather than the order things are stored in.  Another reason we
haven't done this is that as currently written FILLARRAY is too slow
anyway.  But if written in microcode these functions would probably
operate in storage order, incompatible with Maclisp.  Of course,
for *ARRAY the order doesn't matter since it is storing the same thing
in all locations of the array.  Unless someone has a better idea, we
should implement a function named something like FILL-ARRAY-WITH-SCALAR
or INITIALIZE-ARRAY and have *ARRAY call it.

However, note that it may possibly be the case that what you really want is
MAKE-ARRAY of one of the positive-integer type arrays (ART-1B,
ART-2B, ART-4B, ..., ART-16B).  These arrays do get initialized to zero,
and efficiently, too.  But they won't hold negative numbers.


JIM@MIT-MC 04/24/80 12:02:02
To: (BUG LISPM) at MIT-MC
How 'bout making FILLARRAY work for multidimensional arrays.
(*array () 'FIXNUM 2 2) bombs out now but (*array () 'FIXNUM 2) works.

MOON@MIT-MC 04/22/80 21:58:52
To: LPD at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date: 22 APR 1980 1435-EST
    From: LPD at MIT-AI (L. Peter Deutsch)
    To: (BUG LISPM) at MIT-AI

    In system 26.20 NWS, with microcode 657, on LISP Machine Six:
    Trying to do a Help Apropos "mail" or "compile" (or, I suspect, anything else)
    bombs trying to take CADR of a closure.  Maybe this is a result of the recent
    change which made closures not behave like lists wrt CAR/CDR?

Yes, that system and that microcode don't really go together.

Date: 22 APR 1980 1501-EST
From: LPD at MIT-AI (L. Peter Deutsch)
To: (BUG LISPM) at MIT-AI

In system 26.20 NWS, with microcode 657, on LISP Machine Six:
After apparently completing a Rename File command successfully, ZWEI got an error
trying to pass T to =.


Date: 22 APR 1980 1435-EST
From: LPD at MIT-AI (L. Peter Deutsch)
To: (BUG LISPM) at MIT-AI

In system 26.20 NWS, with microcode 657, on LISP Machine Six:
Trying to do a Help Apropos "mail" or "compile" (or, I suspect, anything else)
bombs trying to take CADR of a closure.  Maybe this is a result of the recent
change which made closures not behave like lists wrt CAR/CDR?


HIC@MIT-MC 04/22/80 13:07:32 Re: New window system
To: info-lispm at MIT-AI
I will be talking about the new window system this Thursday, April 24,
from 3:00 to 5:00 PM in the playroom.  I will discuss it from both the
user and programmer point of view.  I strongly suggest that anyone
who plans on using the new window system as a programmer attend.


Date: 22 April 1980 13:02-EST
From: Howard I. Cannon <HIC at MIT-MC>
To: xconos at MIT-AI
cc: BUG-LISPM at MIT-AI

This is a well known bug.  You can fix it by loading the file LMIO;GRIND
sometime this evening, as soon as I recompile it.


Date: 22 APR 1980 0558-EST
From: xconos at MIT-AI (Alec Destry)
Sent-by: ___037 at MIT-AI
To: (BUG LISPM) at MIT-AI

    There is a bug somewhere in grindef such that you get the message:

   THE VARIABLE SI:EH-CONDITION-HANDLERS IS UNBOUND.

  I hope that is enough to find the bug.  You should have no trouble finding it.
Just run grindef.

Date: 21 April 1980 20:46-EST
From: David Chapman <ZVONA at MIT-AI>
Subject: DEFVAR and DEFCONST
To: INFO-LISPM at MIT-AI

I sometimes change the value of a constant in the source and then would like to
be able to use c-t-c to reset it. GLS's suggestion would not allow this.

Date: 21 APR 1980 0804-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
Subject: DEFVAR and DEFCONST
To: INFO-LISPM at MIT-AI

I would recommend that DEFCONST not always reinitialize the variable
involved, but should complain if the variable is bound and is
not EQUAL to the newly computed value?

Date: 21 APR 1980 0420-EST
From: XCONOS at MIT-AI (Alec Destry)
To: (BUG LISPM) at MIT-AI

  When you quit DIRED in ZWEI on the lisp machine after indicating files to
be deleted but without deleting them, dired gets hung on wanting to delete
those files and only those files every subsequent time you enter dired.

Date: 20 APR 1980 2126-EST
From: Moon at MIT-AI (David A. Moon)
To: (BUG LISPM) at MIT-AI

I got scrod by the fact that there was no way to reload the microcode
of another machine over the debug interface.  So I made the following
source change: I removed CADR:STUFF-MCR-FILE from the Lisp machine version
since it had no hope of working, and fixed SI:LOAD-MCR-FILE so that it
could work over the debug interface (give a third argument of the machine name).
Haven't tested it, I'm ashamed to say, but it should work.

Date: 20 APR 1980 2032-EST
From: RG at MIT-AI (Richard Greenblatt)
To: INFO-LISPM at MIT-AI

  DEFCONST is clearly an improvement on DEFVAR-SETQ, so I have flushed
the latter in favor of the former.

Date: 20 April 1980 17:17-EST
From: Mark L. Miller <MILLER at MIT-AI>
Subject:  Automatic Conversion
To: JPG at MIT-MC, JONL at MIT-MC
cc: BUG-LISP at MIT-AI, BUG-LISPM at MIT-AI, EJS at MIT-MC, H at MIT-MC,
    KMP at MIT-MC, HENRY at MIT-MC

Why not a several stage conversion process as follows:
0.  The current state of affairs (one DO supports both old and new).
1.  Rename the current function POSSIBLE-OLD-STYLE-DO and keep supporting it.
    Users wanting automatic upwards-compatibility can use MM REPLACE to
    change their current code to that.  (Using Query Replace, one could even
    optionally chose to NOT rename obviously-new-style DO's.)
    POSSIBLE-OLD-STYLE-DO would do what DO does now, but be autoloading
    and not necessarily efficient.  Keep current DO also for a while.
2.  Redefine DO to support only the new style after much warning.
3.  Eventually delete the autoload property for POSSIBLE-OLD-STYLE-DO from the
    default environment.
This sort of scheme might turn out to be useful for other changes as well.
Regards, Mark

Date: 20 APR 1980 0730-EST
From: GLR at MIT-AI (Jerry Roylance)
Subject: DEFVAR
To: MOON at MIT-MC
CC: INFO-LISPM at MIT-AI


It would be nice if the compiler substituted for a (DEFCONST FOO 'BAR)
and didn't bother to tell the rest of the world about the definition.

MOON@MIT-MC 04/19/80 23:55:08 Re: Binary i/o
To: Henry at MIT-AI
CC: (BUG LISPM) at MIT-MC
Fixed.  Was a long-standing bug in the file server on ITS.

MOON@MIT-MC 04/19/80 23:40:06 Re: DEFVAR
To: info-lispm at MIT-AI
I think there should be two special forms for defining symbols with global
variables, one called DEFVAR and one called DEFCONST.  DEFCONST should reinitialize
the symbol every time it is seen, while DEFVAR should reinitialize it only if
it is unbound (the theory being that since it is a variable its current value
should not be disturbed.)  There should also be a variable you can bind while
loading a file to cause all its DEFVARs to be redone.  I suspect that DEFVAR's
present behavior while imperfect probably has the least problems short of
reading the user's mind.

However, note that (DEFCONST FOO value) has the same effect as
(DEFVAR FOO) (SETQ FOO value) and therefore may be superfluous.

MOON@MIT-MC 04/19/80 23:04:02 Re: errors
To: HENRY at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date: 19 APR 1980 1754-EST
    From: HENRY at MIT-AI (Henry Lieberman)
    Subject:  errors
    To: (BUG LISPM) at MIT-AI

    What's a good way to divert error messages to a different 
    stream? The manual mentions an ERROR-OUTPUT stream, which 
    seems like a good idea, but seems not to be implemented.
    EH-SECOND-LEVEL binds STANDARD-OUTPUT to SYN-TERMINAL-IO, 
    binding that doesn't seem the way to go.
Well, ERROR-OUTPUT is supposed to work, but doesn't happen to.
Perhaps it will be fixed some day.  No one seems to have had a good
reason to use it yet.  Note that a reasonable thing to do is to
divert STANDARD-OUTPUT and or STANDARD-INPUT to be different from
TERMINAL-IO, which is supposed to be the stream over which all interaction
occurs.

There is also a global variable which you can use to divert error messages.
This is different from ERROR-OUTPUT in that it works for all processes rather
than being something a process can bind to affect just itself.  This variable
is called SI:ERROR-HANDLER-IO in the old window system and EH:ERROR-HANDLER-IO
in the new window system.  It takes effect if non-NIL.  Since this is for
all processes, it is normally used when debugging part of the system rather
than for "application" type use.


Date: 19 April 1980 19:51-EST
From: Gerald R. Barber <JERRYB at MIT-AI>
To: MOON at MIT-MC
cc: BUG-LISPM at MIT-AI

    Date: 04/18/80 23:00:10
    From: MOON at MIT-MC
    To:   (BUG LISPM)
    cc:   jerryb

        Date: 18 APR 1980 1851-EST
        From: jerryb at MIT-AI (Gerald R. Barber)

        (string-reverse-search-set '(#/a) "abc")
        returns 1. instead of 0.

    This is not a bug, exactly.  The documentation in the manual and the documentation
    in the code differ about what STRING-REVERSE-SEARCH-SET and STRING-REVERSE-SEARCH-NOT-SET
    are supposed to do.  What they do now is convenient for functions like STRING-TRIM,
    but is not consistent with what you would expect based on the other searching functions.

    Any suggestions for what to do?  (Declare the manual to be wrong or change the functions
    and the several places that call them.)

I would prefer that they would follow the explanation in the manual, ie the
example above would return 0, just because that is what the name of the
function suggests.  At any rate, as it stands now the form
	(string-reverse-search-char #/a "abc")
returns 0.  String-reverse-search-char and string-reverse-search-set should at
least be consistent. 

Date: 19 APR 1980 1754-EST
From: HENRY at MIT-AI (Henry Lieberman)
Subject:  errors
To: (BUG LISPM) at MIT-AI

What's a good way to divert error messages to a different 
stream? The manual mentions an ERROR-OUTPUT stream, which 
seems like a good idea, but seems not to be implemented.
EH-SECOND-LEVEL binds STANDARD-OUTPUT to SYN-TERMINAL-IO, 
binding that doesn't seem the way to go.

Date: 19 APR 1980 1726-EST
From: Henry at MIT-AI (Henry Lieberman)
Subject:  Binary i/o
To: (BUG LISPM) at MIT-AI

I tried writing a binary file and reading it back in.
What seems to happen is that you wind up reading
past the end of file.
(WRITE-BINARY-FILE) followed by (READ-BINARY-FILE)
returns a list with the stuff written and a lot of extraneous garbage 
at the end.


(EVAL-WHEN (EVAL LOAD COMPILE)
	   (COND ((NOT (STATUS FEATURE LOOP)) (LOAD "liblsp;loop") (SSTATUS FEATURE LOOP))))

(DEFUN READ-BINARY-FILE ()
       (LET ((FILE (OPEN "henry;use less" '(READ FIXNUM))))
	    (LOOP FOR NEXT-WORD =  (TYI FILE 'END-OF-FILE)
		  UNTIL (EQ NEXT-WORD 'END-OF-FILE)
		  COLLECT NEXT-WORD)))

(DEFUN WRITE-BINARY-FILE ()
       (LET ((A-FILE (OPEN "henry;use less" '(WRITE FIXNUM))))
	    (TYO 17. A-FILE)
	    (TYO 69. A-FILE)
	    (CLOSE A-FILE)))



Date: 19 APR 1980 1341-EST
From: RG at MIT-AI (Richard Greenblatt)
To: INFO-LISPM at MIT-AI

  The feature of DEFVAR that it only initializes the variable if
it was previously unbound sometimes leads to hard to find bugs.
I have defined DEFVAR-SETQ in the source which always does a setq if
initialization is given.  Really tho, I think the default should be
the other way, with DEFVAR always doing the initialization, and 
something else doing it only if the variable is unbound.  It
might not be too late to change this, although it would be
moderately painful.

Date: 19 APR 1980 0130-EST
From: Henry at MIT-AI (Henry Lieberman)
To: (BUG LISPM) at MIT-AI

How bout having streams take a PRINT message in addition to TYO, etc.
Often I would like to have output streams that intercept things at the PRINT
level, TYO's too late.


MOON@MIT-MC 04/18/80 23:00:10
To: (BUG LISPM) at MIT-AI
CC: jerryb at MIT-AI
    Date: 18 APR 1980 1851-EST
    From: jerryb at MIT-AI (Gerald R. Barber)

    (string-reverse-search-set '(#/a) "abc")
    returns 1. instead of 0.

This is not a bug, exactly.  The documentation in the manual and the documentation
in the code differ about what STRING-REVERSE-SEARCH-SET and STRING-REVERSE-SEARCH-NOT-SET
are supposed to do.  What they do now is convenient for functions like STRING-TRIM,
but is not consistent with what you would expect based on the other searching functions.

Any suggestions for what to do?  (Declare the manual to be wrong or change the functions
and the several places that call them.)

Date: 18 APR 1980 1851-EST
From: jerryb at MIT-AI (Gerald R. Barber)
To: (BUG LISPM) at MIT-AI

In system 27.1, with microcode 635, on LISP Machine One:

(string-reverse-search-set '(#/a) "abc")

returns 1. instead of 0.


Date: 18 APR 1980 0212-EST
From: Moon at MIT-AI (David A. Moon)
Subject: Gratuitous changes...
To: (BUG LISPM) at MIT-AI

I have made the source changes appropriate to the new microcoded NTH, NTHCDR,
and string functions.  STRING-EQUAL and forwards non-set string searching should
be very much faster.  Also more vestiges of case-shifts in strings have been
flushed (they hardly worked anywhere.)

Date: 18 APR 1980 0106-EST
From: MOON at MIT-AI (David A. Moon)
Subject: Incompatible change
To: INFO-LISPM at MIT-AI

If you call MAKE-SYMBOL with more than one argument, you will need to change
your code in the next world.  It is highly unlikely that anyone does, but
I am announcing it anyway just in case.  See the documentation in LMMAN;FD.SYM
if it matters to you.

Date: 17 April 1980 23:37-EST
From: Howard I. Cannon <HIC at MIT-MC>
Subject:  Grind
To: MOON at MIT-MC
cc: BUG-LISPM at MIT-MC

The bug in Grind such that grinding AND's would not work has been
fixed in the source.  The EH:CONDITION-HANDLERS bug will be taken care
of by a recompilation in the old window system world.


Date: 17 APR 1980 1548-EST
From: Gyro at MIT-AI (Scott W. Layson)
Subject:  grinder
To: (BUG LISPM) at MIT-AI

In system 27.4, with microcode 645, on LISP Machine Four:
Something strange seems to be wrong with this (system 27) grinder.  I'm trying
to run (MEXP) and keep getting errors like
"The argument CONS was #<DTP-LOCATIVE 104...>, which is not a CONS
While in the function CAR-LOCATION  SI:GRIND-AND  SI:GRIND-FORM"

Also, when I try to grind a not-particularly-complicated sexp using (grindef),
I get:
"The variable EH:CONDITION-HANDLERS is unbound.
While in the function SI:GRIND-COUNT-IO SI:PRINT-RAW-STRING  SI:PRINT-PNAME-STRING"

I hope this is enough info to locate the bug.  It seems bad enough that
you should have no trouble regenerating it.


Date: 16 APR 1980 1717-EST
From: LPD at MIT-AI (L. Peter Deutsch)
To: (BUG LISPM) at MIT-AI

In system 26.3, with microcode 618, on LISP Machine Two:
The Meta-s command centers the line between the physical boundaries of the window,
not between the margins established for Filling.  (I suppose one can argue as to
whether this is a bug, but it certainly wasn't what I wanted, and I couldn't find
any way to set the window size to a precise number of characters or pixels.)


Date: 16 APR 1980 1043-EST
From: ECC at MIT-AI (Eugene C. Ciccarelli)
To: (BUG LISPM) at MIT-AI

In system 27.4, with microcode 645, on LISP Machine Four:
(format t "~:@c" #10r14)
will infinitely expand the circle-with-cross (Top-I) as:
 (Top- (Top- (Top-....


Date: 16 Apr 1980 0419-PST
From: Scott at SRI-KL (Scott J. Kramer)
Subject: Re: Lexical CATCH and named constructs
To: QUUX at MIT-AI, BUG-LISP at MIT-AI, BUG-LISPM at MIT-AI, nil at MIT-MC
In-Reply-To: Your message of 16-Apr-80 0131-PST

    Mail-from: ARPAnet host MIT-MC rcvd at 16-Apr-80 0414-PST
    Date: 16 April 1980 04:31-EST
    From: Quux <QUUX at MIT-AI>
    Subject: Lexical CATCH and named constructs
    To: BUG-LISP at MIT-AI, BUG-LISPM at MIT-AI, nil at MIT-MC

    Maybe do it with various kinds of parentheses:

    	[SETQ X {CAR (IF [OR (CAR X)
    			     (AND (CDR X) (RETURN-FROM "[" 3))
    			     (RETURN-FROM "{" 5)]
    			 [RETURN-FROM "[" 6]
    			 LOSER)}]

Bletch, that's the grossest looking code I've ever seen!
-------

Date: 16 APR 1980 0431-EST
From: QUUX at MIT-AI (Quux)
Subject: Lexical CATCH and named constructs
To: (BUG LISP) at MIT-AI, (BUG LISPM) at MIT-AI, nil at MIT-MC

Maybe do it with various kinds of parentheses:

	[SETQ X {CAR (IF [OR (CAR X)
			     (AND (CDR X) (RETURN-FROM "[" 3))
			     (RETURN-FROM "{" 5)]
			 [RETURN-FROM "[" 6]
			 LOSER)}]

Of course, you'd need a lot of different parentheses in general.
Maybe Carl has some ideas about this.

(This idea inspired by super-brackets -- use brackets to convey
control, not just textual, "closing off".)

Date: 16 April 1980 01:49-EST
From: John L. Kulp <JLK at MIT-MC>
Subject:  Name for lexical CATCH
To: GLS at MIT-MC
cc: BUG-LISPM at MIT-MC, BUG-LISP at MIT-MC, NIL at MIT-MC

Sorry, but I couldn't resist this:
Call it BLETCH (Block and LExical caTCH)....


Date: 16 APR 1980 0139-EST
From: GLS at MIT-MC (Guy L. Steele, Jr.)
Subject: Name for lexical CATCH
To: (BUG LISPM) at MIT-MC, (BUG LISP) at MIT-MC, NIL at MIT-MC

Well, I'd like to avoid puns like LATCH.  A name which might
even appeal to ALGOL types and help win them over to our wonderful
way of doing things might be BLOCK, with EXIT used to mean a
lexical throw.  Thus
	(BLOCK CRUFT
	       (GROSS OUT)
	       (AND (LOSE) (EXIT CRUFT))
	       (AND WIN (EXIT CRUFT 43))
	       19)

The next suggestion is less serious, but if you can't stomach
BLOCK, then why not confuse the world by using BEGIN and END?
BEGIN begins the catch, and END ends it (but not in the usual
sense!).


Date: 15 APR 1980 2349-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
Subject: Yet another note on lexical CATCH
To: (BUG LISP) at MIT-AI, (BUG LISPM) at MIT-AI, NIL at MIT-MC

Regarding Henry's note that he never uses named constructs,
let me say that I haved used them about three times total ever.
But when I need it, it's the right thing to have!  (I've also
used PROG about three times in the past year, and HAULONG
about twice, if that gives you any basis for comparison.)

Date: 15 April 1980 13:51-EST
From: Alan Bawden <ALAN at MIT-MC>
Subject: Lexical Catch
To: RWK at MIT-MC, BUG-LISP at MIT-MC, BUG-LISPM at MIT-MC

I propose we name this construct LEXICAL-CATCH (what a novel thought!).

Date: 15 April 1980 08:59-EST
From: Dan Brotsky <DCB at MIT-AI>
Subject:  GLS's DO suggestion
To: BUG-LISP at MIT-MC, BUG-LISPM at MIT-MC

GLS's suggestion about parallel/sequential do interpretation
seems wonderful to me, since I often find cooperating parallel
and sequential assignments just what the doctor ordered.

I'm not so happy with the update-defaults-to-init suggestion
since it seems to introduce an arbitrariness motivated only
by a desire to type less, but I could live with it.
	dan



Date: 15 APR 1980 0525-EST
From: KMP at MIT-MC (Kent M. Pitman)
Subject: Can I talk again yet?
To: (BUG LISP) at MIT-MC
CC: (BUG LISPM) at MIT-MC, H at MIT-MC, HENRY at MIT-MC, GLS at MIT-MC
CC: EJS at MIT-MC

I want ITERATE as a separate construct. Implementing it with GO is not 
satisfactory. People doing (ITERATE ...) will know they can put GO's and prog
tags in the toplevel of that form. I would like to have a form which guarantees
to my eye when scanning code that there will be no GO's or prog-tags there.


Date: 15 APR 1980 0448-EST
From: RWK at MIT-MC (Robert W. Kerns)
Sent-by: ___024 at MIT-MC
Subject: Lexical Catch
To: GLS at MIT-MC, (BUG LISP) at MIT-MC, (BUG LISPM) at MIT-MC
To: EJS at MIT-MC, H at MIT-MC, HENRY at MIT-MC

I'd hoped that the LEXICAL catch was the end of the debate.  To help end it,
let me add my voice to the consensus that a lexical catch is what is wanted.

Why don't we let this argument degerate into an argument over names?


Date: 15 APR 1980 0419-EST
From: MOON at MIT-MC (David A. Moon)
Subject: GLS would like to push again for hairiferous DO
To: GLS at MIT-MC, (BUG LISP) at MIT-MC, (BUG LISPM) at MIT-MC
CC: EJS at MIT-MC, JONL at MIT-MC, H at MIT-MC, KMP at MIT-MC
CC: HENRY at MIT-MC

I don't think that it is at all syntactically clear what this
yet-further-extended form of DO does.  At some point you reach
diminishing returns with doing all your syntax with parentheses, and
must either punt or resort to keywords.  I think even people who "would
never ever use" LOOP would agree that LOOP is a greatly preferable way
of saying the same things than your DO with 3 open parentheses.  If you
aren't familiar with LOOP, ask GSB for a copy of the documentation.

As far as this much too protracted discussion of named constructs goes,
my considered opinion is that the correct way of documenting it is as a
lexically-scoped catch.  It has the usual small efficiency and modularity
advantages of lexical scoping over dynamic scoping.  (The fact that the
cost of dynamic CATCH is very much larger in pdp10 Maclisp is purely
a historical artifact of the implementation and is not conceptually
necessary; it -is- conceptually necessary that it be a little more
expensive, as it is in the Lisp machine.)

It was probably a mistake to have more than one way (named PROG and
DO-NAMED) of saying it.  I'm not sure that I would go so far as to take
one of them out, although probably that would be best in the long run.
I don't think it's necessary or useful to have function names for every
possible combination of primitive operators.

Date: 15 APR 1980 0049-EST
From: JONL at MIT-MC (Jon L White)
Subject: PROG-BODY
To: GLS at MIT-MC
CC: NIL at MIT-MC, (BUG LISPM) at MIT-MC, (BUG LISP) at MIT-MC
CC: HENRY at MIT-MC

LISP370 employed a "PROG-SEQ" as a variable-less PROG, so
that contours could be concentrated under one construct, LAMBDA.
The generic- and VAX-specific NIL compiler also does this.
As RMS earlier pointed out, a single named construct should
suffice for all end-user purposes;  we have it now in the
slightly haired regular PROG.  Also happy to hear first vote
from HENRY that he uses no named constructs ever.


Date: 15 April 1980 00:40-EST
From: "Guy L. Steele, Jr." <GLS at MIT-MC>
Subject: What should we DO?
To: BUG-LISP at MIT-MC, NIL at MIT-MC, BUG-LISPM at MIT-MC
cc: KMP at MIT-MC, H at MIT-MC, HENRY at MIT-MC, RMS at MIT-MC,
    MOON at MIT-MC


    My personal feelings on this are that we should come up with consistent
    rules about these things. Documentation is much simpler if you could
    generalize in it. So I would prefer flushing old-DO in the longrun but
    it's probably unworkable at present. There's no reason to leave ourselves
    open to future problems of this sort by implementing something now without
    thinking first -- which is why I advocated not allowing (DOTIMES n ...).
    I was not advocating that (DOTIMES lab ...) be installed -- just allowing
    for that contingency.

    I now present my feelings on this issue of how DO/PROG could be done in order
    this haggling, part of which I think comes out of the fact that these return
    tags are tied up in PROG-ness and so on ... Suppose you had the following
    primitives in Lisp:

    (PROG-BODY ...) which evaluated all non-atomic stuff. Atoms were GO-tags.
     Returns () if you fall off the end. RETURN does not work from this form.

    (PROG-RETURN-POINT form name) name is not evaluated. Form is evaluated and
     if a RETURN-FROM specifying name (or just a RETURN) were executed, control
     would pass to here. Returns the value of form if form returns normally or
     the value returned from it if a RETURN or RETURN-FROM is executed. [Note:
     this is not a [*]CATCH because it is lexical in nature and optimized out
     by the compiler. Also, a distinction between NAMED-PROG-RETURN-POINT
     and UNNAMED-PROG-RETURN-POINT might be desirable -- extrapolate for yourself
     how this would change things -- I'll just present the basic idea here.]

    (ITERATE bindings test form1 form2 ...) like DO is now but doesn't allow
     return or goto. All forms are evaluated. GO does not work to get to any form
     in the iteration body.

Seriously, folks, my own position on DO and friends is largely in agreement
with KMP here.  His PROG-RETURN-POINT is simply the lexical catch advocated
by DLW, with allowances for how RETURN could be expressed in terms of that.
It is of interest to note that the S-1 NIL compiler in fact
implements a construct called PROG-BODY with precisely those semantics;
PROG is then turned into a nested LET and PROG-BODY.  This was done
to concentrate all knowledge of variable bindings into one place --
the code that handles LAMBDA.  The original intent was just to use
this construct internally to the compiler, but indeed it may be a useful
building-block for other macros.

Date: 15 April 1980 00:10-EST
From: "Guy L. Steele, Jr." <GLS at MIT-MC>
Subject: Named constructs
To: JONL at MIT-MC
cc: MOON at MIT-MC, H at MIT-MC, KMP at MIT-MC, HENRY at MIT-MC,
    BUG-LISPM at MIT-MC, BUG-LISP at MIT-MC

    From: JONL at MIT-MC (Jon L White)
    Uh, don't these things only apply to prog-like constructs? things
    with GOs and RETURNs or loops in them?

Why?


Date: 15 April 1980 00:09-EST
From: Quux <Quux at MIT-MC>
Sender: GLS at MIT-MC
Subject: Inconsistency in various DOs
cc: MOON at MIT-MC, JONL at MIT-MC, H at MIT-MC, KMP at MIT-MC,
    HENRY at MIT-MC, BUG-LISP at MIT-MC, BUG-LISPM at MIT-MC

    Date: 12 APR 1980 1831-EST
    From: MOON at MIT-MC (David A. Moon)

    If you're going to promote named DOTIMES's, you might as well promote
    named CONS, named PLUS, named ADD1, etc.


Two great minds... I guess MOON gets academic priority on this one.


Date: 15 April 1980 00:08-EST
From: Quux <Quux at MIT-MC>
Sender: GLS at MIT-MC
Subject: Inconsistency in various DOs
To: BUG-LISP at MIT-MC, BUG-LISPM at MIT-MC
cc: JONL at MIT-MC, MOON at MIT-MC, H at MIT-MC, KMP at MIT-MC,
    HENRY at MIT-MC

    From: JONL at MIT-MC (Jon L White)
    ...
       Speaking of issues, how important a loss is it that there has to
    be a DO-NAMED?  How big a loss would it be to programmers if they
    had to type PROG-NAMED rather than PROG?  Admittedly these "named"
    constructs are crucial to interpreters and compilers, but I'd be
    curious hear what proportion of DO/PROG usages by J. Random Loser
    actually use the "named" feature.  If its extremely low (say, below 2%)
    then it would seem counter-productive to constrain the future
    language constructs just to save typeing a rare "-NAMED".  The 
    Vision people, the Constraints guys, and the ACTOR builders might
    be the logical ones to provide input here.

I propose that ALL constructs be named.  Thus one might do
	(SETQ-NAMED FOO X (CAR-NAMED BAR (IF (OR-NAMED FOO (CAR X)
						       (AND (CDR X) (RETURN-FROM FOO 3))
						       (RETURN-FROM BAR 5))
					     (RETURN-FROM-NAMED FOO FOO 6)
					     LOSER)))
Three brownie points to whoever can tell me what this means.


Date: 14 April 1980 23:57-EST
From: "Guy L. Steele, Jr." <GLS at MIT-MC>
Subject: DOTIMES or REPEAT, and old-style DO flushable?
To: BUG-LISP at MIT-MC, BUG-LISPM at MIT-MC
cc: EJS at MIT-MC, JONL at MIT-MC, H at MIT-MC, KMP at MIT-MC,
    HENRY at MIT-MC


    From: Eric J. Swenson <EJS at MIT-MC>
    I've long thought that the time had come to flush the old-style DO.  I
    don't think it presents a substantial saving of coding space, and being as
    un-general as it it, is not worth keeping.


    From: Alan Bawden <ALAN at MIT-MC>
    There is a saying about such ideas: "you're in charge!".


I observe that the lexical distance between an old- and new-style
DO is precisely six characters: "(())()":
	(DO x y z w . body) ==> (DO ((x y z)) (w) . body)
But much as I would also like to flush it, I must agree with ALAN.

Bletcherous idea:  let  (DO (NAME) ...) be the way to name a DO?

By the way, guys, I want to push again for the additional interpretation
	(DO (((var11 init11 step11) (var12 init12 step12) ...)
	     ((var21 init21 step21) ...)
	     ...
	     ((varn1 ...) ...))
	    (test ... retval)
	    . body)

where variables within each group are processed in parallel, but the groups
are processed serially.  Moreover, in the first group omitting a stepper
means don't step (as now), but in other groups means the stepper form
is the same as the init form.  This allows one to do, for example:
	(DO (((X L (CDR X)))
	     ((Y (CAR X)) (Z (CAAR X) (CDAR X))))
	    ((OR (NULL X) (EQ Z 'LOSE)) (BARF))
	    ...)
I.e. Y is always the CAR of X, and Z is a function of X also.
This is not the same as a LET in the body, as these computations
get done before the endtest is evaluated each time.

Date: 14 APR 1980 2346-EST
From: JONL at MIT-MC (Jon L White)
Subject: "Sorry, guys ..."
To: GLS at MIT-MC
CC: (BUG LISPM) at MIT-MC, (BUG LISP) at MIT-MC, H at MIT-MC

Well, poor "H" getting all that response.  Anyway, this
particlar piece of mail left one misimpression, or at least
so I think, and wonder if you concur.  The potential syntax
(DOTIMES <symbol> ...)  doesn't share the ambiguities of 
computed GOTO's, nor of the STATUS-MACRO kludge, but rather
has the same case analysis of old/new style DO.  On the
other hand, the pointer to Interlisp's RPTQ was most welcome.


Date: 14 April 1980 23:33-EST
From: "Guy L. Steele, Jr." <GLS at MIT-MC>
Subject: DOTIMES
cc: BUG-LISPM at MIT-AI, BUG-LISP at MIT-AI

    Date: 9 April 1980 13:24-EST
    From: Jack Holloway <H at MIT-AI>

    Besides the cogent argument in favor of a named DOTIMES
    (and it's too bad we can't flush old-style DO so we
    wouldn't need DO-NAMED), letting (DOTIMES X ...)
    mean (DOTIMES (G3453 X) ...) has the extremely nasty
    property that there is a context which wants a value
    in which you can only specify it by means of a variable,
    and not by an expression.  This is like the old
    computed-GO or STATUS-MACRO kludge, only backwards.
    If you really want that, why not use the InterLISP
    name RPTQ or something?  Or, (DOTIMES (IGNORE X) ...)
    isn't so bad...

Sorry, guys -- this was from me.  -- GLS


Date: 14 April 1980 13:07-EST
From: Richard L. Bryan <RLB at MIT-MC>
Subject: *CATCH vs named PROG
To: BUG-LISP at MIT-MC, BUG-LISPM at MIT-MC

One more vote for DLW's lexical catch.  Not only do we get to flame about
what to call the catch, but also about whether RETURN-FROM and friends are
still acceptable names.


Date: 12 April 1980 21:33-EST
From: Alan Bawden <ALAN at MIT-MC>
To: JONL at MIT-MC
cc: BUG-LISP at MIT-MC, BUG-LISPM at MIT-MC

    Date: 12 APR 1980 2124-EST
    From: JONL at MIT-MC (Jon L White)
    Have you forgotten how DO is generalized?  with the old-style available,
    a non-atomic first arg is *not* generalized the way you just did for
    DOTIMES.

No I have not forgotten anything.  I am not defending old-style
DO as an example of elegant syntax.  But here it is and we are stuck
with it (I confess to even using it sometimes).  This is not a reason
to implement other NEW such crocks.

Date: 12 APR 1980 2124-EST
From: JONL at MIT-MC (Jon L White)
Subject: Inconsistencies imposing constraints
To: ALAN at MIT-MC
CC: (BUG LISP) at MIT-MC, (BUG LISPM) at MIT-MC

    Date: 12 April 1980 21:11-EST
    From: Alan Bawden <ALAN at MIT-MC>
    Subject: Inconsistency in various DOs
	Date: 12 APR 1980 1819-EST
	From: JONL at MIT-MC (Jon L White)
	.  .  .     The "gain" for flushing
	old-style DO is to free up the constraints on other DOers imposed
	by the syntax which treats an atomic first "argument" as an abbreviated
	variable specification, rather than a "name" for the DO.  
    I don't see how this follows.  Given that other DOers such as DOTIMES
    are written as macros, they are free to expand into anything they
    want, their syntax is entirely up to the macro-writer.
I don't think I wrote that note in such a way to give the impression
that the constraint was due inability to code up the functionality;
rather the problem is popular attitudes as to what are consistent 
extensions, and abbreviations, for DO.  In fact, your "narrow" viewpoint
towards DOTIMES, expressed in just this very note, is such an example.
    Secondly, you are incorrect in stating that the named mumble argument
    was the only "practical point" mentioned.  (Perhaps we differ on the
    definition of "practical".)  The best argument to my mind was the
    complete lack of generality of your suggestion.  To remind you:
      (DOTIMES X ...)		;Does the thing X times BUT
      (DOTIMES (1+ X) ...)		;Doesn't do the thing X+1 times
    I think that (DOTIMES <atom> ...) should be an ERROR! (How novel!)  I
    also think that (PROG <atom> ...) should be an error, but I am too
    late for that one!  
Have you forgotten how DO is generalized?  with the old-style available,
a non-atomic first arg is *not* generalized the way you just did for
DOTIMES.


Date: 12 April 1980 21:11-EST
From: Alan Bawden <ALAN at MIT-MC>
Subject: Inconsistency in various DOs
To: JONL at MIT-MC
cc: BUG-LISP at MIT-MC, BUG-LISPM at MIT-MC

    Date: 12 APR 1980 1819-EST
    From: JONL at MIT-MC (Jon L White)

    ...

    Either you missed the first part of these communications, about syntax
    of DO and DOTIMES, or you're simply confused.  The "gain" for flushing
    old-style DO is to free up the constraints on other DOers imposed
    by the syntax which treats an atomic first "argument" as an abbreviated
    variable specification, rather than a "name" for the DO.  

I don't see how this follows.  Given that other DOers such as DOTIMES
are written as macros, they are free to expand into anything they
want, their syntax is entirely up to the macro-writer.  They can
become DO-NAMEDs or PROGs or anything you want, not just DOs. (I guess
that the name DO does imply that you can RETURN from them.) So it is
not necessary to flush old-style DO to free up anyone's constraints.
							      
							      That is,
    DOTIMES and other yet-to-be-invented DOers are constrained by popular
    opinion to interpret an atomic first arg as a "name", rather than leaving 
    that for some other operation like DOTIMES-NAMED -- that was the only 
    practical point mentioned in all the mail to my inquiry about the syntax
    (DOTIMES <symbol> ...).

First off, I don't sense the popular opinion that you speak of,
specially since the ONLY special form that has this syntax currently
is PROG!

Secondly, you are incorrect in stating that the named mumble argument
was the only "practical point" mentioned.  (Perhaps we differ on the
definition of "practical".)  The best argument to my mind was the
complete lack of generality of your suggestion.  To remind you:

  (DOTIMES X ...)		;Does the thing X times BUT

  (DOTIMES (1+ X) ...)		;Doesn't do the thing X+1 times


I think that (DOTIMES <atom> ...) should be an ERROR! (How novel!)  I
also think that (PROG <atom> ...) should be an error, but I am too
late for that one!  Why do we think that we are obliged to define
a meaning for every special case there is?

WOW!!! what an amazing amount of mail!!  For the record I vote for
DLW's suggestion of a lexical CATCH.  (Now we can flame about what to
call it!)

Date: 12 April 1980 21:08-EST
From: Daniel L. Weinreb <DLW at MIT-AI>
Subject: *CATCH vs named PROG
To: BUG-LISP at MIT-MC, BUG-LISPM at MIT-MC

For the record, I did not forget about *CATCH; I was just being
sarcastic, for which I apologize.  Yes, RWK is right, it is dynamic and
not lexical.  So let us actually introduce a new form that IS lexical,
and use IT everywhere.  The compilers would be quite capable of
producing the same code for a DO surrounded by a lexical CATCH as they
do now for DO-NAMED.  I'm not kidding; I think this is the right
solution to the problem.



Date: 12 APR 1980 2054-EST
From: KMP at MIT-MC (Kent M. Pitman)
Subject: What should we DO?
To: (BUG LISP) at MIT-MC, NIL at MIT-MC, (BUG LISPM) at MIT-MC
CC: H at MIT-MC, KMP at MIT-MC, HENRY at MIT-MC, RMS at MIT-MC
CC: MOON at MIT-MC

RMS - doing (PROG name () (DO ...)) seems rather inelegant --
 an idiom for achieving something conceptually different than what
 you were really asking for. Take for example:

   (PROG name
	 (DO
	  ... code that extends off page ...))

 you'd be forced to scan to the next page to see that name was referring
 really to the DO. This sort of reasoning is why we most of us use let rather
 than LAMBDA. So I certainly wouldn't advocate that DO-NAMED was redundant.

Moon - Clearly we aren't advocating making everything named -- just the
 constructs that do flow of control-hacking -- for such constructs need
 information about where to GO/RETURN to. Probably we need a DOTIMES that
 allows the capability and another flavor that doesn't -- ie, that becomes
 an invisible prog.

My personal feelings on this are that we should come up with consistent
rules about these things. Documentation is much simpler if you could
generalize in it. So I would prefer flushing old-DO in the longrun but
it's probably unworkable at present. There's no reason to leave ourselves
open to future problems of this sort by implementing something now without
thinking first -- which is why I advocated not allowing (DOTIMES n ...).
I was not advocating that (DOTIMES lab ...) be installed -- just allowing
for that contingency.

I now present my feelings on this issue of how DO/PROG could be done in order
this haggling, part of which I think comes out of the fact that these return
tags are tied up in PROG-ness and so on ... Suppose you had the following
primitives in Lisp:

(PROG-BODY ...) which evaluated all non-atomic stuff. Atoms were GO-tags.
 Returns () if you fall off the end. RETURN does not work from this form.

(PROG-RETURN-POINT form name) name is not evaluated. Form is evaluated and
 if a RETURN-FROM specifying name (or just a RETURN) were executed, control
 would pass to here. Returns the value of form if form returns normally or
 the value returned from it if a RETURN or RETURN-FROM is executed. [Note:
 this is not a [*]CATCH because it is lexical in nature and optimized out
 by the compiler. Also, a distinction between NAMED-PROG-RETURN-POINT
 and UNNAMED-PROG-RETURN-POINT might be desirable -- extrapolate for yourself
 how this would change things -- I'll just present the basic idea here.]

(ITERATE bindings test form1 form2 ...) like DO is now but doesn't allow
 return or goto. All forms are evaluated. GO does not work to get to any form
 in the iteration body.

So then we could just say that the definitions for PROG and DO might be
(ignore for now old-DO's -- they could, of course, be worked in if people
really wanted them but they have nothing to do with this argument) ...

 (PROG [ <tag> ] <bvl> . <body>)

  => (PROG-RETURN-POINT (LET <bvl> (PROG-BODY . <body>)) [ <tag> ])

 (DO [ <tag> ] <bind-specs> <tests> . <body>)

  => (PROG-RETURN-POINT (ITERATE <bind-specs> <tests> (PROG-BODY . <body>))
			[ <tag> ])

Other interesting combinations could be formed by those interested in them.
If these lower-level primitives were made available to the user, he needn't
feel tied to one of PROG/DO -- he can assemble an operator with the 
functionality he really wants. 

-kmp

ps - apologies for multiple copies ... i wish i knew how to make that
	not happen ...


Date: 12 APR 1980 2051-EST
From: JONL at MIT-MC (Jon L White)
Subject: "*CATCH"?
To: RWK at MIT-MC, DLW at MIT-MC
CC: (BUG LISP) at MIT-MC, (BUG LISPM) at MIT-MC

I presumed that Dan just forgot about the existence of
*CATCH in it current definition, and was trying to propose something
new.  RMS seems to have noticed this same possibililty, by suggesting
that named progs could supplant the need for anything else named.
E.g.,  (DO-NAMED GORILLA ...) ==> (PROG GORILLA () (DO ...))


Date: 12 April 1980 20:47-EST
From: Robert W. Kerns <RWK at MIT-MC>
Sender: ___126 at MIT-MC
Subject: *CATCH vs named PROG
To: BUG-LISP at MIT-MC, BUG-LISPM at MIT-MC, DLW at MIT-MC

*CATCH is not the same.  For one thing, it's dynamicly scoped, not
lexical.  This is not the semantics we're looking for.  Why not flush
RETURN and always use *CATCH/*THROW instead?  This means it must
compile to something a couple orders of magnitude slower than the
pop/jump sequence of a named prog and return.  *THROWs outside the
context where they should be allowed would find the *CATCH above them,
unlike the construct we're looking for.


Date: 12 APR 1980 2043-EST
From: DLW at MIT-AI (Daniel L. Weinreb)
Subject: DO-NAMED
To: (BUG LISP) at MIT-AI, (BUG LISPM) at MIT-AI

I have a new proposal.  In the schemes being discussed, PROG, DO,
DOTIMES and DOLIST must each exist in two forms, either with different
function names (DO versus DO-NAMED) or different syntaxes (DOTIMES
followed by a symbol versys followed by a list).  JONL correctly points
out that there may be more such special forms in the future, each of
which would have to have two versions for the same reason.

Rather than duplicating this functionality in all these forms, why
not "subroutinize out" the functionality into a new special form,
which could be called "*CATCH"; you could have merely one version
of each special form, and then put a *CATCH around it if you need
a named escape expression.  This will keep the definition of the
language simpler (by keeping down the number of special forms
or different syntaxes of special forms), and will automatically
work for any new special forms that are invented in the future without
putting constraints on their syntax.

Date: 12 APR 1980 1833-EST
From: JONL at MIT-MC (Jon L White)
Subject: Named constructs
To: MOON at MIT-MC
CC: H at MIT-MC, KMP at MIT-MC, HENRY at MIT-MC, (BUG LISPM) at MIT-MC
CC: (BUG LISP) at MIT-MC

Uh, don't these things only apply to prog-like constructs? things
with GOs and RETURNs or loops in them?


Date: 12 APR 1980 1831-EST
From: MOON at MIT-MC (David A. Moon)
Subject: Inconsistency in various DOs
To: JONL at MIT-MC
CC: H at MIT-MC, KMP at MIT-MC, HENRY at MIT-MC, (BUG LISP) at MIT-MC
CC: (BUG LISPM) at MIT-MC

If you're going to promote named DOTIMES's, you might as well promote
named CONS, named PLUS, named ADD1, etc.

Date: 12 APR 1980 1835-EST
From: RMS at MIT-AI (Richard M. Stallman)
Subject: DO-NAMED
To: (BUG LISP) at MIT-AI, (BUG LISPM) at MIT-AI

There is probably no need for DO-NAMED at all.
Putting a named PROG around the DO ought to do just as well.

Date: 12 APR 1980 1819-EST
From: JONL at MIT-MC (Jon L White)
Subject: Inconsistency in various DOs
To: MOON at MIT-MC
CC: H at MIT-MC, KMP at MIT-MC, HENRY at MIT-MC, (BUG LISP) at MIT-MC
CC: (BUG LISPM) at MIT-MC

    Date: 10 April 1980 05:17-EST
    From: David A. Moon <MOON at MIT-MC>
    Subject: Flushing old-style do
    DO (old as well as new style) is very heavily used,  and there is nothing
    to be gained by flushing the old style other than an extremely minor
    simplification of documentation.  
Either you missed the first part of these communications, about syntax
of DO and DOTIMES, or you're simply confused.  The "gain" for flushing
old-style DO is to free up the constraints on other DOers imposed
by the syntax which treats an atomic first "argument" as an abbreviated
variable specification, rather than a "name" for the DO.  That is,
DOTIMES and other yet-to-be-invented DOers are constrained by popular
opinion to interpret an atomic first arg as a "name", rather than leaving 
that for some other operation like DOTIMES-NAMED -- that was the only 
practical point mentioned in all the mail to my inquiry about the syntax
(DOTIMES <symbol> ...).
   As it happens, the LISPM blew it by not flushing old-style DO's
in the very beginning.  Since all maclisp code had to be mildly "massaged"
to get it onto LISPM, there would have been no difficulty mechanically
rewriting the old DO into the new (actually, much maclisp code needed
a ***great*** deal more massaging than just a mechanical inspection);
at runtime, a "maclisp-support" flag would permit obslete constructs
to be used.  As it also happens on LISPM, neither is there a DOTIMES-NAMED, 
nor is the syntax (DOTIMES <symbol> ...) permissible for a named DOTIMES.
Of course, this inconsistency in the current situation is preferable
to the temporary perturbation that would result from trying to flush
old-style DOs, but it's a shame to perpetuate further inconsistencies
because of a failure to see the issues clearly.
   Speaking of issues, how important a loss is it that there has to
be a DO-NAMED?  How big a loss would it be to programmers if they
had to type PROG-NAMED rather than PROG?  Admittedly these "named"
constructs are crucial to interpreters and compilers, but I'd be
curious hear what proportion of DO/PROG usages by J. Random Loser
actually use the "named" feature.  If its extremely low (say, below 2%)
then it would seem counter-productive to constrain the future
language constructs just to save typeing a rare "-NAMED".  The 
Vision people, the Constraints guys, and the ACTOR builders might
be the logical ones to provide input here.


Date: 11 APR 1980 0337-EST
From: JPG at MIT-MC (Jeffrey P. Golden)
To: JONL at MIT-MC
CC: EJS at MIT-MC, H at MIT-MC, KMP at MIT-MC, HENRY at MIT-MC
CC: (BUG LISP) at MIT-MC, (BUG LISPM) at MIT-MC

I think flushing the old-style DO would be a very foolish thing to do.
It would break lots of old code.  Who wants to have to go through old 
code converting the DOs there to new-style DOs?  (I suppose someone 
out there recommending flushing the old-style DO has an automatic 
converter to the new-style or is willing to write one?)  This is very 
different from the CATCH, THROW -> *CATCH, *THROW change because there 
every CATCH and THROW was affected, so writing an automatic converter 
was trivial.


Date: 10 APR 1980 2337-EST
From: ALAN at MIT-MC (Alan Bawden)
Subject: Flushing old-style DO.
To: EJS at MIT-MC
CC: (BUG LISP) at MIT-MC, (BUG LISPM) at MIT-MC

    Date: 10 April 1980 23:18-EST
    From: Eric J. Swenson <EJS at MIT-MC>

        Date: 10 April 1980 22:53-EST
        From: Alan Bawden <ALAN at MIT-MC>
        To:   EJS
        cc:   BUG-LISP, BUG-LISPM at MIT-AI
        Re:   Flushing old-style DO.

        There is a saying about such ideas: "you're in charge!".
    -----
    I don't understand this.  Please explain.
-----
It means that you proposed something that sounds nice but is
impossible to implement (think of all the code that uses old-style
DO!) so we put you in charge of the project confident that it will
never happen!

Date: 10 April 1980 22:53-EST
From: Alan Bawden <ALAN at MIT-MC>
Subject: Flushing old-style DO.
To: EJS at MIT-MC
cc: BUG-LISP at MIT-MC, BUG-LISPM at MIT-AI


There is a saying about such ideas: "you're in charge!".



Date: 10 April 1980 22:45-EST
From: Eric J. Swenson <EJS at MIT-MC>
Subject:  DOTIMES or REPEAT, and old-style DO flushable?
To: JONL at MIT-MC
cc: H at MIT-MC, KMP at MIT-MC, HENRY at MIT-MC, BUG-LISP at MIT-MC,
    BUG-LISPM at MIT-MC

I've long thought that the time had come to flush the old-style DO.  I
don't think it presents a substantial saving of coding space, and being as
un-general as it it, is not worth keeping.


Date: 10 APR 1980 1308-EST
From: H at MIT-AI (Jack Holloway)
Subject: DOTIMES
To: (BUG LISPM) at MIT-AI

    Date:  9 APR 1980 1324-EST
    From: H at MIT-AI (Jack Holloway)

    Besides the cogent argument in favor of a named DOTIMES
    (and it's too bad we can't flush old-style DO so we
    wouldn't need DO-NAMED), letting (DOTIMES X ...)
    mean (DOTIMES (G3453 X) ...) has the extremely nasty
    property that there is a context which wants a value
    in which you can only specify it by means of a variable,
    and not by an expression.  This is like the old
    computed-GO or STATUS-MACRO kludge, only backwards.
    If you really want that, why not use the InterLISP
    name RPTQ or something?  Or, (DOTIMES (IGNORE X) ...)
    isn't so bad...
This mail was not my fault, someone else was using my terminal.

Date: 10 APR 1980 1140-EST
From: HES at MIT-AI (Howard Shrobe)
To: (BUG LISPM) at MIT-AI

In system "26.10 Daedalus", with microcode 618, on LISP Machine Two:
In the old (current) window system there is a minor bug in (window-class :clean).
It calls tv-erase which works in terms of bits passing as arguments the window size
(i.e (- right left) (- bottom top).  However, these are in units of pixels which on
the color screen is different than bits.  The fix is to multiply (- right left) times
the number of bits per pixel for the screen belonging to that window.  Oddly, however,
tv-erase doesn't do the height (y argument) in terms of bits but in terms of pixels
so that arg shouldn't be multiplied.  The fix is in the code saved in lispm2;window.


Date: 10 APR 1980 0517-EST
From: MOON at MIT-MC (David A. Moon)
Subject: Flushing old-style do
CC: JONL at MIT-MC, H at MIT-MC, KMP at MIT-MC, HENRY at MIT-MC
CC: (BUG LISP) at MIT-MC, (BUG LISPM) at MIT-MC

DO (old as well as new style) is very heavily used, and there is nothing
to be gained by flushing the old style other than an extremely minor
simplification of documentation.  Let's concentrat on something
at least marginally worthwhile.

MOON@MIT-MC 04/10/80 05:15:15 Re: esc-F produces garbage
To: NLM at MIT-AI, (BUG LISPM) at MIT-AI
Fixed.  MMcM broke the name server by activating a subtle bug by making
the NAME program on ITS know about more than one network.  Sigh.

MOON@MIT-MC 04/10/80 04:41:55 Re: arglist
To: jerryb at MIT-AI
CC: (BUG LISPM) at MIT-MC
Read the last paragraph in the documentation in the manual for arglist.

Date:  9 APR 1980 2133-EST
From: NLM at MIT-AI (Neil L. Mayle)
To: (BUG LISPM) at MIT-AI

In system 26.3, with microcode 618, on LISP Machine Two:  
   Escape-F produces gubbish. Obscure characters are intermixed with
the real output which is not properly formatted into columns.  

Date: 9 April 1980 21:16-EST
From: Richard M. Stallman <RMS at MIT-AI>
Subject:  Old-style DO flushable?
To: HENRY at MIT-MC
cc: BUG-LISP at MIT-AI, BUG-LISPM at MIT-AI

Let's not flush old-stye DO, and let's not flush CATCH and THROW
either.  The extra functionality of new style DO and *CATCH and *THROW
is good, but we don't gain anything by forcing people to stop using
the old forms.

Date:  9 APR 1980 2033-EST
From: JERRYB at MIT-AI (Gerald R. Barber)
Subject: Correction to last message on do-named
To: (BUG LISPM) at MIT-AI

The example works interpreted but doesn't compile.

Date: 9 April 1980 20:30-EST
From: Mike McMahon <MMCM at MIT-AI>
To: JERRYB at MIT-AI
cc: BUG-LISPM at MIT-AI

    Date:  9 APR 1980 1924-EST
    From: jerryb at MIT-AI (Gerald R. Barber)
    The following works compiled but causes the compiler to error out with an
    "unseen prog label" error.

      ...
      (LET ((SI:KBD-TYI-HOOK
    	  #'(LAMBDA (C)  ....  (RETURN-FROM INSTALL-LAYOUT NIL) ....))))
        (DO-NAMED INSTALL-LAYOUT
    	      () (())
    	...)
#' really does make another function, with it's own set of PROG tags and so on.
I imagine CATCH and THROW are really what you want.

Date:  9 APR 1980 1935-EST
From: JONL at MIT-MC (Jon L White)
Subject: DOTIMES or REPEAT, and old-style DO flushable?
To: H at MIT-MC, KMP at MIT-MC, HENRY at MIT-MC
CC: (BUG LISP) at MIT-MC, (BUG LISPM) at MIT-MC

The overwhelming response is to keep DOTIMES in the flavour of
a "DO" rather than a "REPEAT";  that is, the argument against
extending is based on the premise that there will have to be
"named" capability for DOTIMES.  
    Date: 8 April 1980 22:40-EST
    From: Kent M. Pitman <KMP at MIT-MC>
    Subject:  DOTIMES
    .  .  .  we should consider 
    the case of named DOTIMES's -- this syntax would meet with 
    later problems if we decided we wanted something like that.
But at least some, myself included, feel the need for a very 
simple REPEAT syntax
    Date: 8 April 1980 22:12-EST
    From: Henry Lieberman <HENRY at MIT-AI>
    Subject: DOTIMES
    Instead, I propose REPEAT for this:
     (REPEAT (NUMBER-OF-TIMES) ...)
    This kind of repetition is so common 
    its worth having a clear syntax for it.
and 
Date: 9 April 1980 13:24-EST
    From: Jack Holloway <H at MIT-AI>
    Subject: DOTIMES
    .  .  .
    (and it's too bad we can't flush old-style DO so we
    wouldn't need DO-NAMED)  .  .  .
    If you really want that, why not use the InterLISP name RPTQ 
    or something?  Or, (DOTIMES (IGNORE X) ...) isn't so bad...
But since we're talking about it, has anyone given thought recently
to actually flushing the old-style DO syntax?  It certainly becomes
less useful if you have DOTIMES and a REPEAT as mentioned above.
The maclisp world is under one edict to flush old styles: on 
Sept 17, 1978  we introduced *CATCH and *THROW and announced the 
impending collapse of maclisp CATCH and THROW.  Is it time to
introduce RPTQ (or REPEAT) and take aim at old-style DO?


Date:  9 APR 1980 1924-EST
From: jerryb at MIT-AI (Gerald R. Barber)
To: (BUG LISPM) at MIT-AI

In system 27.1, with microcode 635, on LISP Machine One:

The following works compiled but causes the compiler to error out with an
"unseen prog label" error.

  ...
  (LET ((SI:KBD-TYI-HOOK
	  #'(LAMBDA (C)  ....  (RETURN-FROM INSTALL-LAYOUT NIL) ....))))
    (DO-NAMED INSTALL-LAYOUT
	      () (())
	...)



Date:  9 APR 1980 1917-EST
From: jerryb at MIT-AI (Gerald R. Barber)
To: (BUG LISPM) at MIT-AI

In system 27.1, with microcode 635, on LISP Machine One:

(arglist 'foo) where foo defined by

(defun foo (&aux a b c)
	...)

returns (&aux a b c) if foo is interpreted and nil if foo is compiled.
Locals shouldn't really be part of the arglist.

This screws things up when you try to decide wheather to funcall a function
with arguments based on what is returned by arglist.  It would be nice if
when a function didn't take arguments arglist would return nil so you wouldn't
have to try and understand what arglist returned.


Date:  9 APR 1980 1324-EST
From: H at MIT-AI (Jack Holloway)
Subject: DOTIMES
To: (BUG LISPM) at MIT-AI, (BUG LISP) at MIT-AI

Besides the cogent argument in favor of a named DOTIMES
(and it's too bad we can't flush old-style DO so we
wouldn't need DO-NAMED), letting (DOTIMES X ...)
mean (DOTIMES (G3453 X) ...) has the extremely nasty
property that there is a context which wants a value
in which you can only specify it by means of a variable,
and not by an expression.  This is like the old
computed-GO or STATUS-MACRO kludge, only backwards.
If you really want that, why not use the InterLISP
name RPTQ or something?  Or, (DOTIMES (IGNORE X) ...)
isn't so bad...

MOON@MIT-MC 04/09/80 02:58:47 Re: ~<CR> in FORMAT
To: GLS at MIT-AI, (BUG LISPM) at MIT-AI, HIC at MIT-AI, ALAN at MIT-AI
To: KMP at MIT-AI, GSB at MIT-AI, MOON at MIT-AI
    Date:  8 APR 1980 1640-EST
    From: GLS at MIT-AI (Guy L. Steele, Jr.)

    I recommend that ~<cr> mean "ignore the <cr> and all following whitespace".
    Let the : modifier mean "but retain the whitespace" and @ mean
    "but retain the <cr>".  Thus ~:@<cr> is the same as a bare <cr>.
I made this change in the source and documentation, for the Lisp machine.
Fixed a slight bug or two while I was at it.

Date: 8 April 1980 22:40-EST
From: Kent M. Pitman <KMP at MIT-MC>
Subject:  DOTIMES
To: JONL at MIT-MC
cc: BUG-LISPM at MIT-MC, BUG-LISP at MIT-MC

    Date: 8 April 1980 18:01-EST
    From: Jon L White <JONL at MIT-MC>
    To:   BUG-LISP
    cc:   BUG-LISPM
    Re:   DOTIMES

    Would anyone object if the syntax (DOTIMES <atom> (...)) ...
-----
Just for the record, having already talked to you on this, we should consider
the case of named DOTIMES's -- this syntax would meet with later problems
if we decided we wanted something like that.
-kmp


Date:  8 APR 1980 2212-EST
From: HENRY at MIT-AI (Henry Lieberman)
Subject: DOTIMES
To: (BUG LISPM) at MIT-AI, JONL at MIT-MC

Moon's comment on JONL's proposal for DOTIMES is a valid point.
Instead, I propose REPEAT for this:
 (REPEAT (NUMBER-OF-TIMES) ...)
so that an expression works.
This kind of repetition is so common 
its worth having a clear syntax for it.

MOON@MIT-MC 04/08/80 17:56:10 Re: DOTIMES
To: JONL at MIT-MC
CC: (BUG LISPM) at MIT-MC, NIL-I at MIT-MC
    JONL@MIT-MC 04/08/80 17:46:39 Re: DOTIMES
    To: MOON at MIT-MC
    CC: (BUG LISPM) at MIT-MC
    Sorry for typo - msg meant to say
    "Why doesn't the LISPM version  of DOTIMES support the syntax
       (DOTIMES 4 (MUMBLE))
    which should act like
       (DOTIMES (G0025 4) (MUMBLE))
Because said syntax is a crock.  It doesn't work to substitute an
expression for "4", which I don't think is an acceptable limitation,
considering how little it buys you.
Furthermore this syntax has never before been discussed (to my
knowledge anyway.)  I think we can safely shelve this one with the
other bad ideas.

Date:  8 APR 1980 1801-EST
From: JONL at MIT-MC (Jon L White)
Subject: DOTIMES
To: (BUG LISP) at MIT-MC
CC: (BUG LISPM) at MIT-MC

Would anyone object if the syntax
  (DOTIMES <atom> (...))
were permissible, to mean
  (DOTIMES (G0012 <atom>) (...))
where G0012 is a random gensym.


JONL@MIT-MC 04/08/80 17:46:39 Re: DOTIMES
To: MOON at MIT-MC
CC: (BUG LISPM) at MIT-MC
Sorry for typo - msg meant to say
"Why doesn't the LISPM version  of DOTIMES support the syntax
   (DOTIMES 4 (MUMBLE))
which should act like
   (DOTIMES (G0025 4) (MUMBLE))


MOON@MIT-MC 04/08/80 17:38:05
To: JONL at MIT-MC
CC: (BUG LISPM) at MIT-MC
    JONL@MIT-MC 04/07/80 23:52:27
    To: NIL-I at MIT-MC
    CC: (BUG LISPM) at MIT-MC
    I just fixed a fence-post bug in maclisp's DOTIMES,
    and also have it correctly inserting DECLARE's for the
    loop variable.  Question:  why doesn't the LISPM version
    support the syntax  (DO 4 (MUMBLE-4-TIMES)) ?

Eh?  Please correct typos and resend.

Date:  8 APR 1980 1640-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
Sent-by: BKERNS at MIT-AI
Subject: ~<CR>
To: (BUG LISPM) at MIT-AI, HIC at MIT-AI, ALAN at MIT-AI, KMP at MIT-AI
To: GSB at MIT-AI, MOON at MIT-AI
CC: GLS at MIT-AI

I recommend that ~<cr> mean "ignore the <cr> and all following whitespace".
Let the : modifier mean "but retain the whitespace" and @ mean
"but retain the <cr>".  Thus ~:@<cr> is the same as a bare <cr>.
The point is that the commonest case is easiest to type, and
the next most common cases easier to type than the useless case.

JONL@MIT-MC 04/07/80 23:52:27
To: NIL-I at MIT-MC
CC: (BUG LISPM) at MIT-MC
I just fixed a fence-post bug in maclisp's DOTIMES,
and also have it correctly inserting DECLARE's for the
loop variable.  Question:  why doesn't the LISPM version
support the syntax  (DO 4 (MUMBLE-4-TIMES)) ?


MOON@MIT-MC 04/07/80 08:32:53
To: LPD at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date:  6 APR 1980 2015-EST
    From: LPD at MIT-AI (L. Peter Deutsch)
    To: (BUG LISPM) at MIT-AI

    In system 26.3, with microcode 618, on LISP Machine Two:
    Not only won't TRACE trace macros (which I agree with GLS is a dead loss),
    it won't trace DTP-SELECT-METHODs either!  At least it tells you....

TRACE can actually only trace symbols.  It traces macros
(symbols whose function definitions are macros) in the latest system,
probably not installed yet.  I have fixed (in the source) the brain-bubble
that caused it not to be able to trace symbols whose function definitions
are random types of functions such as dtp-select-method (it was written
years before there was such a thing as dtp-select-method).

It is, perhaps, a microcode bug that %args-info of a dtp-select-method returns
with the %%arg-desc-interpreted bit on.

MOON@MIT-MC 04/07/80 08:14:22 Re: Suppressing carriage returns in FORMAT
CC: (BUG LISPM) at MIT-MC, GLS at MIT-MC, HIC at MIT-MC, ALAN at MIT-MC
CC: KMP at MIT-MC, GSB at MIT-ML
tilde-carriage-return suppressing the carriage return has been installed in
Lisp-machine FORMAT for a week or so.  If there is sentiment in favor, we can
define it to ignore whitespace after the carriage return also (you can use ~X
to put it in, or ~0X to provide a separator, or only ~: carriage return could
ignore it or not ignore it.)

Date:  6 APR 1980 2015-EST
From: LPD at MIT-AI (L. Peter Deutsch)
To: (BUG LISPM) at MIT-AI

In system 26.3, with microcode 618, on LISP Machine Two:
Not only won't TRACE trace macros (which I agree with GLS is a dead loss),
it won't trace DTP-SELECT-METHODs either!  At least it tells you....


Date:  6 APR 1980 1638-EST
From: LPD at MIT-AI (L. Peter Deutsch)
To: (BUG LISPM) at MIT-AI

In system 26.3, with microcode 618, on LISP Machine Two:
If I am in an error break and I call (mexp), the keyboard goes dead -- nothing
echoes, c-z and c-g don't work.  The only way I know to get out is to hit call.


Date:  6 April 1980 15:38-EST
From: Gerald R. Barber <JERRYB at MIT-AI>
To: CWH at MIT-MC
cc: BUG-LISPM at MIT-MC

    Date: 6 April 1980 11:23-EST
    From: Carl W. Hoffman <CWH at MIT-MC>
    To:   BUG-LISPM at MIT-MC

        HENRY@MIT-AI 04/05/80 23:09:23 Re:  CAR and CDR should send messages
		...
        A user program wouldn't
        have to know what kind of list it was dealing with, it
        could just take CAR and CDR.

    This is what I said in my original message.
    I think this is very poor.

    There are all sorts of objects which may be chained together in a list-like
    structure, many of which are more complicated than just a cons.  Consider,
    for instance, the linking of free chaosnet packets, or the editor's line
    objects.  Using CAR and CDR to manipulate these lists would be extremely
    confusing.  Higher level naming conventions are used.

This just argues for higher level abstractions.  No one will disagree with you
on that account.

    My other objection to this proposal deals with syntax.  As long as this
    language includes both functional and message passing semantics, there
    should be some clear way to distinguish between the two.

Why?  You are requiring that the user program know the underlying
representation of the objects it is dealing with.  This is poor.  As long as
they behave as they should, eg, a car and cdr receiving object behaves like an
ordinary cons, then there is no need for this restriction.

    ...
    Finally, you should consider transportability.  This is almost impossible to
    implement in a system without microcoded CAR, whereas (<- X ':CAR), or
    better (<- X ':FIRST), is much easier.

CAR is already too smart for non-microcodeable machines.



Date: 6 April 1980 11:23-EST
From: Carl W. Hoffman <CWH at MIT-MC>
To: BUG-LISPM at MIT-MC

    HENRY@MIT-AI 04/05/80 23:09:23 Re:  CAR and CDR should send messages
    It's to allow eventual implementation of actors.
    There may want to be user-defined actors which 
    respond specially to CAR and CDR. An example of
    where this would be useful would be in implementing
    a new kind of list which would compute its elements
    incrementally, only when the next element was requested
    (generator or coroutine style). A user program wouldn't
    have to know what kind of list it was dealing with, it
    could just take CAR and CDR.

This is what I said in my original message.
I think this is very poor.

There are all sorts of objects which may be chained together in a list-like
structure, many of which are more complicated than just a cons.  Consider,
for instance, the linking of free chaosnet packets, or the editor's line
objects.  Using CAR and CDR to manipulate these lists would be extremely
confusing.  Higher level naming conventions are used.

My other objection to this proposal deals with syntax.  As long as this
language includes both functional and message passing semantics, there
should be some clear way to distinguish between the two.  And the notation
used for sending messages should be uniform.  If you were writing
(<- X ':CAR), I would object less strongly.  But if you want (CAR X) to send
a message, then all forms which send messages should be written with the
message as the first element of the form.  And messages would have to be
declared appropriately so that the compiler (and people) could distinguish
between the two.

Finally, you should consider transportability.  This is almost impossible to
implement in a system without microcoded CAR, whereas (<- X ':CAR), or
better (<- X ':FIRST), is much easier.


Date:  6 APR 1980 0008-EST
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

It makes sense to forbid CAR or CDR of an ENTITY, but the same reasons
don't apply to ordinary closures.  That's what the distinction is for.
If there is no need for the distinction, then we should reclaim one of
the two data types.

Date:  5 April 1980 20:34-EST
From: Jeffrey I. Schiller <JIS at MIT-AI>
Subject: Not having CAR and CDR send messages to entities
To: cwh at MIT-MC
cc: BUG-LISPM at MIT-AI

Lose! not only should CAR and CDR when applied to an entity or instance
send a message to that object, but most of the micro-coded functions of 
the lisp machine should also as well (which is what this change is
probably gearing up for...) Entities would serve ideally as a way
to implement abstract data types that my be somewhat like lists and
thus the car and cdr operations would be meaningful. (maybe I want
to make an abstract CONS that also has some other information stashed
away in it like the number of times its cdr was taken so that statistics
for a data base using CONS's could be gathered by inserting these psuedo
CONS's just for experimental runs.) This may be a bad example because it
is just off the top of my head, but the possibilities are limitless. I would
hat to think that this ability be missing because someone (like yourself)
hasn't thought through the possibilities but instead dismissed the whole
idea as "something to be discouraged."

[END OF FLAME]

			-Jeff

Date:  5 April 1980 19:37-EST
From: Carl W. Hoffman <CWH at MIT-MC>
To: BUG-LISPM at MIT-MC

    Date:  5 APR 1980 0414-EST
    From: RG at MIT-AI (Richard Greenblatt)

    (1) ...  Eventually, it will send a message to an ENTITY or INSTANCE
        if CAR or CDR of it is taken.

Why are you bothering with this?  I don't see how CAR or CDR can be thought
of as generic operations.  I view them as primitives for manipulating
conses, and nothing more.  Alternate primitives should be created for
indirection through locatives, etc.

The only way such a feature would be useful would be in using code written in
terms of CAR and CDR to manipulate objects which are structurally similar to
lists.  I think this is something to be discouraged.


Date:  5 APR 1980 1304-EST
From: HES at MIT-AI (Howard Shrobe)
To: (BUG LISPM) at MIT-AI

In system "26.3", with microcode 618, on LISP Machine Two:
There is a bug in default-mouse-handler (in lispm2;mouse) which causes a minor problem
when using both a color and a black and white screen.

The problem is that when clipping the mouse position to the size of the screen local
variables max-x and max-y are used to keep the size of the screen.  However, the screen
which the mouse is on can change during while the function is running.  The fix is
simply to keep fetching the screen-x2 and screen-y2 of mouse-screen.  I have patched and
saved the code.



Date:  5 APR 1980 0414-EST
From: RG at MIT-AI (Richard Greenblatt)
To: INFO-LISPM at MIT-AI

  27 series cold loads are making their appearance.  Two important things
to note:
  (1)  CAR or CDR of a CLOSURE, ENTITY or INSTANCE is an error.  Do a
     (%MAKE-POINTER DTP-LIST xx) if you want the function part.  Eventually,
     it will send a message to an ENTITY or INSTANCE if CAR or CDR of it is
     taken.
  (2)  When using the console program CC to look at a core image of a 27 or higher
     cold load, be sure you have the latest version of QF.  (The simplest way
     to be sure of this is to be using a 27 or higher system to do the CC).
     This is because a microcode change affects the procedure for
     determining where the swapping partition is.  If you use an old CC,
     you could clobber the disk!!

  Version 27 has JERRYB's ESCAPE package by default.  Most other changes
are bug fixes or hooks for the microcompiler.

Date:  5 APR 1980 0148-EST
From: jerryb at MIT-AI (Gerald R. Barber)
To: (BUG LISPM) at MIT-AI

In system 27.0, with microcode 635, on LISP Machine One:

If a process is in error (eh) selects it but seems to loop
infinitely.


Date:  4 APR 1980 1814-EST
From: MMCM at MIT-AI (Mike McMahon)
Sent-by: jerryb at MIT-AI
To: (BUG LISPM) at MIT-AI

In system 27.0, with microcode 635, on LISP Machine One:

Apparently someone changed it so that you can no longer perform arbitrary list
functions, like CADR on closures without checking all the system code that did
this.  This breaks the editor in several places.

Date:  4 APR 1980 0454-EST
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

ECC's experience suggets that, just as incandescent bulbs are
stressed especially much when they are turned on,
CPT monitors receive a high stress from the click that
accompanies booting.  Eliminating the click might be the most
important way to extend the life of the CPT.  Even if it
requires some hardware modification, it might be worth while.
Is the click entirely the result of reloading the sync roms?

Date:  4 APR 1980 0447-EST
From: ECC at MIT-AI (Eugene C. Ciccarelli)
To: (BUG LISPM) at MIT-AI

The CPT monitor in 902 on not-CADR-3 may have just
fried -- it went overly bright suddenly after cold-booting, and while
we were figuring what to do and were about to turn off the power
supply, it went off itself and wouldn't come back.

Date:  3 APR 1980 1032-EST
From: CWH at MIT-AI (Carl W. Hoffman)
To: (BUG LISPM) at MIT-AI

The feature of LOAD-FILE-ALIST-MAP which checks if a file is already
loaded before reloading should be accessible at the per-file level, e.g.
via LOAD.  It would also be nice if LOAD-FILE-ALIST were keyword driven. 


Date:  3 APR 1980 0739-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
Subject: Tracing macros
To: MOON at MIT-MC
CC: GLS at MIT-AI, (BUG LISPM) at MIT-AI

    MOON@MIT-MC 04/02/80 23:27:19 Re: Tracing macros
    Well, it isn't brain damaged, it just didn't have any code to do it.
    I have fixed it in the source, however it may or may not do what you want;
    you have to be aware that most macros in the Lisp machine are displacing,
    so the macro will only get traced when it really is expanded (the first time).

Well, sorry for the flaming, but I wasted a great deal of time on it.
The brain damage is not that it can't handle them (though that fact
is very annoying, as MacLISP has long handled that case); it is that
it makes you think it has won when it hasn't.  If it can't handle macros,
it should at least say "Barf! I can't trace a macro!", not just blithely
do something which not only doesn't trace but breaks the code which calls
the macro.
As for displacing, maybe that bad interaction could be fixed.  Either DISPLACE
could know about tracing (after all, GRINDEF does too), or TRACE could
maybe fake out the displacer by handing the real macro a copy of the
list cell which is the macro call.

MOON@MIT-MC 04/02/80 23:27:19 Re: Tracing macros
To: GLS at MIT-AI
CC: (BUG LISPM) at MIT-MC
Well, it isn't brain damaged, it just didn't have any code to do it.
I have fixed it in the source, however it may or may not do what you want;
you have to be aware that most macros in the Lisp machine are displacing,
so the macro will only get traced when it really is expanded (the first time).


MOON@MIT-MC 04/02/80 22:35:33
To: CWH at MIT-MC
CC: (BUG LISPM) at MIT-MC
    CWH@MIT-MC 04/01/80 17:06:11
    To: (BUG LISPM) at MIT-MC
    Interrupt a process with ESC B, and then type C-L.  The message displayed
    is "No error message for this error".  It should print something more
    informative, and mention that C-C is the way to continue.

c-C is always the way to continue.  I have fixed the random error message
(and sometimes error in the error handler), but only in the new-window-system
version of the error handler; it was caused by things being modularized wrong.

Date:  2 APR 1980 1724-EST
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

On cadr 6, while SUPDUPing, I often hit NETWORK instead of TAB.
This causes an error.

MOON@MIT-MC 04/02/80 15:45:33 Re: Proposed incompatible change to LISTP
To: (BUG lispm) at MIT-AI
I think we accidentally gave LISTP the wrong definition back when.
Currently (LISTP x) = (NOT (NLISTP x)) and (NLISTP x) = (ATOM x).
I would like to define (LISTP x) = (OR (NULL x) (NOT (ATOM x))) and
get rid of NLISTP entirely.  Thus LISTP (NLISTP) will never be the way
to terminate an iteration, rather it is the way to test if something
is a list of 0 or more elements.  The preferred way to terminate
an iteration will be NULL in most cases, or ATOM when it would be
reasonable not to consider a dotted list to be an error.  (If anyone
wants to push for ATOM to always be the preferred way to terminate
an iteration, speak now.  Currently it does not generate as good code,
but that would not be terribly difficult to change.  I might even
be wrong about that.)

The NIL people are muttering about "CONSP" and "PAIRP", but I don't
see any advantage of those over ATOM, unless one has hunks, which we
will never have.  If necessary we can define one or both of those
functions for compatibility, but I am not proposing to do so now.

If there are no demurrers in the next couple days, I will announce this
to users and remove all usage of LISTP and NLISTP in the system source,
preparatory to making the incompatible change.  Compiled code that calls
those functions will continue to work since they are open-coded.

CWH@MIT-MC 04/01/80 17:06:11
To: (BUG LISPM) at MIT-MC
Interrupt a process with ESC B, and then type C-L.  The message displayed
is "No error message for this error".  It should print something more
informative, and mention that C-C is the way to continue.


Date:  1 April 1980 14:54-EST
From: Mike McMahon <MMCM at MIT-AI>
To: LPD at MIT-AI
cc: BUG-LISPM at MIT-AI

    Date:  1 APR 1980 1431-EST
    From: LPD at MIT-AI (L. Peter Deutsch)
    If the regular pushdown list overflows and I type ctrl-z to get back to the
    top level, the machine goes into an (apparently) infinite loop.
The C-Z command in the error handler tries to execute a throw to top level
within the overflown stack group, which cannot work.  I'm afraid handling of
pushdown overflows is pretty poor: it is assuredly on the list of things to get
done.

Date:  1 APR 1980 1431-EST
From: LPD at MIT-AI (L. Peter Deutsch)
To: (BUG LISPM) at MIT-AI

In system 26.3, with microcode 616, on LISP Machine One:
If the regular pushdown list overflows and I type ctrl-z to get back to the
top level, the machine goes into an (apparently) infinite loop.


Date:  1 APR 1980 1234-EST
From: LPD at MIT-AI (L. Peter Deutsch)
To: (BUG LISPM) at MIT-AI

In system 26.3, with microcode 616, on LISP Machine One:
The Compile File command in the editor, unlike Evaluate Buffer and Compile Buffer,
doesn't actually install things like macro definitions in any place that they can
be used later.  Thus, for example, if I have a macro definition (or a defun
enclosed in (eval-when (compile) ...)), I can't use that macro or function as part
of the computation in another macro.  Here's the example that blasted it out:
	(defmacro pack-intern args
	  `(intern-local (make-symbol (string-append ,@args))))

	(defmacro foo (fn . stuff)
	  (let ((name (pack-intern fn "-" (gensym))))
	    ...))
When the compiler tries to macro-expand a call of foo, pack-intern isn't defined
(for Compile File only).

Apparently if I want this to work I have to evaluate or compile the file once before
I do the Compile File.  This doesn't seem reasonable to me.


Date:  1 APR 1980 0619-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

In system 26.3, with microcode 618, on LISP Machine Two:

!!!!!!!!!!!!!INCREDIBLE SCREW INFINITE!!!!!!!!!!!!!!!!

It doesn't work to trace a macro!!!  How brain-damaged!!!


Date: 31 MAR 1980 1217-EST
From: JERRYB at MIT-AI (Gerald R. Barber)
To: (BUG LISPM) at MIT-AI


Things that run in the background, such as TV-XGP-HARDCOPY, lose becuase they
compete with other processes.  The right behavior should be that they only run
when no non-background process need the processor.  I suggest we distinguish
between background and non-background processes and run background processes
when the foreground activity has been quiescent for a period of time, maybe a
couple seconds (to keep the paging down).

Thus background processing would get done if the user had nothing to do while
it would stop as soon as he did have something to do giving him the full
processor. 

MOON@MIT-MC 03/30/80 00:25:16
To: CWH at MIT-MC
CC: (BUG LISPM) at MIT-MC
    CWH@MIT-MC 03/28/80 21:26:30
    To: (BUG LISPM) at MIT-MC
    (format t "~:[a~;b" t) gets an error while trying to print
    the message that the closing ~] is missing.

Fixed.

Date: 29 MAR 1980 2352-EST
From: MOON at MIT-MC (David A. Moon)
Subject: NAME server on lisp machines
To: MT at MIT-XX
CC: (BUG LISPM) at MIT-MC

    Date: 29 Mar 1980 0231-EST
    From: Michael Travers <MT at MIT-XX>
    Subject: NAME server on lisp machines
    To: (BUG LISPM) at MIT-AI

    It doesn't close its connection properly (appears to never send EOF).
    -------
This does not appear to be true.  Are you sure?  The code waits for all
packets to be acknowledged, sends an eof, waits for that to be acknowledged,
then closes.  Of course I don't know if there are old versions floating around
that are different.  Also it might be broken, because someone (I hope it wasn't
me!) vandalized the code to run in the Chaosnet-background process, which means
that it would not get any retransmission.  I've fixed that in the source.

You probably really want to use the FINGER server, not the NAME server,
as it uses a simple-transaction rather than a full byte-stream connection.

Date: 29 March 1980 12:54-EST
From: Howard I. Cannon <HIC at MIT-MC>
To: JLK at MIT-AI
cc: BUG-LISPM at MIT-AI

The bug with not being able to type call is undoutbedly
that you had previosly typed a character.  Processes cannot
go blockeddwith shceduling inhibited without causing an error.
The new window system fixes this.


Date: 29 MAR 1980 0943-EST
From: JLK at MIT-AI (John L. Kulp)
To: (BUG LISPM) at MIT-AI

In system 26.4, with microcode 616, on LISP Machine Seven:

I got hung in NETO when trying to write out my edit buffer to MC, MC died in the
middle, and the machine sat in NETO for about 20 secs, so I tried to CALL out
of it (with sequence breaks on for clock and keyboard), and I couldn't,
so I presume interrupts were somehow locked out.  I assume it was an oversight
that interrupts managed to get locked out for such long periods of time.  This
should be fixed.


Date: 29 MAR 1980 0854-EST
From: RSG at MIT-AI (Robert S. Giansiracusa)
To: (BUG LISPM) at MIT-AI

On CADR-1 (though it has happened on all others I have used also), system 26.3,
microcode 616:  I was using (ED <filename>) in an INIT file to preload the editor.
Sometimes it works, but about 70% of the time it loads about half of my files and
then craps out with the message
>>TRAP 6062 (TRANS-TRAP)
The function NIL is undefined.
While in the function ZWEI:ZED-INTERNAL-G4983 <- PROCESS-WAIT <- ZED

ZWEI:ZED-INTERNAL-G4983:
  Arg 0 (OLD-WINDOW): NIL


Date: 29 Mar 1980 0231-EST
From: Michael Travers <MT at MIT-XX>
Subject: NAME server on lisp machines
To: (BUG LISPM) at MIT-AI

It doesn't close its connection properly (appears to never send EOF).
-------

Date: 29 MAR 1980 0015-EST
From: Moon at MIT-AI (David A. Moon)
Subject: CADR-7 parity errors
To: INFO-LISPM at MIT-AI

If there are any parity errors on CADR-7 after the date of this message,
I want to know about them.  The two memories currently plugged in to that
machine (#13 and #19) contain an experimental modification.  Please send
me mail if you get any main memory parity errors.

Date: 28 MAR 1980 2256-EST
From: LPD at MIT-AI (L. Peter Deutsch)
To: (BUG LISPM) at MIT-AI

In system 26.3, with microcode 618, on LISP Machine Two:
I tried to generate some objects of type DTP-SELECT-METHOD by using code similar
to that in DEFSELECT.  Everything worked fine, except that if none of the keys
matched, rather than calling the function whose FEF pointer was (cdr (last object)),
I got an error "Wrong argument type for APPLY, it expected a CONS" with the
offender being (cdr (last object)).  The only difference I could find between what
I do and what DEFSELECT does is that DEFSELECT does a defun and puts a symbol
at the end of the list, whereas I put an actual FEF pointer.  Normally apply
is happy with a FEF pointer as its first argument: is the situation different
in this case?  If so, I would consider it a bug.


Date: 28 MAR 1980 2137-EST
From: LPD at MIT-AI (L. Peter Deutsch)
To: (BUG LISPM) at MIT-AI

In system 26.3, with microcode 618, on LISP Machine Two:
(last '(a b c . d)) properly returns '(c . d), but
(butlast '(a b c . d)) blows up trying to take car of 'd.


CWH@MIT-MC 03/28/80 21:26:30
To: (BUG LISPM) at MIT-MC
(format t "~:[a~;b" t) gets an error while trying to print
the message that the closing ~] is missing.


Date: 28 MAR 1980 2109-EST
From: LPD at MIT-AI (L. Peter Deutsch)
To: (BUG LISPM) at MIT-AI

In system 26.3, with microcode 618, on LISP Machine Two:
The construct (function (named-lambda foo (arg) forms)) works properly interpreted
(i.e. shows up with the name foo on the backtrace), but if I say
   (defun fie () (function (named-lambda foo (arg) forms)))
and compile fie, the function actually gets named something like fie-internal-g0099.
At least this is what shows up on the backtrace if there is an error during the
execution of forms.  (On the other hand, I think I've also had it work correctly.
Not really sure what is going on here.)


Date: 28 MAR 1980 1943-EST
From: MOON at MIT-AI (David A. Moon)
To: (BUG LISPM) at MIT-AI

Whoever implemented (status userid) and (status tabsize)
didn't have their wits about them.

MOON@MIT-MC 03/28/80 17:45:25 Re: Compiler temporary area problem
To: LPD at MIT-AI
CC: (BUG LISPM) at MIT-MC
Your diagnosis is probably correct.  Unfortunately this can't be fixed
until the long awaited new garbage collector is finished, which may not
be soon.  However, in the interim things are supposed to be done in such
a way that most reasonably written macros can't lose.  Could you please
mail me a pointer to your code so I can look at it?  It may be that it
is reasonable and points up a bug someplace.

Date: 28 MAR 1980 1714-EST
From: LPD at MIT-AI (L. Peter Deutsch)
Subject:  Meta-.
To: (BUG LISPM) at MIT-AI

Fairly often (maybe one time out of 4) meta-. simply goes off the deep end --
at least, it computes for several minutes and I lose patience.  This has
happened both with system functions and my own.


Date: 28 MAR 1980 1709-EST
From: LPD at MIT-AI (L. Peter Deutsch)
Subject: Compiler problem
To: (BUG LISPM) at MIT-AI

I had a mysterious problem in which a string constant computed by
string-append during macro expansion was getting smashed in the
eventual compiled code.  I believe the cause is that the compiler
rebinds the default working area, and the string is getting put
there and not copied.  This loses because the compiler's working
area gets zapped at every compilation.  The problem probably doesn't
show up when compiling to a QFASL file, since the string gets
written out before it gets smashed, but in my situation I was using
control-top-C to compile into memory.

I can fix this with a relatively minor change in my code, in this
particular case, but if this is really the cause of the problem,
it obviously has the potential for causing many subtle difficulties
in the future.

Date: 28 MAR 1980 0206-EST
From: gls at MIT-AI (Guy L. Steele, Jr.)
Sent-by: ___065 at MIT-AI
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

With regard to RMS's note on lisng when AI went down, note
that I too recently (a month or two ago) went through
exactly the same process, having to disassemble a half
dozen functions before discovering SI:FILE-DEFAULT-HOST.
SO, grumble.  Hope it gets fixed soon.

Date: 27 MAR 1980 0443-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
Subject: LSUBR GET
To: (BUG LISP) at MIT-AI, (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI, GJS at MIT-AI

I was about .9 serious about my propsoed LSUBR GET.  However, that proposal
is in conflict with another for (GET sym propname [defaultval]), which
I also support.  Maybe the LSUBR GET could be called GET* ?  Or maybe
just not implemented?  Oh well.  LSUBR GET is easily coded as a macro;
the defaulted GET less so, and probably more useful.

Date: 27 MAR 1980 0254-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
Subject: LSUBR GET
To: (BUG LISP) at MIT-AI, (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI, GJS at MIT-AI

Boy, would it be neat in certain kinds of programming for
GET to be an LSUBR!  (GET x p1 p2 p3 ... pn) =>
(GET ... (GET (GET (GET x p1) p2) p3) ... pn)
Great for super property-list hackers (like GJS).

MOON@MIT-MC 03/27/80 00:59:41 Re: ash
To: SHIPMN at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date: 26 MAR 1980 2207-EST
    From: SHIPMN at MIT-AI (David W. Shipman)
    To: (BUG LISPM) at MIT-AI

    ASH doesn't always work. For example, (ash (ash -3 9.) -9.) returns -1;
    although (ash (ash -3 8.) -8.) correctly returns -3.
This brain-bubble is fixed in UCADR 630, which probably works well enough
that you could use it if you really care about this.  Bug happens for
any negative number shifted left by more than 8.

Date: 26 MAR 1980 2207-EST
From: SHIPMN at MIT-AI (David W. Shipman)
To: (BUG LISPM) at MIT-AI

ASH doesn't always work. For example, (ash (ash -3 9.) -9.) returns -1;
although (ash (ash -3 8.) -8.) correctly returns -3.

Date: 26 MAR 1980 0408-EST
From: MOON5 at MIT-AI (David A. Moon)
To: (BUG LISPM) at MIT-AI

I would be interested to know who deleted the version of LMIO;CHSTBL
that had phone numbers for the machines in the EECS machine room.  It wasn't
edited out, the file version was deleted.

Date: 25 MAR 1980 1911-EST
From: Moon at MIT-AI (David A. Moon)
To: (BUG LISPM) at MIT-AI

I got rid of "user .LSPM_" files (which were loaded when you logged out)
because they cause problems if the machine you were logged in to has gone
down, no one uses them, and they are useless, since you can put arbitrary
forms to be evaluated onto LOGOUT-LIST.

MOON@MIT-MC 03/25/80 19:00:45
To: JERRYB at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date: 25 MAR 1980 1442-EST
    From: JERRYB at MIT-AI (Gerald R. Barber)
    To: (BUG LISPM) at MIT-AI

    In system 26.3, with microcode 618, on LISP Machine Six:

    Typing the following after a cold bood:

    (si:sb-on 'chaos)
    (chaos:connect 'cadr6 "eval")

    returns the string:

    "Bad state: LOS-RECEIVED-STATE, Con ection not ope:"
I have fixed (in the source) the two bugs that caused this plus about half
a dozen more that showed up in the process.  Thanks for the information.
Note: the network isn't clobbering packets, it's just that the routine
for copying an error message into a LOS packet was written wrong and
has never worked.

Date: 25 March 1980 15:03-EST
From: Mike McMahon <MMCM at MIT-AI>
Subject:  RMS's Complaint about AI being down
To: JLK at MIT-MC
cc: BUG-LISPM at MIT-MC

Please note that all of RMS' problems were caused by being previously logged
in through AI.  The editor uses your directory on the login machine for the
default file name, and trying to login again (through MC) had to first logout
which looks for USER .LSPM_.  Logging in through MC works on a freshly booted
machine.


Date: 25 MAR 1980 1442-EST
From: JERRYB at MIT-AI (Gerald R. Barber)
To: (BUG LISPM) at MIT-AI

In system 26.3, with microcode 618, on LISP Machine Six:

Typing the following after a cold bood:

(si:sb-on 'chaos)
(chaos:connect 'cadr6 "eval")

returns the string:

"Bad state: LOS-RECEIVED-STATE, Con ection not ope:"

I didn't mistype, the string is randomly smashed as shown.

With the sequence breaks for chaos off, it works fine.


Date: 25 March 1980 09:41-EST
From: John L. Kulp <JLK at MIT-MC>
Subject:  RMS's Complaint about AI being down
To: BUG-LISPM at MIT-MC

I have been screwed by this numerous times.  It goes without saying that
the AI machine should not be required for the use of a LISP machine, and
as long as this situation is likely to be rectified within a few months,
further complaints/comments will be witheld...(I mean "required for use"
in a broader sense than simply having to set file-default-host, namely
that many support (database) files, documentation, sources, etc are only on AI.
Presumably some things like documentation could be distributed to other
machines  -- but it would be a major convenience if one could define
default seach paths for files so that if AI was down, FONTS;FONTS WIDTHS
for instance, would be automatically loaded from MC without kludgey special
case code for each instance).


rms@MIT-MC (Sent by ___041@MIT-MC) 03/24/80 23:11:39
To: (BUG LISPM) at MIT-MC
I was using a Lisp machine and AI was down.
I typed C-X C-W and before even giving me a minibuffer
it hung up trying to look at AI.
It should have waited to give me a chance to say "MC:"
as I had planned to.
Well, I tried saying (login 'rms 'mc)
(I had logged in before, at a time when AI was still up)
and again it barfed about not being able to get to AI.

What I finally had to do was disassemble some things to find
out about si:file-default-host.


MOON@MIT-MC 03/24/80 08:44:43 Re: FDEFINE question
To: BAK at MIT-MC
CC: (BUG LISPM) at MIT-MC
    Date: 22 MAR 1980 1612-EST
    From: BAK at MIT-AI (William A. Kornfeld)
    To: (BUG LISPM) at MIT-AI

    When fdefine-carefully asks you if you are sure you want to redefine a function,
    and you type N, it goes into the error handler.  Wouldn't a more reasonable behavior
    be for it to simply not redefine the function and go on?
FDEFINE has done what you request for six months to a year.  Maybe there's
a bug in the cross-package-misdefinition question instead; I will look
into that.

MOON@MIT-MC 03/23/80 08:59:10
To: BAK at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date: 22 MAR 1980 1612-EST
    From: BAK at MIT-AI (William A. Kornfeld)
    To: (BUG LISPM) at MIT-AI

    When fdefine-carefully asks you if you are sure you want to redefine a function,
    and you type N, it goes into the error handler.  Wouldn't a more reasonable behavior
    be for it to simply not redefine the function and go on?

There is no function by that name in the standard environment.

Date: 22 MAR 1980 1612-EST
From: BAK at MIT-AI (William A. Kornfeld)
To: (BUG LISPM) at MIT-AI

When fdefine-carefully asks you if you are sure you want to redefine a function,
and you type N, it goes into the error handler.  Wouldn't a more reasonable behavior
be for it to simply not redefine the function and go on?


Date: 22 MAR 1980 0149-EST
From: Henry at MIT-AI (Henry Lieberman)
Subject:  Can you guess how many value cells there are in the jar?
To: (BUG LISPM) at MIT-AI, CARL at MIT-AI

For those thinking about the impact of value cells on GC:
In the middle of a completely random session,
I counted 1910 symbols which had values. 
This was out of the 17285 symbols in the whole world. 
Looks like some estimates of how many there are was a bit high. 


Date: 21 March 1980 16:46-EST
From: Gerald R. Barber <JERRYB at MIT-AI>
Subject:  escape key package
To: INFO-LISPM at MIT-AI


Any comments on the new escape key package would be appreciated.

Date: 21 MAR 1980 1424-EST
From: jerryb at MIT-AI (Gerald R. Barber)
To: INFO-LISPM at MIT-AI


I have written a set of functions to allow the use of the <esc> keys in
a more reasonable fashion.  It resides in JERRYB;ESCAPE.

An interesting application is the use of the keys in the manipulation of windows,
obviating the need for the mouse in many cases.

Loading the file and doing <esc><help> will list all defined escape keys.

The function KBD-ESC-INSTALL-FUNCTION is used for defining new keys or the
escape key  (lambda) may be used to bind a key in realtime while  (pie) can
unbind a key.

Note that whatever you hang on an escape key runs in its own process to protect
the keyboard process.


Date: 21 MAR 1980 1415-EST
From: jerryb at MIT-AI (Gerald R. Barber)
To: (BUG LISPM) at MIT-AI

In system 26.4, with microcode 618, on LISP Machine Nine:

Peek winow mode A is broken.

Why don't supdup and telnet windows become deactivated when they
are sent a Kill message.  Seems as if they should.


Date: 21 MAR 1980 0240-EST
From: Moon at MIT-AI (David A. Moon)
Subject: FED bugs
To: (BUG LISPM) at MIT-AI

In system 26.10 NWS, with microcode 618, on LISP Machine Nine:

The D command does not work; it displays garbage.  This may have to do with the
effect that it gratuitously clobbered the box width of all my characters to 0
(but they have raster outside the box).

If I do a c-R, edit for a while, then do a c-W, the directory in the filename
default has been changed to LMFONT;.  Presumably this is an attempt to encourage
smashing the system fonts.

I'd rather you didn't have to do an "S" after editing a character, but had automatic
saving and an explicit command for cancelling the current edit or undoing a previous save.

ALAN & HIC@MIT-MC (Sent by ALAN@MIT-MC) 03/19/80 22:08:37 Re: PUTPROP
To: (BUG LISPM) at MIT-MC
We note that every time you do a putprop you are consing.
The first thing that putprop does is call remprop to flush the
old property, then it conses a new pair on the front.

This has the advantage that the property is moved to the
front of the plist.  It has the disadvantage that it always conses.

How about having it do the appropriate rplaca if the property
already exists?

Date: 19 March 1980 11:46-EST
From: "Guy L. Steele, Jr." <GLS at MIT-AI>
To: MMCM at MIT-AI
cc: GLS at MIT-AI, BUG-LISPM at MIT-AI

    Date: 18 March 1980 14:13-EST
    From: Mike McMahon <MMCM at MIT-AI>

        GLS@MIT-AI 03/18/80 14:06:07
        Yet another instance of the screw where Apropos lists a certain command
        but the M-X completing command reader refuses to believe it:
    I thought you had received Moon's message concerning this a while ago.  The new
    editor will tell you command that are available via M-X explicitly.
Sorry, I was confused -- I thought the fix was in because I seemed to have
a newer version of things -- but I guess not of that.

However, I neglected to point out another bug here: why CAN'T I get
Kill Mode/Global Word Abbrev?  I'm in Abbrev mode, and I can
access make Word Abbrev and Kill All Word Abbrevs, but not those.

Date: 19 MAR 1980 1138-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
Subject: defstruct selector of NIL returns NIL bad idea
To: MOON at MIT-MC
CC: GLS at MIT-AI, (BUG LISPM) at MIT-AI

    MOON@MIT-MC 03/18/80 23:01:07 Re: defstruct selector of NIL returns NIL bad idea
    It would certainly have hindered me from detecting dozens of bugs.  You can
    achieve that effect by using :list rather than :array (the default) as the
    structure type.

There is indeed the bug-detection problem.  Hence it would be most
convenient if it were an option in DEFSTRUCT, preferably per-selector.
The problem with using :LIST is that I want the speed of array access
(maybe I'm being fussy, but...).  Actually, as far as bug detection
goes, I'm of the mild opinion that when you allocate things
like arrays and structures the default value of each component should
not be NIL, but rather a null pointer (whatever it is that gives
unbound-variable errors).  The same thing goes for PROG variables,
actually, but that's entrenched in the language.  It's not
so bad to type (FOOSEL ()) instead of FOOSEL in the DEFSTRUCT.

Date: 19 MAR 1980 0825-EST
From: TFT at MIT-AI (Tom Trobaugh)
To: (BUG LISPM) at MIT-AI

    I tried to use STEP on CADR 6 just now, and was told the LISP-LISTENER-1 had
recieved a PC-PPR msg that went unclaimed.  This was on the init-lsp-lstnr.

Date: 19 MAR 1980 0122-EST
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

    Date: 18 MAR 1980 1242-EST
    From: GLS at MIT-AI (Guy L. Steele, Jr.)

    Just as it is useful for (CAR ()) = (CDR ()) = (), so it would
    be very useful for any DEFSTRUCT selector to return () when
    applied to ().  I'm writing a piece of code for which that would
    be INFINITELY convenient.  On the other hand, I'm not sure I
    would want the AR-n primitives as such to change (but maybe so?).
    Anyway, (SETF (FOOBAR ()) 43) would still barf, just as
    (RPLACA () 43) should.  Anyway, it would seem simple to add
    something like CAR-SYM-MODE called AR-SYM-MODE or something,
    with only two values (error, and error-except-nil).

This might be a good idea, but having modes to control it is no good,
because these operations will be run in the same world with other code
which does not expect such behavior.  So there would need to be new
operations which would be like AR-N except allow nil.  Then the user
could in each DEFSTRUCT specify whether nil would be allowed or not.

Date: 18 MAR 1980 1242-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI, GJS at MIT-AI

Just as it is useful for (CAR ()) = (CDR ()) = (), so it would
be very useful for any DEFSTRUCT selector to return () when
applied to ().  I'm writing a piece of code for which that would
be INFINITELY convenient.  On the other hand, I'm not sure I
would want the AR-n primitives as such to change (but maybe so?).
Anyway, (SETF (FOOBAR ()) 43) would still barf, just as
(RPLACA () 43) should.  Anyway, it would seem simple to add
something like CAR-SYM-MODE called AR-SYM-MODE or something,
with only two values (error, and error-except-nil).


Date: 14 MAR 1980 2206-EST
From: jerryb at MIT-AI (Gerald R. Barber)
To: (BUG LISPM) at MIT-AI

In system 26.3, with microcode 618, on LISP Machine Two:

There ought to be an easier way to hang things off the <esc> keys, maybe an array
indexed by the character, each entry would contain a function of one arg, 
the numeric arg.

Date: 14 MAR 1980 1810-EST
From: jerryb at MIT-AI (Gerald R. Barber)
To: (BUG LISPM) at MIT-AI

In system 26.3, with microcode 618, on LISP Machine Two:

In a supdup both CALL and P do the same thing.  I propose that CALL
return to the top window and that P merely bury the supdup window.


Date: 14 MAR 1980 1520-EST
From: jerryb at MIT-AI (Gerald R. Barber)
To: (BUG LISPM) at MIT-AI

In system 26.3, with microcode 618, on LISP Machine Two:

Marks don't seem to be buffer specific anymore, ie if I set a mark in buffer foo,
switch to buffer bar and do a U<space> I am switched back to buffer foo.


Date: 13 MAR 1980 1744-EST
From: DLW at MIT-AI (Daniel L. Weinreb)
To: (BUG LISPM) at MIT-AI

The Lisp Machine mail sending programs should refuse to send
mail with no recipients.  COMSAT will just reject it as a BADREQ
anyway, so it would be better to inform the user that he
is losing in the first place.

Date: 13 MAR 1980 0844-EST
From: MOON at MIT-AI (David A. Moon)
To: (BUG LISPM) at MIT-AI

LCADR;UCADR is currently in an inconsistent state, containing half-completed
changes.  Don't try to do anything with it.

Date: 12 MAR 1980 2342-EST
From: KMP at MIT-MC (Kent M. Pitman)
Subject: GC-DEFER, GC-RESTART, and friends
To: NIL at MIT-MC
CC: (BUG LISPM) at MIT-MC

Here's an idea I came up with in discussion with RLB the other day about
gc's and code that requires knowing when one happens ... there are times
when you worry about doing a given task not because it is particularly
tricky or that you can't start it over but just 'cuz it's prone to
timing screws. Wouldn't it be nice if code of that point could just say
-- start me over here if you have to GC ... So you could do

  (GC-RESTART
    (SETQ FOO (MUNKAM x))
    ... simple code involving FOO's value ...)

where you aren't going to do anything to make the garbage collector get
up and do its thing, but you don't have to lock out interrupts to keep things
from getting messed up ... 

Naturally, there's a new idiom for doing infinite loops ... people might want
to replace
		(DO () (NIL) ...) with (GC-RESTART ... (GC))

yes, some silly things can be made out of it, but there are useful applications
too ... Doing pointer arithmetic would be a whole lot simpler if one could
do this sort of thing... I think this can open code into something pretty
efficient if you just keep a location around which if non-zero contains
info about what state to return to if a GC occurs.... but there is this
hairy case... if one does

	(GC-RESTART ... (GC-RESTART ... x ...) ...),

it seems to me that one has to return to the outer GC-RESTART but one
still may or may not want to run the inner code as well ... eg, suppose
that the inner one isn't lexically scoped and is some interrupt trying to
run. It may want to do a local return to the GC-RESTART in the interrupt
and when the interrupt has been handled, control may want to pass to the
other GC-RESTART. Maybe a GC-RESTART-BARRIER could accomplish this or maybe
interrupts could do something special or who knows ... 

Here's another -- GC-DEFER ... doing
(GC-DEFER ...code...) says that you want to turn off garbage collection
for the execution of this form. This is for forms that cannot be restarted
if the garbage collector runs. In such a case, the GC-LOSSAGE handler, not
the GC-OVERFLOW handler should be run if a GC feels forced at that time.
Additionally, doing (GC-DEFER ((fixnum 30.) (flonum 50.)) ...) might be
a nicer syntax so that you could say -- "I'm about to do an operation that
will require 30 fixnum cells and 50 flonum cells. If you don't have that 
many, you can do a GC-OVERFLOW type error now but if you enter me you better
not do any GC'ing until I return ..." -- hence interrupts running in that
time that caused GC's would cause GC-LOSSAGE -- if the guy wants to lock out
interrupts too he might want to, but maybe he doesn't want to lock out ^G and
other winners ...

So there's the suggestions for your comments and consideration.
-kmp


Date: 12 MAR 1980 1852-EST
From: LEVITT at MIT-AI (David A. Levitt)
Subject: CADR 9 monitor losing badly
To: (BUG LISPM) at MIT-AI

The CADR 9 monitor in 921 went black after a cold boot.
I haven't checked to see whether the monitor in 918A works.

Date: 12 MAR 1980 1629-EST
From: dkm at MIT-AI (David K. Mellinger)
Sent-by: ___017 at MIT-AI
To: INFO-LISPM at MIT-AI

Please remove me from the INFO-LISPM mailing list. Thank you.  dkm

Date: 11 MAR 1980 1825-EST
From: JLK at MIT-AI (John L. Kulp)
To: (BUG LISPM) at MIT-AI

A new bus interface has been plugged into CADR-7.  If it still dies with a
main memory parity error, please send mail to CADR.


Date: 11 MAR 1980 1626-EST
From: GYRO at MIT-AI (Scott W. Layson)
Subject: new iteration facility
To: INFO-LISPM at MIT-AI

ARE YOU undone by DO?  Do you find mapcar pretty, but too few of the things
you want to map over are lists?  Have you seen Pete Szolovits' FOR package,
and wondered that people would want Lisp to look like Cobol?  Take a look
in  ai:apiary;gmap >  for the new wave in Lisp iteration!

This version is still experimental.  YOUR suggestions can help improve it.
Try it out!

-- Scott Layson

Date: 11 MAR 1980 0252-EST
From: ED at MIT-AI (Ed Schwalenberg)
Subject: UCADR
To: (BUG LISPM) at MIT-AI

COMSAT was in its usual wedged state earlier this evening, trying to
write out 222 blocks to pack 2.  I first tried deleting random PRESS files
and such, then attempted to move UCADR 609 to another pack.  I got a
DIRECTORY FULL error, so I moved it to ED;.  Then HIC wrote out UCADR >
and now it can't be moved back.  HIC refuses to delete something, so
if anyone cares, they're in charge.

Date: 10 March 1980 14:58-EST
From: Howard I. Cannon <HIC at MIT-MC>
To: CENT at MIT-AI
cc: INFO-LISPM at MIT-AI

CADR7 has been getting parity errors recently.  They are of suspicious origin.
We are currently involved in a manhunt for the culprit.  Be wary
of using it for anything lengthy and/or important.

Date: 10 MAR 1980 0724-EST
From: CENT at MIT-AI (Pandora B. Berman)
To: (BUG LISPM) at MIT-AI

cadr7 while supduping to ai and in emacs
just decided to stop on me twice in half an hour. it
may be tht i am just not patient enough. but in each case
although it appeared that it should be able to hear the
keyboard, it didn't listen to call and seemed to become
entirely wedged when warm-booted. it seemed to be all right
after cold booting.

Date:  9 MAR 1980 2204-EST
From: DANNY at MIT-AI (W. D. Hillis)
To: INFO-LISPM at MIT-AI

	For those of you who are confused about the status of CADR-9. There are two
consoles on this machine: one in 918a (locked), one around the corner in 921 (unlocked).
This has been the case since the machine was installed; I apologize for not publicizing
better in the first place. Switching between the consoles involves changing a plug (unlocked).
Get someone to show you which one.
                                      -Danny

Date:  8 MAR 1980 1326-EST
From: CWH at MIT-AI (Carl W. Hoffman)
To: (BUG LISPM) at MIT-AI

Why does QC-FILE-LOAD actually load the file after compiling
rather than using the LOAD-FLAG option of QC-FILE?


Date:  7 MAR 1980 2342-EST
From: Moon at MIT-AI (David A. Moon)
Subject: New Lisp machine system release
To: INFO-LISPM at MIT-AI

System 26.3 and microcode 616 are installed on CADR-1 and CADR-6.  This
system has a lot of bugs fixed, and (we may hope) doesn't have more than
its share of new ones.

If you want to help out, follow the instructions in the file AI:LMDOC;INSTAL NEWSYS
and copy this system onto your favorite machine.

Date:  7 MAR 1980 2331-EST
From: HENRY at MIT-AI (Henry Lieberman)
Subject: Room 902 to be kept locked
To: SJOBRG at MIT-AI
CC: PHW at MIT-AI, BKPH at MIT-AI, CARL at MIT-AI
CC: (BUG LISPM) at MIT-AI

I think this is not acceptable. Other lab
members need the Lisp Machines to get their work
done. Lisp Machines are still scarce enough
so that people will often be unable to find them if 2 of
them are inaccessible [representing 20% of our total 
supply], especially at night when the room is likely to
be locked. As an alternative I suggest one of the following:
 - Move the valuable equipment out of that room.
 - Move the consoles out of that room.
 - Have consoles that are switchable between that
room and somewhere else. I think there's a plan for
that for 918.

Date:  7 MAR 1980 0822-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
Subject: New color hack
To: (BUG LISPM) at MIT-AI
CC: HES at MIT-AI, GLS at MIT-AI, DANNY at MIT-AI

An alternative to COLOR:COLORIZE is COLOR:COLORATE.  It repeatedly chooses
a random pair of colors and linearly "melts" them into each other; that is,
the colors are exchanged, but slowly, by a process of mutual linear
interpolation.  It is a nice effect.  It is especially good with
SPECTRUM-COLOR-MAP, which duplicates colors, because things seem to
fade away and then reappear (because it and its background are temporarily
the "same" color.)  I put this into LMIO;COLOR and recompiled.


Date:  6 MAR 1980 1633-EST
From: JLK at MIT-AI (John L. Kulp)
To: (BUG LISPM) at MIT-AI

If you take one or more of the new keyboards away from the 9th floor, please
note the fact in AI:LMDOC;KBD LOG so we can keep track of them (at least roughly).
Thanks.


Date:  6 MAR 1980 0834-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: (BUG EMACS) at MIT-AI, GLS at MIT-AI

In system 25.0, with microcode 612, on LISP Machine Two:

I suggest the following new feature:  C-M-% does the floowing hairy thing.
It is assumed that the cursor is somewhere before or in one variable-binding
clause of a LET.  It verifies this and decides which one by doing successive C-M-(
operations until it discovers that two of them have bounded the word LET plus
possible whitespace (you do it this way so that you don't count being in the
bodies of inner LETs).  Then you go to the right of the ( after the LET and do
C-M-N repeatedly until you pass the original cursor position, then back up
one; that's the binding clause in question.  Call the two parts of the clause
the variable and the value.  Then you enter Query Replace mode with the value
as first argument and the variable as second argument (but ^U exchanges these
roles), and with the range of the replace (enforced by temporary buffer bounds?)
reduced to the body of the LET (or the rest of the buffer if the body is incomplete).

This allows you to write a piece of code, notice that (CAR FOO) is used all over the
place, then install (LET ((BAZ (CAR FOO))) ... ) and easily make the appropriate changes.
^U lets you easily de-install such a LET if that's what you want.


Date:  5 MAR 1980 2136-EST
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

	[by the way, people, one of the claimed advantages
	of dynamic scoping was that debugging is easier because
	you can just type the name of a variable and see the
	value when in a debugger -- whereas for lexical scoping
	you need a more complicated thing that can grovel over
	the environment.  But in the current scheme of things
	I find myself typing A and L a lot and groveling arond
	trying to find things.

The variables that cause the trouble are not dynamically scoped.  The
problem exists because the system is NOT purely dynamic.

	Before I end this flame, I'd like
	to put in a good word for the DEFAULT being for the
	compiler to include all debugging information, including
	names of locals and the kitchen sink, in all FEF's,
	for debugging purposes.

It is.

Date:  5 MAR 1980 1738-EST
From: gls at MIT-AI (Guy L. Steele, Jr.)
Sent-by: RICH at MIT-AI
Subject: FORMAT
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

I did add two more features to FORMAT.  They are already documented
and everything -- I just forgot to send a note to (BUG LISPM).
SHall I prepare a better note of all changes and send to INFO-LISPM
at some point?

(1) ~{~} (where the iterand string is null) means that an argument
    should be gobbled, whgich had better be a string, to be used as the
    iterand text.  It may contain ~x commands, etc.  This argument is
    gobbled before any arguments processed byu the iteration itself.
(2) ~:}, used to close any flavor of ~{, forces the iterand text to
    be processed at least once even though the list of arguments
    to be iterated over is initially empty.  However, an explicit repeat
    count of zero will override this, and iterate zero times anyway.

Date:  5 MAR 1980 1734-EST
From: gls at MIT-AI (Guy L. Steele, Jr.)
Sent-by: RICH at MIT-AI
Subject: Errors in LISP Machine code
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

I'd like to suggest that a little more thought be put into
error recovery in LISP Machine software.  We have this
wonderful CERROR function which ought to be used more.
For a better user interface, it should ideally be very
easy for the user to retry or restart or whatever.
Some parts are very good, offering you a range of options
(e.g. Y, N, E, or P?); others just crap out and the
best you can do is return a value from some function,
possibly after pulling off a side effect (which is difficult
at best because all the goodies of interest are hidden
away in compiled local variables
	[by the way, people, one of the claimed advantages
	of dynamic scoping was that debugging is easier because
	you can just type the name of a variable and see the
	value when in a debugger -- whereas for lexical scoping
	you need a more complicated thing that can grovel over
	the environment.  But in the current scheme of things
	I find myself typing A and L a lot and groveling arond
	trying to find things.  The new window system debugger
	may help some -- but that technology would also help
	lexical scoping too.  Before I end this flame, I'd like
	to put in a good word for the DEFAULT being for the
	compiler to include all debugging information, including
	names of locals and the kitchen sink, in all FEF's,
	for debugging purposes.  Also a reverse compiler would be
	a lot more useful than the crocky disassembler.]
where they are hard to find).  I said I wouldn't hack FORMAT
any more, but if other people will think harder about error
recovery I promise to fix up all the uncorrectable errors
in FORMAT to recover more gracefully.

I suggest that the flags to CERROR (proceedable-p and restartable-p)
should, if non-nil, be strings describing what will happen
if that action is taken.  This information should be printed
along with the error message, or something.

Date:  5 March 1980 08:33-EST
From: Mark L. Miller <MILLER at MIT-AI>
Subject: PUT/GET
To: RWK at MIT-MC, NIL at MIT-MC, MULTICS-LISP-PEOPLE at MIT-MC,
    BUG-LISPM at MIT-MC, BUG-LISP at MIT-MC

I vote "yes" for the proposal.  I am always having to explain to
new LISP-ers (e.g., my students) why there are so many exceptions and
inconsistencies.  Upward compatibility is nice and all that, but
maybe NIL is a good chance to clean up a lot of "historical" lossages...
  Regards, Mark



Date:  4 MAR 1980 1609-EST
From: Doyle at MIT-AI (Jon Doyle)
Subject:  Too much hidden processing and lost characters
To: (BUG LISPM) at MIT-AI
CC: DOYLE at MIT-AI

Perhaps someone has remarked on this before, but I find that LM1 is incredibly
unresponsive due to some hidden processing going on in the background.  I have
heard a rumor that this has something to do with collecting status information
for the free tv display, but the magnitude and effects of this processing seem
to be far too large and consequential if that is all that is being done.

It seems to me that I lose something like 10-15 seconds out of every minute to
the mysterious background process.  This is a lower bound.  Sometimes it seems
like more.  This in itself is annoying enough, but has the extremely annoying
effect that at moderate typing speeds, I seem to exceed the typeahead capacity
during these extended intervals and thus lose between 5 and 8 characters in the
middle of my input every minute or so when I am simply entering information.
To make sure this lossage is not happening, I must constantly be looking at
the screen, rather than at my source as is natural in touch typing, to watch
for halted processing.  When I see the machine stop, to be safe I must stop
and sing a few refrains of some song while waiting for it to return its
attention to me.

Is this necessary?  Is this the correct operation, or am I doing something
which aggravates the problem?

Date:  4 MAR 1980 1437-EST
From: gls at MIT-AI (Guy L. Steele, Jr.)
Sent-by: RICH at MIT-AI
To: MOON at MIT-AI
CC: GLS at MIT-AI, (BUG DDT) at MIT-AI, (BUG LISP) at MIT-AI
CC: (BUG ITS) at MIT-AI, (BUG TECO) at MIT-AI, (BUG EMACS) at MIT-AI
CC: (BUG LISPM) at MIT-AI, cpr at MIT-MC

Last note from RICH was really from GLS.

Date:  4 MAR 1980 1434-EST
From: RICH at MIT-AI (Charles Rich)
To: MOON at MIT-AI
CC: GLS at MIT-AI, (BUG DDT) at MIT-AI, (BUG LISP) at MIT-AI
CC: (BUG ITS) at MIT-AI, (BUG TECO) at MIT-AI, (BUG EMACS) at MIT-AI
CC: (BUG LISPM) at MIT-AI, CPR at MIT-MC

One obvious application of the Greek/Front key on the PDP-10
is that all such characters could be self-inserting in TEX format;
thus typing  would insert "\alpha", etc.  I don't know how much
more convenient this would make it to type weird formulas in TEX.

MOON@MIT-MC 03/04/80 12:01:08 Re: Marksman
To: info-lispm at MIT-AI
If you have a problem with CADR10, which is a problem with the marksman
disk, please follow the instructions posted on the wall, which will mail
me information about what happened.  

Date:  4 MAR 1980 1113-EST
From: RICH at MIT-AI (Charles Rich)
Subject:  DIRED
To: (BUG ZWEI) at MIT-AI
CC: (BUG LISPM) at MIT-AI

It is very confusing if you are in DIRED and hit control-Z
and then type (ED) again, you end up back in the *DIRED*
buffer but not under the control of the DIRED program.
The screen looks the same (except for the line "Q to Quit"
at the bottom) and it can take a while to figure out why
it doesn't respond like a DIRED.

JLK@MIT-MC 03/03/80 13:07:16
To: (BUG LISPM) at MIT-MC
In case someone needs to know, CADR-10 (which thinks its CADR-11 due to the setting
of its host address switched) is dying about every 5 mins, with the disk bar on.


Date:  3 March 1980 07:44-EST
From: Robert W. Kerns <RWK at MIT-MC>
Subject: PUT/GET
To: NIL at MIT-MC, MULTICS-LISP-PEOPLE at MIT-MC, BUG-LISPM at MIT-MC,
    BUG-LISP at MIT-MC

I want to put (PUT <sym> <tag> <value>) like (PUTPROP <sym> <value> <tag>)
but with the args in the right order into LISP.  This makes
(SETF (GET ...) ...) easier to do right WRT order of evaluation, and
makes a lot more sense.  This is consistant with all the other ACCESS/STORE
frobs except for the other exceptions....

However, it may be argued that we should not usurp the name PUT from the
user, and that we shouldn't even be usurping GET.  Personally, I lean
somewhat to using the name PUT on the theory thta such widely used things
deserve to be short, but other suggestions for the name are PUT-PROP, with
GET-PROP also existing, equivalent to GET.  So I'm throwing it out here
so we can all agree on a name and be consistant with each other.
Comments?  Flames?


Date:  3 MAR 1980 0236-EST
From: Moon at MIT-AI (David A. Moon)
To: (BUG LISPM) at MIT-AI

There used to be two TV tool kits ("GC alignment kit") in 936.  There are now none.
How can anyone contribute to the group effort without any tools?  If you know where
these are, return them to 936 postehaste.

Date:  3 MAR 1980 0139-EST
From: Moon at MIT-AI (David A. Moon)
Subject: Slightly incompatible changes in next world
To: INFO-LISPM at MIT-AI

1. The system will start using the variables ++, **, +++, ***, and //.  These
   symbols are not global now, but will be in the next system.
   // will hold the list of multiple values of the last form; like * but you
   get a list of the values rather than just the first.
   ++ will hold the previous value of +, and +++ the value before that.
   ** will hold the previous value of *, and *** the value before that.
   These are not a substitute for a full-blown history feature, but in their
   simplicity should make interacting with the read-eval-print loop easier.
2. If formerly you had (format x "~{~S~}" y), now you must say
   (format x "~{~S~^, ~}" y).  If you never heard of this, don't worry
   about it.
3. The system will thrash a little less.  Let me know if this inconveniences
   anyone.

Date:  2 MAR 1980 1809-EST
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

I did Break L at a SUPDUP, but it detached me instead of logging me out.

Date:  2 MAR 1980 1806-EST
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

There ought to be a way to retry from the error of being
unable to connect to AI for file reading.

Date:  1 MAR 1980 1522-EST
From: Gyro at MIT-AI (Scott W. Layson)
Subject:  speed of compiled funcalls
To: (BUG LISPM) at MIT-AI

This isn't a bug, but I didn't know whom else to ask, so:

I have a macro that in normal use generates a lot of stuff of the form
(funcall #'foo bar)
  and
(funcall #'(lambda (snrk) (glop snrk 3)) cruft)


Should I bother to make the macro smart enough to turn this into
(foo bar)
  and 
(glop cruft 3)
or is the compiler smart enough to do the equivalent thing for me?


Date:  1 MAR 1980 1504-EST
From: CENT at MIT-AI (Pandora B. Berman)
To: (BUG LISPM) at MIT-AI

cadr11 has a habit of not liking to be booted.
this morning i gave up on it after alternately power-cycling
the disk and trying to cold-boot about 5 times.

Date:  1 MAR 1980 1345-EST
From: KENT at MIT-AI (Kent A. Stevens)
To: (BUG LISPM) at MIT-AI

the xgp hardcopy process is annoyingly fragile.  I have received numerous
errors, such as "went into an illegal state", or "LOS:connection does not
exist at this end" in CHAOS:send packet, and others that crop up.

the user (me) does not have recourse but to warm boot, it seems.  that
is frustrating, to say the least.

if AI is down, or there is no disk space temporarily, or other problem on
the 10 side of things, can the chaos net be more kind, and keep trying.
it is billed as a background job, but often burps up onto the screen leaving
me with the problem of trying to figure out which screen-full was lost, often
in the midst of making several difficult-to-reproduce diagrams.

Please consider making the xgp process more robust.  it gets a lot of good use,
but needs to be more kind to the user.

thanks.

Date:  1 MAR 1980 1326-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
Subject: Writing DREI in FORMAT language, etc.
To: (BUG LISPM) at MIT-AI, RMS at MIT-AI, HENRY at MIT-AI
CC: GLS at MIT-AI

I was aware that it is rather fruitless to make FORMAT
be too powerful -- after all, one can always use LISP!
But then again, creeping featurism... Anyway, I'd like
to point out that I haven't implemented anything which
wasn't either a bug fix or a feature I want to use now
for some purpose (i.e. in the next week).  I carefully
resisted putting anything in just because of elegance.
(In particular, I avoided putting in Q-registers, much
as I was tempted to, to solve a tab problem!)  -- Quux

Date: 29 FEB 1980 1721-EST
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI, GLS at MIT-AI

Is FORMAT powerful enough now to write a real-time editor in?

Date: 29 FEB 1980 1556-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
Subject: Changes to FORMAT
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI, GSB at MIT-AI

I am done hacking FORMAT; I have tested it and it seems to work.
Naturally I'll fix any remaining bugs.  A summary of changes:

I fixed a bug in ~C (it printed the  in the wrong place).
The parts of ~C which need the names of special keys like
Return and Tab now use the same table which is used in the
reader to process #\.  This table (an a-list) now resides
in the special variable SI:XR-SPECIAL-CHARACTER-NAMES.
(I updated LMIO;READ > for this purpose.)  ~:C and ~:@C
perform a reverse look-up in this table, then capitalize the
name.

~@C is a fourth character print-out mode.  It prints the character
in a READable format using #/ or #\ as appropriate (another reason
for using READ's #\ table).  It deals with bucky bits too (e.g. #/F).

~:* is like ~* but "exgnores" arguments, i.e. it backs up so that
you can reprocess them.  ~n* backs up n arguments.

~:P is like ~P but does ~:* first.  Hence (format nil "~D dog~:P" n).
~@P prints "y" or "ies" as appropriate.  ~:@P does both.  Hence
(format nil "~D pupp~:@P" n)

~nR means print a number in radix n.  (I de-installed ~B, which I
had previously reported to mean Binary.)  Thus ~8R = ~O.  Any flags
or additional parameters are exactly as for ~D.  The full form is
therefore ~radix,mincol,padchar,commacharR.

~@{ means use all the remaining arguments as the arguments to
be iterated over.  ~:@{ means use all remaining arguments,
each a list to be used as a set of arguments, one per iteration step.

~^ means escape (mnemonic: throw UP (^)) from a loop.  (Previously
I called this ~$, but renamed it because of a conflict with GSB's stuff.)
If there are no remaining arguments to process, terminate the enclosing ~{.
~n^ terminates iff n is zero; thus ~0^ is an unconditional termination.
~n,m^ terminates iff n=m.  ~n,m,p^ terminates iff nmp.
If one is within a ~:{ (or ~:@{), however, then the set of arguments
one sees is for this iteration step only, and therefore ~^ terminates
only the current iteration step, allowing the commencement of the next one.
In this situation, ~:^ can be used to terminate the entire loop.

~^ used within a ~< terminates processing of ~< clauses.  Only as many
as have been completely processed are used by ~<.

~^ outside of a ~{ or ~< terminates the processing of the entire FORMAT call.

If the first clause of a ~< is terminated by ~:; instead of ~;, then
the text resulting from the first clause (and the padding point
indicated by the ~:;) is not included in the justification process.
When the justification is done, then if the newly padded text will fit
on the current line (it always fits if you can't :READ-CURSORPOS the stream),
the justified text is output; but if it won't, the text from the first clause
is printed (it probably should contain a newline), and then the justified text.
If there is a parameter ~:n;, then the text must fit with n characters to spare
to avoid printing the first clause's text.

Incompatible change to ~{: it no longer automatically puts in ", "
between iteration steps.  To do this one can use ~{text~^, ~}.
But with a little extra thought one can do even better than that.
For example, ~{~<~%  ~:;text~>~^, ~} avoids splitting items across line
boundaries.

A numeric parameter n to any kind of ~{ limits the number of iterations to n.

The character # used as a parameter means the number of arguments left
to be processed.  Like ~G and ~*, this is relative to any enclosing
iteration, or to the global FORMAT process if not so enclosed.

~@[text~] tests an argument.  If nil, it swallows it and does nothing;
otherwise it does not swallow it and processes the text.

~[foo~;bar~;baz~:;quux~] does quux if one of the other clauses is not
selected; that is, ~:; indicates an "else" clause.

~[~1,2;foo~3;bar~4,5,17;baz~:;quux~] does foo if the argument is 1 or 2;
bar if 3; baz if 4, 5, or 17; and quux otherwise.  This is a "tagged
cases" construct.  If a tagged case has a :, then the tags are pairs
of range boundaries.  Thus:
"~[~'+,'-,'*,'//;operator ~:'A,'Z,'a,'z;letter ~:'0,'9;digit ~:;other ~]"

A numeric parameter to ~[ uses that as the selector rather than using
an argument.  This is mostly useful for ~#[.

~[, ~{, and ~< now all nest properly.  Internally there is only one routine
which parses ~;-clauses, and only one routine which parses ~-commands (the
second uses the first).

I fixed up the reporting of errors in format strings.  Control strings
are sometimes hard to decipher, so many errors now indicate the place
in the string where the error was encountered.


JONL@MIT-MC 02/06/80 14:17:10 Re: LISPM compiler inadequacy?
To: MOON at MIT-MC
CC: (BUG LISPM) at MIT-MC
The lossage I mentioned to you last week about macros is no
doubt due the compiler "remembering" macrodefinitions for
use by the compiler's macro-finder/expander, but not doing so 
in a way that can be utilized by expr code.  MACLISP does this 
(that is, remembering, but not PUTPROPping macro definitions) 
when the macro name conflicts with a system function, but 
apparently the LISPM compiler does it for all macros?  
For example,
   (MACRO FIRST-MACRO (X) 
      (CDR (ASSQ (CADR X) '((TWO . '2) (THREE . '3)))))
   (MACRO SECOND-MACRO (Y) `(LIST ,(first-macro (cadr y))))
   (DEFUN A-FUN () (SECOND-MACRO THREE))
seems to be a paradigm of how I get the compiler to die in an
undefined function (which it announces to be FIRST-MACRO).
Is this right?  Is this the intended state during macroexpansion?

MOON@MIT-MC 02/08/80 15:08:10
To: HENRY at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date: 8 FEB 1980 0258-EST
    From: HENRY at MIT-AI (Henry Lieberman)
    To: (BUG LISPM) at MIT-AI

    Using a symbol whose function cell is an array
    as argument to ASET works interpretively, but
    not compiled.

    (DEFUN ARRAY-BUG ()
           (ARRAY AN-ARRAY T 1)
           (ASET 'ARRAY-ELEMENT 'AN-ARRAY 0)
           (PRINT (AREF 'AN-ARRAY 0)))

    The compiled version complains about a wrong
    type arg.
It is a bug that it works interpretively; it is not supposed to.
I will correct this if the AI machine ever comes up again.

JLK@MIT-MC 02/28/80 18:06:22
To: (BUG LISPM) at MIT-MC
The CADRIO; directory was completely full after adding about 2 new files to it,
so I created a CADRDC; directory and moved all the disk related stuff to it.
I left a forwarding pointer for XBUS DRW since other files refer to it...
I hope this doesn't cause lossage.


JLK@MIT-MC 02/28/80 18:14:05 Re: CADR 7
To: (BUG LISPM) at MIT-MC
After letting it sit in its hung state for about 10 minutes, it finally began to run
again.  I don't understand it.


MOON@MIT-MC 02/28/80 18:27:52 Re: Getting the dimensions of a window
To: GLS at MIT-AI
CC: (BUG LISPM) at MIT-MC
In the new window system, there is a :character-size window (and
hence stream) operation, which returns two values, width and height.
However, note that this whole concept is meaningless if you are using
variable width fonts, which is why we left it out in the first place.
Grind should really be using the operation which takes a cursor position
and a string, and tells you whether the string fits on the line to
the right of the cursor position and where it leaves the cursor.

JLK@MIT-MC 02/28/80 18:06:22
To: (BUG LISPM) at MIT-MC
The CADRIO; directory was completely full after adding about 2 new files to it,
so I created a CADRDC; directory and moved all the disk related stuff to it.
I left a forwarding pointer for XBUS DRW since other files refer to it...
I hope this doesn't cause lossage.


JLK@MIT-MC 02/28/80 18:14:05 Re: CADR 7
To: (BUG LISPM) at MIT-MC
After letting it sit in its hung state for about 10 minutes, it finally began to run
again.  I don't understand it.


MOON@MIT-MC 02/28/80 18:27:52 Re: Getting the dimensions of a window
To: GLS at MIT-AI
CC: (BUG LISPM) at MIT-MC
In the new window system, there is a :character-size window (and
hence stream) operation, which returns two values, width and height.
However, note that this whole concept is meaningless if you are using
variable width fonts, which is why we left it out in the first place.
Grind should really be using the operation which takes a cursor position
and a string, and tells you whether the string fits on the line to
the right of the cursor position and where it leaves the cursor.

Date: 28 FEB 1980 1620-EST
From: JLK at MIT-AI (John L. Kulp)
To: (BUG LISPM) at MIT-AI

CADR 7 is evidently dead.  After cold booting, typing out CADR 7 and such, it hangs
with the processor lights showing 00888 and no periods showing.

Date: 28 FEB 1980 1301-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

In system 25.0, with microcode 612, on LISP Machine Two:
There seems to be no easy way to get the LINEL of a screen or pc-ppr or whatever.
:LINEL is not a stream operation and there is no LINEL function.  Indeed, I looked
at GRINDEF to see how it was done there (my application is similar), and saw
that it just has the constant 95., with the comment "this should be computed"!!!


Date: 28 FEB 1980 1300-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

In system 25.0, with microcode 612, on LISP Machine Two:
I suggest that in FDEFINE when it tells you you are redefining
something illegally and asks whether to go ahead, if you say "No"
there shgould be some easy way to specify another symbol in whose
function cell the definition should be placed.  This could
be done by explicit question, or by making it recoverable with C.
(The idea of the latter is that the symbol is a "wrong type argument",
i.e. one which is already bound or something.)
The application happens when debugging a new version of a package
(in my case FORMAT).  I say (LOAD "LMIO;FORMAT" 'F0) to get it into
a new package.  It then tells me it is illegally redefining FORMAT;
I would like to say "no, don't clobber the system FORMAT function,
but instead call it F".


Date: 28 FEB 1980 0909-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

In system 25.0, with microcode 612, on LISP Machine Two:

If the Great Renaming ever occurs, I put in a vote to
rename RETURN-ARRAY to RECLAIM-ARRAY.  Its current name
is misleading (makes one think of a weird returning from
a PROG -- indeed I encountered it in a DO loop and went
bananas for a minute).


ALAN@MIT-MC 02/27/80 13:27:54
To: (BUG LISPM) at MIT-MC
Change the location that CADR-2 claims for itself.

MOON@MIT-MC 02/25/80 19:10:07 Re: ;;; 	 -*- Mode:Lisp; Package:User; Base: 8. -*- 
To: Nis at MIT-AI
CC: (BUG LISPM) at MIT-MC
I can't see any evidence in the code that this ever worked.  For now,
you can put a -*- Ibase:8 -*-.  That is, of course, the wrong thing,
but it will work.  I have made a fix in the source to cause "base:"
in the -*- line to work.  However, the whole way this feature works
now is wrong, and I think I'm going to do it over right the next
time I am on a Lisp machine.

Date: 25 FEB 1980 1900-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

I finally got fed up with FORMAT and made some changes to the code.
It's not thoroughly tested yet; in case of lossage, LMIO;FORMAT OQFASL
should be restored to QFASL status.
Among the changes:
~:P is like ~P but uses the previous argument, not the next.
   Hence "~D loser~P" does the right thing and swallows one argument.
~@P outputs "y" or "ies" as appropriate.
~@[str~] will process str iff the next argument is non-nil.  The argument
   is NOT SWALLOWED.  Thus "~@[PRINLEVEL=~D~]" prints its argument in decimal
   unless it is nil.  (I want to do this all the time.)
~B is like ~O and ~D, but binary.

INCOMPATIBLE CHANGE:
~{ no longer outputs ", " automatically between items.  Instead, there is
a new command ~$ which terminates the current format string if there are
no more arguments to be processed.  Actually, there are ~$, ~:$, ~{, ~:{,
~@{, ~:@{.  One can get the old effect of "~{foo~}" by doing "~{foo~$, ~}".
I'll document all this better later.

I also put a documentation string into the definition of FORMAT,
and fixed spelling errors in the English (~R) output stuff.


Date: 25 FEB 1980 1557-EST
From: jerryb at MIT-AI (Gerald R. Barber)
To: (BUG LISPM) at MIT-AI

In system 25.0, with microcode 612, on LISP Machine Five:

You cannot use NIL as an eof-option to TYI because TYI assumes an eof-option value
of NIL means it wasn't supplied.  This screws READCH when TYI returns something
from reading at the end of a file that cannont be coerced to a string.


Date: 25 FEB 1980 1425-EST
From: Nis at MIT-AI (H. Keith Nishihara)
To: (BUG LISPM) at MIT-AI

re: ;;; 	 -*- Mode:Lisp; Package:User; Base: 8. -*- 

this mode line at the top of a file used to cause the compiler (qc-file-load ..) 
to use ibase 8 when reading the file  -- this no longer seems to be the case
on cadr-3  when ibase is set to 10.  in the lisp environment. Has something changed?
-- keith


Date: 24 FEB 1980 0321-EST
From: Moon at MIT-AI (David A. Moon)
To: (BUG LISPM) at MIT-AI

Someone deleted LISPM;CDMP QFASL.  Please refrain from biting the bag.

Date: 23 FEB 1980 2312-EST
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

The error handler seems to cleverly use PRINLEVEL to prevent me
from seeing anything about the code I am executing,
and gives me (as far as I know) no way of turning this "feature" off.
Furthermore, the feature of filtering out uninteresting
EVALs and fsubrs from interpreted code, though still documented,
no longer works.
This is on CADR 1.


Date: 23 FEB 1980 1546-EST
From: HIC at MIT-AI (Howard I. Cannon)
To: (BUG LISPM) at MIT-AI

I fixed PKGDCL to get SERIAL from LMIO1;

Date: 23 FEB 1980 1047-EST
From: JLK at MIT-AI (John L. Kulp)
To: (BUG LISPM) at MIT-AI

LMIO; was getting so full files couldn't be edited on it and it didn't seem
like there were very many copies any single file, so I moved SERIAL, SUPSER, and HACKS
to LMIO1 and installed links for the QFASL files (however some file somewhere
for recompiling the world might need to know about this?).

Date: 23 FEB 1980 0245-EST
From: Henry at MIT-AI (Henry Lieberman)
To: (BUG LISPM) at MIT-AI

In system 25.0, with microcode 612, on LISP Machine Two:

(ARRAY AN-ARRAY FIXNUM 1 1) complains that FILLARRAY was given 2D array, 
when it expected a 1D array.

(ARRAY AN-ARRAY T 1 1) has no such problem.



Date: 22 FEB 1980 2229-EST
From: moon at MIT-AI (David A. Moon)
Sent-by: ___043 at MIT-AI
Subject: missing 74s472 adaptor
To: (BUG LISPM) at MIT-AI

please ignore previous message, it has been located.

Date: 22 FEB 1980 2226-EST
From: moon at MIT-AI (David A. Moon)
Sent-by: ___057 at MIT-AI
To: (BUG LISPM) at MIT-AI

Where is the 74S472 adaptor for the prom burner?  Such things should never be removed
from 936!

JLK@MIT-MC 02/22/80 08:49:15
To: (BUG LISPM) at MIT-MC
QSEND is broken.  When you type ^C as it tells you, it just pheeps at you.
I sure wish people would be more careful when they change basic system
software (this is on  CADR1, I have no idea what system because I don't
want to go to the trouble to get out of my SUPDUP -- as I said a few
months ago, it would be a win to put the version number in the WHO line
so it doesn't take you 5 minutes to report a bug).


Date: 22 FEB 1980 0444-EST
From: cent at MIT-AI (Pandora B. Berman)
Subject: inventory
To: (BUG LISPM) at MIT-AI, TC at MIT-AI

the inventory has been completed (yes, finally). results in the form
of a list of parts needed to finish the build are in CADRPT;BUILD2 NEEDS.
it includes all parts needed for board stuffing, cables, and some other
misc. stuff. i think. (if anyone knows where hidden stores of any of
it are, plz speak up.)
cadr12 is currently fully stuffed except for 10pin 330ohm sips.
would responsible people (if there are any listening) plz order or
expedite this stuff?

TC: dummies needed for the rest of the build:
3 A
9 E	
10 G
10 H	
8 J	
18 L
16 M
3 N
as listed in CADRPT;PARTS >.
also, i have put together a listing of dips and their components
needed per machine; it resides in CADRPT;RC CHART.

all inventory stuff will now live in its own file in the 936 file cabinet.

MOON@MIT-MC (Sent by MOON5@MIT-MC) 02/21/80 17:25:21 Re: PRINLEVEL and the :PRINT operation
To: GLS at MIT-AI
CC: (BUG LISPM) at MIT-MC
So far it has been assumed that actors which accept the :PRINT
operation are atoms, so such issues don't apply.  If you have
non-atoms of this form, the PRINLEVEL (and many other!!) issues
will need to be dealt with.  I assume you can get by by binding
PRINLEVEL to (AND PRINLEVEL (- PRINLEVEL DEPTH)) where DEPTH
is the argument you are passed.

Date: 21 FEB 1980 1317-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

In system 25.0, with microcode 612, on LISP Machine Two:
Okay, winners, what is the official theory on dealing with PRINLEVEL
in conjunction with the :PRINT operation?  I understand that an internal
depth number is passed around.  Are you supposed to deal with that
by comparing it to PRINLEVEL, or just pass it along (and if so, how?
PRIN1 doesn't use it free -- it resets the depth to zero.  Is one
supposed to call SI:PRINT-OBJECT explicitly?) for SI:PRINT-OBJECT
to test?  Also, what if I want to use FORMAT?


ALAN@MIT-MC 02/20/80 23:08:08
To: (BUG LISPM) at MIT-AI
    Date: 20 FEB 1980 1259-EST
    From: GLS at MIT-AI (Guy L. Steele, Jr.)
    I observe that C-M-U seems to do something interesting in the error
    handler, but this is not in the <HELP> documentation.  Also, the
    documentation doesn't specify how you tell C-M-A and C-M-L which
    argument you want ...
Also, it seems that <return> and <line> are no longer with us, contrary
to the documentation on <help>.  (They used to be the same as C-P and C-N
I believe.)

Date: 20 FEB 1980 1536-EST
From: JLK at MIT-AI (John L. Kulp)
To: (BUG LISPM) at MIT-AI

In system 25.0, with microcode 612, on LISP Machine Five:

I think the default extension used in ARRAY-PUSH-EXTEND is a loss.  I was just being
screwed by the fact that LMIO1;PRESS  calls it without a 3rd argument (I have at least
fixed that) and I found that it was copying a 32k word array for every 64. word
extension (needless to say, it caused infinite paging...).  I suggest that a better
behavior for ARRAY-PUSH-EXTEND would be to double the size of the array, if its
current size is less than some magic ("BIG" array) threshold (say, somewhere between
1k and 10k words), and if its greater than this threshold, increase by a fixed
percentage (e.g. 20%) of the current size (this has the effect of growing the
increment size linearly with the size of the array).  Now I don't claim that this
is the best in all cases, but probably leads to more desirable behavior in the
case where the user doesn't specifically control it.  A constant increment is
almost never the right thing, statistically (because its only the right thing
when you know you are not going to need to expand the array much more).


Date: 20 FEB 1980 1259-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

In system 25.0, with microcode 612, on LISP Machine Two:
I observe that C-M-U seems to do something interesting in the error
handler, but this is not in the <HELP> documentation.  Also, the
documentation doesn't specify how you tell C-M-A and C-M-L which
argument you want (after about two minutes' experimentation I found
that using Control-numbers works, but the documentation gives
not the slightest hint).


Date: 19 FEB 1980 2233-EST
From: moon at MIT-AI (David A. Moon)
Sent-by: MMCM at MIT-AI
Subject: If your file-job goes away
To: INFO-LISPM at MIT-AI

It now sleeps for 5 minutes before killing itself, giving you a chance to
debug why it went away, or find a system programmer to do so for you.  Please do.

MOON@MIT-MC 02/15/80 17:58:49 Re: Going off half-cocked about SOME and EVERY
To: GLS at MIT-AI
CC: ALAN at MIT-MC, (BUG LISPM) at MIT-MC
There was a bug.  It is fixed now.

Date: 17 FEB 1980 2320-EST
From: CWH at MIT-AI (Carl W. Hoffman)
To: (BUG LISPM) at MIT-AI

SET-SYNTAX-FROM-DESCRIPTION should recognize symbols in the keyword package
when looking at its second argument, as in
(SET-SYNTAX-FROM-DESCRIPTION #/A ':ALPHABETIC)


Date: 15 February 1980 07:53-EST
From: "Guy L. Steele, Jr." <GLS at MIT-AI>
To: ALAN at MIT-MC
cc: GLS at MIT-AI, BUG-LISPM at MIT-MC

    Date: 15 February 1980 05:45-EST
    From: Alan Bawden <ALAN at MIT-MC>

        Date: 14 FEB 1980 0820-EST
        From: GLS at MIT-AI (Guy L. Steele, Jr.)

        In system 25.0, with microcode 612, on LISP Machine Two:
        	(SOME '(a b 1 c) #'numberp #'cddr)
        will claim that (FUNCTION CDDR) has an invalid function definition.
        Bazola!?

    This is because SOME and EVERY are not actually functions, they are special
    forms.  What you wanted to say was: (SOME '(a b 1 c) #'numberp cddr) which
    would expand into:

    	(DO ((SI:*L* '(a b 1 c) (cddr SI:*L*)))
    	    ((NULL SI:*L*) T)
    	  (AND (FUNCALL #'numberp (CAR SI:*L*))
    	       (RETURN SI:*L*)))

    (has its little problems doesn't it!)

    Now the 64k question is: is this what we really want?  I seem to remember
    that these are Interlisp compatibility crocks, is this the way they work in
    Interlisp?  Anybody out there actually know?

All this was my subtle way of pointing out that people still
are not dealing with functional arguments in a consistent way
on the LISP Machine.  If you don't believe in general evaluation
of some kind in the function position (which would make (#'CAR X)
behave correctly, i.e. the same as (CAR X)), then at least people
who write macros and things should take care to use FUNCALL or
something.  It's not exactly clear what INTERLISP does.  However,
SOME and EVERY aren't just crocks; they are useful.  I suggest
adopting them for the LISP Machine, but they should have their
syntax changed to resemble the MAPCAR series, so that multiple-
argument predicates can be used.  For example:

				;points are lists of numbers representing n-vectors
	(DEFUN POINT-WITHIN-HYPERCUBE-P (UPPER-LEFT-FRONT-ETC LOWER-RIGHT-BACK-ETC POINT)
	       (EVERY #'LESSP UPPER-LEFT-FRONT-ETC POINT LOWER-RIGHT-BACK-ETC))



Date: 15 February 1980 05:45-EST
From: Alan Bawden <ALAN at MIT-MC>
To: GLS at MIT-AI
cc: BUG-LISPM at MIT-MC

    Date: 14 FEB 1980 0820-EST
    From: GLS at MIT-AI (Guy L. Steele, Jr.)

    In system 25.0, with microcode 612, on LISP Machine Two:
    	(SOME '(a b 1 c) #'numberp #'cddr)
    will claim that (FUNCTION CDDR) has an invalid function definition.
    Bazola!?

This is because SOME and EVERY are not actually functions, they are special
forms.  What you wanted to say was: (SOME '(a b 1 c) #'numberp cddr) which
would expand into:

	(DO ((SI:*L* '(a b 1 c) (cddr SI:*L*)))
	    ((NULL SI:*L*) T)
	  (AND (FUNCALL #'numberp (CAR SI:*L*))
	       (RETURN SI:*L*)))

(has its little problems doesn't it!)

Now the 64k question is: is this what we really want?  I seem to remember
that these are Interlisp compatibility crocks, is this the way they work in
Interlisp?  Anybody out there actually know?

Date: 14 FEB 1980 2153-EST
From: jerryb at MIT-AI (Gerald R. Barber)
To: (BUG LISPM) at MIT-AI

In system 25.4, with microcode 613, on LISP Machine Six:
This one is a little involved:

When a qfasl file is loaded with no package explicitly specified someone
in the depths of FASLOAD (FASL-OP-FILE-PROPERTY-LIST) sets the :PACKAGE
property on the file group symbol to the package symbol.  However if the
function GET-FILE-LOADED-ID is not given a pkg when it is called it
depends on the :PACKAGE property of the file group symbol being the
package object, not the symbol, to find information about when the file
was loaded. 

The end result of all this is that if one calls LOAD-FILE-ALIST-MAP
without explicitly giving it a pkg arg then it calls GET-FILE-LOADED-ID
to find out when the file was loaded and it ends up believing it wasn't
loaded. 

I'm not sure I all understand the details of what is going on, is this a
bug, incinsistency or feature?


Date: 14 FEB 1980 1821-EST
From: XCONOS at MIT-AI (Alec Destry)
To: (BUG LISPM) at MIT-AI

    If you type <call> while in the function (load <filename>), load fails to
close the file before you receive control of the terminal.  Of course the file
object is lost.  This causes problems when I want to load another file.

Date: 14 FEB 1980 0820-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

In system 25.0, with microcode 612, on LISP Machine Two:
	(SOME '(a b 1 c) #'numberp #'cddr)
will claim that (FUNCTION CDDR) has an invalid function definition.
Bazola!?


Date: 14 FEB 1980 0358-EST
From: cent at MIT-AI (Pandora B. Berman)
Subject: the dir cadrpt;
To: (BUG LISPM) at MIT-AI

i have been using cadrpt; to store the inventory list and other miscellaneous
stuff relating to the contents of LISPMachines, how much we have or should
have, and how to make parts of things. there are also a lot of old
price/ordering lists there: are these still of any use? and if not, are they 
deletable?

MOON@MIT-MC 02/13/80 18:21:56
To: (BUG lispm) at MIT-AI
    Date: 13 FEB 1980 0820-EST
    From: Alan at MIT-AI (Alan Bawden)
    To: (BUG LISPM) at MIT-AI

    In system 25.1, with microcode 613, on LISP Machine Four:
    try typing:

    (eq '|aAAAAAAAAAAAAAAAAAAAAAAAA| '|AAAAAAAAAAAAAAAAAAAAAAAAa|)	;24 "A"s and 1 "a"

    the answer is T!  This is because INTERN calls STRING-EQUAL which is
    insensitive to case, and these two strings sxhash to the same thing!
This is fixed in the source.

Date: 13 FEB 1980 0820-EST
From: Alan at MIT-AI (Alan Bawden)
To: (BUG LISPM) at MIT-AI

In system 25.1, with microcode 613, on LISP Machine Four:
try typing:

(eq '|aAAAAAAAAAAAAAAAAAAAAAAAA| '|AAAAAAAAAAAAAAAAAAAAAAAAa|)	;24 "A"s and 1 "a"

the answer is T!  This is because INTERN calls STRING-EQUAL which is
insensitive to case, and these two strings sxhash to the same thing!

Date: 11 FEB 1980 1346-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

In system 25.0, with microcode 612, on LISP Machine Two:
LOGNOT and LOGOR are not defined functions!  (Yes, I know LOGIOR is defined;
but, dammit, that is not the standard name for that and never has been.
See the LISP 1.5 manual and others.)


Date: 8 FEB 1980 0258-EST
From: HENRY at MIT-AI (Henry Lieberman)
To: (BUG LISPM) at MIT-AI

Using a symbol whose function cell is an array
as argument to ASET works interpretively, but
not compiled.

(DEFUN ARRAY-BUG ()
       (ARRAY AN-ARRAY T 1)
       (ASET 'ARRAY-ELEMENT 'AN-ARRAY 0)
       (PRINT (AREF 'AN-ARRAY 0)))

The compiled version complains about a wrong
type arg.

MOON@MIT-MC 02/07/80 22:42:20 Re: Henry's $0.02 on packages
To: HENRY at MIT-AI
CC: (BUG LISPM) at MIT-MC
About 5 seconds of thought will reveal why this scheme doesn't work.
What if a function in one package calls a function in another package?

Date: 7 FEB 1980 2122-EST
From: GYRO at MIT-AI (Scott W. Layson)
Subject: fonts
To: (BUG LISPM) at MIT-AI

I got the fonts back mentioned in previous message, with help of HIC.
Thanx anyway.

Date: 7 February 1980 15:08-EST
From: Howard I. Cannon <HIC at MIT-MC>
To: JLK at MIT-MC
cc: BUG-LISPM at MIT-AI

DO NOT WARM BOOT AFTER INITIALIZING THE NCP, run the function
(LISP-REINITIALIZE).  You should avoid warm booting if at all possible.


Date: 7 February 1980 14:03-EST
From: John L. Kulp <JLK at MIT-MC>
To: BUG-LISPM at MIT-AI

In case anyone makes the same mistake I did, I forgot that you must
warm boot after initializing the NCP...


Date: 7 FEB 1980 1238-EST
From: JLK at MIT-AI (John L. Kulp)
To: (BUG LISPM) at MIT-AI

ON CADR 1, in 25.1 when I try to load EFTP by the prescribed sequence, once
I have done the (CHAOS:INITIALIZE-NCP-ONCE) all subsequent attempts to
load files die with a "Packet has no connection" error.
Specifically, I do
COLD-BOOT
(setq user-id 'JLK)
(si:sb-on '(:clock))
(load "ai:moondr;draw pkg")
(setq chaos:server-alist nil)
(load "ai:lmio;chsncp")
(load "chsaux")
(chaos:initialize-ncp-once)
(pkg-load 'DRAW)

and it dies.

JONL@MIT-MC 02/07/80 12:17:53 Re:  Your rejoinder on keywords
To: DLW at MIT-MC
CC: (BUG LISPM) at MIT-MC
    Date: 7 FEB 1980 0612-EST
    From: DLW at MIT-AI (Daniel L. Weinreb)
    Subject: Double standard for keywords
    To: JONL at MIT-MC
    CC: (BUG LISPM) at MIT-AI
    Jonl, when Dave said the colon is necessary, you misunderstood him. To
    say that the colon is necessary does NOT mean that leaving it off is
    *guaranteed* to fail.  Just because it might woak is no contradication
    . . . 
Well, foo, how deep can this get!  I'm not trying to make any technical 
contradiction, but merely point out that the propogated standard hasn't in 
fact taken hold, and that's made life much harder for us poor blokes who're
trying to share compatible system-software.   There has been a lot of 
discussion around the lab here recently about whether or not to switch to a 
keyword package - I don't know if you've been aware of all the arguing going 
on - but Moon's comment shows him to be strongly on one side of the issue, 
and I'm on that same side too.  Yet, it still hasn't happend that the issue 
is settled, and it won't be until the other side acquiseces and the whole 
group (as MMcM so succinctly put it) "bites the bullet" and loads up again.
   Incidentally, in some of my mail last week, I may have misrepresented 
RMS's position  -  I talked about "his idea of making the keyword
package a superior of the USER package".  Unless he's changed his mind,
he's not in favor of this one, due to potential "shadowing" problems.

Date: 7 FEB 1980 0952-EST
From: GYRO at MIT-AI (Scott W. Layson)
Subject: fonts
To: (BUG LISPM) at MIT-AI

Would someone please regenerate, or tell me how to regenerate, the qfasls
for lmfont;hl12, hl12i, and hl12b?  I use these frequently and have become quite
font of them.

Date: 7 FEB 1980 0627-EST
From: DLW at MIT-AI (Daniel L. Weinreb)
Subject: My $0.02 on packages
To: HENRY at MIT-AI, (BUG LISPM) at MIT-AI

These issues have been thought about.  I suggest you speak to either
Sussman or Steele about the function similarities of the package system
and the lexical binding mechanism of SCHEME.  This is a complex subject,
probably deserving serious and hard research.

Date: 7 FEB 1980 0612-EST
From: DLW at MIT-AI (Daniel L. Weinreb)
Subject: Double standard for keywords
To: JONL at MIT-MC
CC: (BUG LISPM) at MIT-AI

Jonl, when Dave said the colon is necessary, you misunderstood him To
say that the colon is necessary does NOT mean that leaving it off is
*guaranteed* to fail.  Just because it might woak is no contradication
to what Dave said.  What is means is that the colon is DEFINED to be
necessary; we TELL you in the MANUL that it is necessary; we make
absolutely no guarantees what will happen if you leave it off.  The
contract between a system and its users is defined by the manual; the
system only guarantees to do what the manual says, and nothing else.
The manual is the contract between the user and the system.  This
is a very important concept.

I speak, of course, of the ideal case of an always-up-to-date manual
that is totally complete, but I am using the term "manual" in a
somewhat metaphoric sense; I think it is clear what I mean.

Date: 6 FEB 1980 2341-EST
From: HENRY at MIT-AI (Henry Lieberman)
Subject:  My $0.02 on packages
To: (BUG LISPM) at MIT-AI


My opinion is that the REAL problem with packages
is that the business of keeping separate name spaces
for independent programs shouldn't be done with the reader
at all! I think this is the root of the problem and won't
be solved regardless of the decision about a separate keyword 
package. I've had innumerable problems with this stuff dating
back to the obarray feature of MacLisp.

The purpose of packages is so that programs can have their
own private local functions and variables. It seems to me
the logical place to put this is in the function and variable
lookup mechanism, not with the mechanism the reader uses to 
create symbols. 

Here's a suggestion for doing this: 
The function and variable values for the current package are in 
the function and value cells, as usual. Values for other packages 
are in a data structure associated with the package. Thus a colon
would tell SYMEVAL and FSYMEVAL to look in the package rather than the
symbol. PKG-GOTO would swap the values between a package and
value cells of symbols.
(I realize this is very different than what's there now, and might
require incompatible changes.)

This scheme has the property that it doesn't interact with the
reader (or printer) at all, so there's ABSOLUTELY no problem with keywords, 
or typein!

Date: 6 FEB 1980 2219-EST
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

Please, don't think that I made a suggestion that the keyword
package be the superior of the user package.

I mentioned it only because I was explaining that it doesn't work.
Unfortunately, nobody seems to have noticed the explanation of
why it doesn't work, and everyone is now going off gung ho to
implement it, not realizing that it is a screw.

I think that we want these three goals:
Naive users should be able to write code without realizing that
packages exist;
Such code should be compatible with Maclisp when it uses functions
which exist in Maclisp;
The cold boot should not have to contain a list of all the keywords
that can EVER exist.

The only way to satisfy all these goals is to make the user package
be the same as the keyword package.  I don't want to try to defend
this statement here because defending it involves dealing with each
possible alternative individually, but the reason why it does not
work to make the keyword package the superior of the user package
is that this sequence of events is possible:

FOO is a keyword used by a function which isn't loaded.
The system as booted contains no calls to that function, and there is
no FOO in KEYWORDS yet.
1) the user happens to type FOO for some other reason.
FOO now exists in USER.
2) the user loads the file which defines that function.
FOO now exists in KEYWORDS.
3) the user tries to call the function using the keyword FOO.
However, he gets the FOO in USER rather than the one in KEYWORDS.

This can only be prevented if KEYWORDS starts out containing all the
symbols it is ever going to contain, just like GLOBAL and SYSTEM.
It's true we have GLOBALIZE for GLOBAL, but that uses forwarding.  It
will work for function symbols but it won't work with keywords, which
need to be EQ.

All this was thought about in great detail before the package system
was designed, and if you have any plans to change it you should manage
somehow to retrieve that file and see why the other alternatives were
discarded.  Unfortunately, I can't remember the name of the file, but
it probably started with PACK.  It was on LMDOC.

Date: 6 February 1980 20:09-EST
From: Alan Bawden <ALAN at MIT-MC>
To: JONL at MIT-MC
cc: BUG-LISP at MIT-MC, BUG-LISPM at MIT-MC

    Date: 6 FEB 1980 0838-EST
    From: JONL at MIT-MC (Jon L White)

    ...

     A partial solution is for ALAN to re-install DEFSHARP so that any file
    which thinks it needs this security could do its own local definition
    for "#:", and we could propogate a general prohibition for using "#:"
    for anything else until the question has been fully settled.  (By the bye, 
    I'd really like to see DEFSHARP be defaulty loaded - it is now with the
    maclisp SHARPM file).

I really don't see why a special form for defining sharpsign macro
characters is any better than SETSYNTAX-SHARP-MACRO which is a
function that can be called to set up a new sharpsign macro.  When I
originally wrote DEFSHARP for my own sharpsign macro in MacLisp, it
was intended to be an internal convience macro since I was going to be
defining a lot of sharpsign macros at the same time.  I had no
intention that it should escape beyond the bounds of that file.

MOON@MIT-MC 02/06/80 19:59:49
To: GLS at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date: 6 FEB 1980 1722-EST
    From: GLS at MIT-AI (Guy L. Steele, Jr.)
    To: (BUG LISPM) at MIT-AI
    CC: GLS at MIT-AI

    In system 25.0, with microcode 612, on LISP Machine Two:
    When you get an undefined-function error in the evaluator, it is
    EXTREMELY ANNOYING that when you type Control-R to the error
    handler you are asked for a value to return from SI:*EVAL,
    rather than a new function.  In general when some quantity
    is in error, Control-R should take a new quantity to replace
    the defective opne, and not decide to return from some arbitrary place.

c-C is the command for performing that operation.  c-R means specifically,
"return a value from the selected frame".  c-C also likes to "fix the error"
by defining the function; we should probably have another command
which fixes this specific error but doesn't define the function, setq
the variable, etc.

Date: 6 FEB 1980 1722-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

In system 25.0, with microcode 612, on LISP Machine Two:
When you get an undefined-function error in the evaluator, it is
EXTREMELY ANNOYING that when you type Control-R to the error
handler you are asked for a value to return from SI:*EVAL,
rather than a new function.  In general when some quantity
is in error, Control-R should take a new quantity to replace
the defective opne, and not decide to return from some arbitrary place.


Date: 6 February 1980 16:11-EST
From: Howard I. Cannon <HIC at MIT-MC>
Subject:  Double standard for keywords
To: JONL at MIT-MC
cc: MMCM at MIT-MC, MOON at MIT-MC, BUG-LISP at MIT-MC,
    BUG-LISPM at MIT-MC

I STRONGLY agree, as I have for a long time, that the keyword and user
package should be seperate.  Having the keyword package be a superior
of user seems fine to me.  We shoulD DEFINITLY bite the bullet and do this.


Date: 6 FEB 1980 1610-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

In system 25.0, with microcode 612, on LISP Machine Two:
In the error handler read-eval-print loop, two more commands
are desirable:
(a) <FORM> should clear the screen and re-prompt with "".
Currently if you type <FORM>, it sits there, a second one
clears the screen and re-echoes "<FORM>", and then you can
rub out the first <FORM>, but that's the best I have found.
(b) There should be a command to re-print the error message.
Sometimes I have forgotten what it was after doing Meta-B
or whatever.


Date: 6 FEB 1980 1347-EST
From: JONL at MIT-MC (Jon L White)
Subject: Double standard for keywords
To: MMCM at MIT-MC, MOON at MIT-MC
CC: (BUG LISP) at MIT-MC, (BUG LISPM) at MIT-MC

  Date: 6 February 1980 12:54-EST
  From: Mike McMahon <MMCM at MIT-AI>
  Subject:  Bridging the colon gap 
  It is a total crock that the keyword package is the same as the user package.
  I understand that it was moderately convenient at the time it was first im-
  plemented, and that it avoided some problems in the cold load; however these
  should have gone away long ago.  Teaching users not to put in the colons is
  decidedly a bad practice, it can only lead to their confusion, and as well 
  not allow for MACLISP compatible code outside of the user package. Unless
  there are nearly insurmountable problems i am not aware of, i propose biting
  the bullet and fixing this at the same time as the other incompatible changes
Yes, this is precisely the problem - that the system began without the colons,
then *some*, but not all users began using the, leaving us in the current
state where both are needed.  Had the colon (or better yet, package prefix)
been necessary earlier, we wouldn't be in this state now.  
  Date: 6 February 1980 13:31-EST
  From: David A. Moon <MOON at MIT-MC>
	    "The problem, as you remember, is that many people are 
	  confused as to how to type keywords - most believe that the colon is 
	  necessary."
  No, Jonl.  The colon IS necessary, and if any believe otherwise they
  are the ones who are confused.  The fact that it sometimes works not
  to type it is a bug and a crock, it is still necessary.
As your comments about the keywords to open show, the colon really isn't
necessary in user code - if it were, then maclisp would have no problem
with the "double standard".  Would you  (MOON) be in favor of MMcM's
suggestion to "bite the bullet"?

Date: 6 FEB 1980 1331-EST
From: MOON at MIT-MC (David A. Moon)
Subject: Keywords
To: (BUG LISPM) at MIT-MC, (BUG LISP) at MIT-MC, JONL at MIT-MC

This got left out of my previous message to (bug lispm) and jonl.

	  "The problem, as you remember, is that many people are 
	confused as to how to type keywords - most believe that the colon is 
	necessary."

No, Jonl.  The colon IS necessary, and if any believe otherwise they
are the ones who are confused.  The fact that it sometimes works not
to type it is a bug and a crock, it is still necessary.

MOON@MIT-MC 02/06/80 13:27:16 Re: Bridging the colon gap 
To: (BUG LISPM) at MIT-MC
CC: JONL at MIT-MC
Well, the issue here is the ability to run Maclisp code with
no modification.  Such code would of course always run in the
USER package, which is supposed to be the package in which you
can run without any knowledge that there are such things as packages.
I think the only reason the keyword and user packages were made
the same was so that code without colons (presumably code from
Maclisp) would work in the USER package.  I think RMS's suggestion
that the keyword package should be superior to the user package
rather than identical to it is the right thing; unfortunately
implementing it will require recompiling everything.

Now, Maclisp code that runs in packages other than the USER package,
such as Macsyma for instance, naturally needs some conditionalization.
It doesn't seem to me to be that big a problem to have to conditionalize
the very few functions that exist in both Maclisp and Lisp machine Lisp
and take keyword arguments; OPEN and TRACE are the only ones that immediately
come to mind.  Even SFAs are not compatible with Lisp-machine streams.
And when you come to user functions that want to take keyword arguments
(as opposed to functions already wired into Lisp), the colon should simply
be regarded as part of the spelling of the symbol.  In Maclisp it really
will be part of the print name, but in the Lisp machine it will put it
in the keyword package.

The ONLY difference between the Lisp machine colon prefix and a simple
naming CONVENTION based on colons in print-names, is that in the Lisp
machine if you are inside a package you may leave out the prefix, for
brevity.  But no one is ever supposed to be inside the keyword package,
that is, you are never supposed to leave off the colon prefix, which is
only 1 character anyway, so that does not apply in this case.

It would certainly be a win if the Maclisp reader were improved so that
you could write a Lisp machine compatible colon macro for Maclisp,
which did whatever you like with the stuff to the left of the colon.
But that's a refinement, and would make no difference to the particular
case of keywords, except for OPEN.

TRACE, being a user interface rather than a program interface, should
regard its keywords as strings rather than symbols, and accept them
in any package, and with spelling correction, for that matter.  Actually,
the S-expression interface to trace is the wrong thing anyway, as we
have a display-oriented interface to trace which eliminates the need
to remember and type all these stupid keywords.

I don't understand what use #: would be.  It seems like there are very
few cases were you could use it by itself, and if you have to conditionalize
something else anyway, you might as well conditionalize any sumbols you
have with colons in them as well.

Note- at present in the Lisp machine system the whole issue has been
circumvented by globalizing the keyword options to OPEN (as well as a
large number of others for reasons having to do with the cold-load
which are no longer true), so that you get the same symbols no matter
what package you are in and whether or not you write the colon.

So what's all the fuss about, anyway?

Date: 6 February 1980 12:54-EST
From: Mike McMahon <MMCM at MIT-AI>
Subject:  Bridging the colon gap 
To: BUG-LISPM at MIT-AI
cc: JONL at MIT-MC

It is a total crock that the keyword package is the same as the user package.
I understand that it was moderately convenient at the time it was first
implemented, and that it avoided some problems in the cold load; however these
should have gone away long ago.  Teaching users not to put in the colons is
decidedly a bad practice, it can only lead to their confusion, and as well does
not allow for MACLISP compatible code outside of the user package.  Unless
there are nearly insurmountable problems i am not aware of, i propose biting
the bullet and fixing this at the same time as the other incompatible changes.

Date: 6 FEB 1980 1241-EST
From: Agre at MIT-AI (Philip E. Agre)
To: (BUG LISPM) at MIT-AI

In system 25.1, with microcode 613, on LISP Machine Four:
In ZWEI Text Fill mode, when you do M-Q in the middle of:

modelling techniques form the basis of the proposed work.  
.sp 6 
This report describes research done at the Artificial Intelligence
Laboratory of the Massachusetts Institute of Technology.  Support for
the laboratory's artificial intelligence research is provided in part by
the Advanced Research Projects Agency of the Department of Defense under
Office of Naval Research contract N00014-75-C-0643.  The author's
graduate research and study are supported by a fellowship from the
Fannie and John Hertz Foundation.  
.page
Acknowledgements: I have been working out these ideas over a period

you get:

modelling techniques form the basis of the proposed work.  
.sp 6  This report describes research done at the Artificial
Intelligence Laboratory of the Massachusetts Institute of Technology.
Support for the laboratory's artificial intelligence research is
provided in part by the Advanced Research Projects Agency of the
Department of Defense under Office of Naval Research contract
N00014-75-C-0643.  The author's graduate research and study are
supported by a fellowship from the Fannie and John Hertz Foundation.   .page
Acknowledgements: I have been working out these ideas over a period


Also, ZWEI does not seem to understand the local modes page at the end of
my file, which sets Auto Fill Mode to 1, in EMACS anyway.

Date: 6 FEB 1980 1101-EST
From: jerryb at MIT-AI (Gerald R. Barber)
To: (BUG LISPM) at MIT-AI

In system 25.0, with microcode 612, on LISP Machine Five:

Why was the font LMFONT:PRT12B deleted?  I have brought it back
from backup.  Was this an unintentional deletion or a result of
somebodies garbage collection.


JONL@MIT-MC 02/06/80 09:28:06 Re: setsyntax-sharp-macro
To: ALAN at MIT-MC
CC: (BUG LISPM) at MIT-MC
The documentation I found showed "SET-SYNTAX-/#-MACRO-CHAR", and at
one point, I found "SETSYNTAX-SHARPM-MACRO" funboundp, but I see
now that it is standard.  Apologies for earlier complaint, but
I'd still like some kind of compatible (macro) DEFSHARP too.


Date: 6 FEB 1980 0838-EST
From: JONL at MIT-MC (Jon L White)
Subject: Bridging the colon gap 
To: HIC at MIT-MC
CC: ALAN at MIT-MC, (BUG LISP) at MIT-MC, (BUG LISPM) at MIT-MC

This "keyword package" question has given rise to a number of
kludgy partial solutions, but none seems to have fully taken hold
yet - until one does, we'll likely encounter complaints, such as
yours (below) against "#:" , and I'd like to take this opportunity
to apprise the bug-lisp/bug-lispm communities of the basic problem.
    Date: 6 February 1980 01:53-EST
    From: Howard I. Cannon <HIC at MIT-MC>
    I suggest not having this.  It seems like a total kludge to me, and
    I see no reason to snarf this either A) ambiguous, or B) potentially
    useful # macro character.  I find it hard to believe that the MacLisp
    reader can't be hacked to throw away everything before a : in a symbol,
    if some flag was turned on, or somesuch.  This seems like a more
    appropriate place for a the kludge.
For MACLISP, we wouldn't want just to throw away the prefix of a colon - 
for example, it is quite desirable for SI:MUMBLE and CL:MUMBLE to be
distinct symbols.  The problem, as you remember, is that many people are 
confused as to how to type keywords - most believe that the colon is 
necessary.  Until it actually becomes necessary (e.g., having a separate 
keyword package), there exists the necessity in MACLISP of having something
which a user can write which will work both now and in the future.
"FOO" is the current state, and if the keyword package happens,  then ":FOO"
or "KEY:FOO", is the future state;  for the LISPM, there is no trouble in 
bridging this gap, but maclisp can't bridge it simply by tossing out the 
colon prefix arbitrarily.  That's why the selectivity of the kludgy "#:" 
is needed.  
   A partial solution is for ALAN to re-install DEFSHARP so that any file
which thinks it needs this security could do its own local definition
for "#:", and we could propogate a general prohibition for using "#:"
for anything else until the question has been fully settled.  (By the bye, 
I'd really like to see DEFSHARP be defaulty loaded - it is now with the
maclisp SHARPM file).
   Another possible solution is RMS's, namely just get people to stop 
putting colons in front of keywords, and let system-programmers take
their lumps about distinguishing the keyword when in the SI package.
This has the desirable feature that all keywords appear *without* colons,
but it may be hard to turn the hands of the clock back to state where
this can be standardized.
   Finally, it might be noted that this is not exclusively a maclisp
compatibility problem (although prominently so now), but in any situation 
where one wants to say, *selectively*, "use the package feature, if enabled",
some such "feature" would be desirable.

ALAN@MIT-MC 02/05/80 21:50:30 Re:  #:
To: INFO-LISPM at MIT-AI
CC: JONL at MIT-MC

Yes, that's right!  Its time to put another # macro character up for
approval!  This time it is "#:".  This one does nothing in the
LispMachine reader, but in MacLisp it throws away all characters
untill another ":".  This is so that people can write compatable code
with package prefixes for the LispMachine and MacLisp ("#:SI:FOO" read
as "SI:FOO" on the LispMachine and as "FOO" in MacLisp.)

Suggestions, barfage, etc. are welcome.

Date: 5 February 1980 21:42-EST
From: Alan Bawden <ALAN at MIT-MC>
To: JONL at MIT-AI
cc: BUG-LISPM at MIT-MC

    Date: 5 FEB 1980 0744-EST
    From: JONL at MIT-AI (Jon L White)

    In system 25.1, with microcode 613, on LISP Machine One:
    I've been trying to use  #:...   which I thought ALAN was
    going to put into the LISPM reader.  

I wasn't aware that it was part of the MacLisp reader.  It was presented
to me in my mail as a proposed change.

					 Also, there doesn't
    seem to be a DEFSHARP macro for easy use with SET-SYNTAX-/#-MACRO

Let me remind you that we agreed that the compatable interface would be the
function SETSYNTAX-SHARP-MACRO which I did implement in a compatable way.


KMP@MIT-MC 02/05/80 14:36:58
To: (BUG LISPM) at MIT-MC
The LISPM compiler complains of the following being obsolete. The manual
doesn't list them as such and I'm confused about what to use.

EXPLODEN, EXPLODEC, IMPLODE -- What is the 'approved' way of mapping down
			       a character's print name? aref and a do-loop?

STATUS, SSTATUS -- Since the time the manual came out, I have seen new status
		   operations introduced on the LispM. The idea of making
		   extensions to obsolete functions seems odd to me.
		   In any case, I am using STATUS options FEATURE, DAYTIME,
		   DATE, and DOW. Perhaps others. What is the sanctioned
		   way of handling this sort of information or is STATUS
		   really right and the compiler message just wrong.

If compiler diagnostics for obsolete functions would just say something
like "MUMBLE is an obsolete function -- See doc on NMUMBLE." things would
be a whole lot easier to update. 

-kmp


Date: 5 FEB 1980 1402-EST
From: JLK at MIT-AI (John L. Kulp)
To: (BUG LISPM) at MIT-AI

In system 25.1, with microcode 613, on LISP Machine Four:

In ZWEI, if you rubout a CRLF, about 50% of the time a blinker is left turned on
at the beginning of the next line (where the cursor was before the deletion).


Date: 5 FEB 1980 0744-EST
From: JONL at MIT-AI (Jon L White)
To: (BUG LISPM) at MIT-AI

In system 25.1, with microcode 613, on LISP Machine One:
I've been trying to use  #:...   which I thought ALAN was
going to put into the LISPM reader.  Also, there doesn't
seem to be a DEFSHARP macro for easy use with SET-SYNTAX-/#-MACRO


Date: 5 FEB 1980 0001-EST
From: Zvona at MIT-AI (David Chapman)
To: (BUG LISPM) at MIT-AI

In system 25.0, with microcode 612, on LISP Machine Five:
There seems to be a problem with esc-q. As far as I can make it out, it is as follows.
If you warm boot before the xgp process finishes, it is put in a FLUSHED state but not
removed from active-processes. This means that not only does one not get the output but
also the process hangs around stealing enough time to substantially degrade performance.
Maybe this would be fixed by the NWS or maybe it can be fixed directly or maybe the background
hardcopy function is too fragile to put on esc-q.

Date: 4 February 1980 16:43-EST
From: Glenn S. Burke <GSB at MIT-ML>
Subject: #+LISPM on ITS
To: KMP at MIT-MC, BUG-LISP at MIT-MC
cc: BUG-LISPM at MIT-ML, "(FILE [GSB1;CONDIT CRUFT])" at MIT-ML

When we designed a conditionalization feature for LSB, it was decided
that anything that had to understand a "foreign" syntax in order to
flush it was a loss.  We do it by
  {predicate any-text-at-all-with-balanced-curly-braces}
The predicate is read by READ and evaluated.  (ONLY-FOR LISPM) is
like #+LISPM.  If it evals to NIL, the text is flushed (splicing readmacro
style);  otherwise it is left there, and global flag hacks cause the matching
right brace to disappear (but it will act as a break).
The restrictions are that this conditionalized structure is a reader
break, and that the contained text must have matching braces.  There
is currently no way to "quote" them, so if one or the other must appear
in the text, a matching one should be placed nearby, appropriately
commented out.  (I think midas has crocks like this, but i'm not sure.)
The feature is that no understanding of the stuff being conditionalized
is necessary.  This greatly simplifies the usage in the long run, and
tends to prevent screws like the one you mentioned, even if only by
limiting their number to those that come from not balancing the braces
or something like that.  (The one i ran into using #Q was conditionalizing
the readin of a small-flonum.)
    I'm not necessarily advocating the adoption of something like this,
but i would be greatly grossed out if hacks were put in to "sort of"
make the sharpsign conditionalization work this way.  Then again, if
people want this as a general feature, the conditionalization stuff
could be separated out of LSB.


Date: 4 FEB 1980 1336-EST
From: cpr at MIT-AI (Chris Ryland)
To: (BUG LISPM) at MIT-AI

In system 25.3, with microcode 613, on LISP Machine Six:
Mouse tracking stopped; warm boot did nothing useful; cold worked.
/CPR


Date: 4 FEB 1980 1023-EST
From: kmp at MIT-AI (Kent M. Pitman)
To: (BUG LISPM) at MIT-AI

If I do Set Fonts in Zwei and the new font does not fit in integral units
of the old one on the page, stale data is left on the last line of the buffer
which there wasn't room for the new font to fit over the top of. That area
should get cleared. If I do <Form> the image of it disappears but until then it
is highly confusing. -kmp


Date: 4 February 1980 03:46-EST
From: Howard I. Cannon <HIC at MIT-MC>
To: KMP at MIT-MC
cc: BUG-LISPM at MIT-MC

Telnet on ITS uses the arpanet.  :SUPDUP AI /ARPA will use the arpanet
on ITS.  On the Lisp Machine, you can specify a path to be used for
Telnet/Supdup, but I'm not sure whether (SUPDUP 'AI<alt>MC) really does
the right thing.  Instead of kludging, though, it seems to me that you
should find someone to fix AI.


KMP@MIT-MC 02/03/80 22:52:27
To: (BUG LISPM) at MIT-MC
Why is it that this evening when the AI Chaos-11 wasn't working well (as
far as I could tell, anyway) -- I could not access AI from either LISPM
supdup or LISPM telnet yet from MC I could access AI from telnet though
not supdup... I suspect this means that it is using AI as a stepping stone
to ARPA in some way. Can it be told that using MC when AI is down is a good
thing so I don't have to go through double <Break>'s etc to Arpa-connect
w/ AI. -kmp


Date: 3 FEB 1980 2107-EST
From: CWH at MIT-AI (Carl W. Hoffman)
To: (BUG LISPM) at MIT-AI

1) TV-COMPUTE-MOTION and TV-STRING-LENGTH both have the misfeature
that when the current font is variable width (the slow loop is being used),
the length of the string is computed relative to the zeroth font of
the font map rather than the pc-ppr-current-font, in the case where
8-bit characters are being used.

2) Neither function understands font shift characters.  Is this for
efficiency reasons?  In the fast loop case, checking for this would
happen outside of the inner loop so I don't see how it would hurt.

3) In the top loop of TV-STRING-OUT, the local variable FONT is not
updated when the font changes.  This causes several bugs which are hard
to describe.

These problems also exist in the new window system.


Date: 3 FEB 1980 2044-EST
From: KMP at MIT-MC (Kent M. Pitman)
Subject: #+LISPM on ITS
To: (BUG LISP) at MIT-MC
CC: (BUG LISPM) at MIT-MC

This bothers me:
On ITS, #+LISPM <form> causes all the symbols in <form> to get INTERN'd even
on ITS because the real reader is called. 
Less annoying, but an artifact of the same problem, is that
#+LISPM #.(PRINT 'FOO) will print FOO even on ITS. Must I really do
#. #+LISPM (PRINT 'FOO) #-LISPM () 
in order to win? I wonder if we shouldn't look into making the reader
recognize it's in a no-op state to suppress #. and INTERN and some of these
other things from really doing their thing. I don't want to do this in a
hackish way so am looking for suggestions for reasonable schemes. The main
intention being that I don't have to do a huge GCTWA when all done reading
some conditionalized file.
-kmp


Date: 2 FEB 1980 0125-EST
From: MOON at MIT-AI (David A. Moon)
Subject: If you use the file LMIO1;EFTP
To: INFO-LISPM at MIT-AI

You can no longer load this in the same way.  To load it now, first load LMIO1;EFTP
then do the following:
	(SETQ CHAOS:SERVER-ALIST NIL)
	(LOAD "LMIO;CHSNCP")
	(LOAD "LMIO;CHSAUX")
	(CHAOS:INITIALIZE-NCP-ONCE)
then warm-boot the machine.

The reason for all of this is that in the next system EFTP will be installed
as part of the default system.

Date: 1 FEB 1980 1148-EST
From: CPR at MIT-AI (Chris Ryland)
To: (BUG LISPM) at MIT-AI

I could be incredibly naive about this, but why, when you are using Zwei, eg,
and cons up a new supdup window with the mouse, Logout of supdup, do you
get bounced back to the top-level listener?


Date: 31 JAN 1980 1403-EST
From: CWH at MIT-AI (Carl W. Hoffman)
To: (BUG LISPM) at MIT-AI

The window system in 21.7 is so broken as to be completely unusable.
21.7 is the only system available on cadr-5.


Date: 31 JAN 1980 1322-EST
From: CPR at MIT-AI (Chris Ryland)
To: (BUG LISPM) at MIT-AI

In system 25.0, with microcode 612, on LISP Machine Nine:
This lispm is apparently getting power hits, since the screen does big glitching
every so often.  One of them wedged it this morning, and the result was a disk
not-ready condition.


Date: 30 JAN 1980 1836-EST
From: app at MIT-AI (Alex P. Pentland)
Sent-by: ___015 at MIT-AI
To: (BUG LISPM) at MIT-AI

On cadr 3 I discovered that the MIN and MAX functions blow up for some
sets of perfectly good input. On looking at the definitions of MIN and MAX
in system internals, they contain an apparent mistyping: they won't work as
listed. Thje nature of the blowup is different for the compiled and the
interpreted code; the compiler gives a message like "arg not a number"
because it's getting NIL as the argument.  The interpreter gives a different
message.  I don't remember the exact strings of numbers that blew up, it
you really need it I can regenerate them.   APP@AI

Date: 30 JAN 1980 1432-EST
From: JONL at MIT-AI (Jon L White)
Subject: CADR-1 dropping dead
To: MOON at MIT-AI
CC: (BUG LISPM) at MIT-AI, RHB at MIT-AI

I'm unable to find the exact code which when compiled from a ZWEI
buffer caused CADR-1 to stop (no bells, whistles or whatever),
but it was during the period between 08:55 and 10:44 of Jan 29
when the AI machine was down;  I had filed away teh ZWEI buffer
at those two points, and continued to edit during AI's illnesses
by warm booting.  By the time AI came alive again, I had edited
out whatever caused it to lose, and can't seem to recreate it;
but RHB witnessed the event twice with me, so it seems not to
have been a fluke.

Date: 29 JAN 1980 1836-EST
From: tk at MIT-AI (Tom Knight)
Sent-by: CARL at MIT-AI
To: (BUG LISPM) at MIT-AI

EDIT-DEFINITION from the zwei editor menu bombs (in 21.2), while <meta>X edit
defintion does not die.

MOON@MIT-MC 01/28/80 06:02:48
To: Gyro at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date: 27 JAN 1980 1017-EST
    From: Gyro at MIT-AI (Scott W. Layson)
    To: (BUG LISPM) at MIT-AI
    
    In system 25.0, with microcode 612, on LISP Machine Six:
    In lmfont;hl12i, the system thinks the character "d" is one pixel narrower than
    it actually is, so that when one types a character after it the far right-hand
    scan column gets cut off.  I would fix this if I knew how to use fed...

This is difficult or impossible to fix.  The problem is that it is an
italic font.  In italic fonts it is legitimate for the width of a character
to be less than the width of its "ink".  In other words, the characters
are closer together than the width of their raster.  In other words,
the upper right hand corner of a character is to the right of the lower
left hand corner of the next.  But the editor tends to do an erase to
end of line before redisplaying part of a line in order to update
the display; in the case of an italic font this erases the upper right
hand corner of the last character in the unerased part of the line.
There is no good way to fix this, although there are several mediocre
ways, for instance partial-line redisplay could be inhibited when
such a font (or overstriking!) is in use.

In general, please do not "fix" system fonts or programs without prior
discussion via bug-lispm.

Date: 27 JAN 1980 2349-EST
From: SHIPMN at MIT-AI (David W. Shipman)
To: (BUG LISPM) at MIT-AI

The functions sin, cos, and sqrt return full floats when given small-floats as args.

Date: 27 JAN 1980 1017-EST
From: Gyro at MIT-AI (Scott W. Layson)
To: (BUG LISPM) at MIT-AI

In system 25.0, with microcode 612, on LISP Machine Six:
In lmfont;hl12i, the system thinks the character "d" is one pixel narrower than
it actually is, so that when one types a character after it the far right-hand
scan column gets cut off.  I would fix this if I knew how to use fed...

Date: 26 JAN 1980 1529-EST
From: Gyro at MIT-AI (Scott W. Layson)
Subject:  saving files when ITS is down
To: (BUG LISPM) at MIT-AI

In system 21.7, with microcode 604, on LISP Machine Five:
When I attempt to save a file on ML, when it (or AI?) is down, I get a message
to the effect that the file has been modified since I last saved it on disk, and
asking whether to saye it anyway.  This has happened a couple of times on different
CADRs, but I don't remember whether they were all system 21.7 or not.  I am quite sure
that neither time had the file actually been modified.

I don't really understand the implications of the fact that SUPDUP goes through AI
to get to ML, so I don't know whether what's actually happening is that ML is really
down or that AI is down so I can't talk to ML.


Date: 26 JAN 1980 1152-EST
From: RICH at MIT-AI (Charles Rich)
To: (BUG LISPM) at MIT-AI

The directories 

LISPM, LISPM1, LISPM2, LMCONS, LMIO, LMIO1, LMMAN, ZWEI, etc.

are due for a cleaning...   Thank you.

Date: 26 JAN 1980 1051-EST
From: JLK at MIT-AI (John L. Kulp)
To: (BUG LISPM) at MIT-AI

The new keyboards have arrived, and I am recording comments about bugs, etc.
which conceivably might get fixed in the next iteration.  Read MC:JLK;KBD NOTES
before reporting any new ones.  I will file all non-redundant responses there.
I realize that most of the useful comments will have to wait until the keyboards
are actually used, which will be a month or so yet (we are waiting for the
enclosures).

MOON@MIT-MC 01/26/80 10:15:09
To: zvona at MIT-AI
CC: (BUG LISPM) at MIT-MC, JLK at MIT-MC
    Date: 25 JAN 1980 2104-EST
    From: zvona0 at MIT-AI
    To: (BUG LISPM) at MIT-AI
    
    In system 25.0, with microcode 612, on LISP Machine One:
    Attempting to define a function NAME causes a spurious warning. This seems to be because
    the (cdr (package-cell-location 'name)) is #<Package GLOBAL> rather than USER. Natheless,
    (apropos) does not turn up any symbol in GLOBAL or anywhere else called NAME and 
    GLOBAL:NAME is unbound, has no function definition, no plist, and no description. The
    symbol NAME is not shadowed or otherwise declared by GLOBAL's package declaration. Bug
    or feature?
Let me start with an ad hominem argument: you should not log in explicitly
as zvona0; if I had not noticed and manually corrected the destination of
this message to zvona, it would never have gotten back to you.  You should
log in as zvona even if there are two of you, and let the system add the 0.

To answer your report.  The warning is not spurious; the symbol NAME is
global, so it is telling you that are defining this function for everybody,
not just for your own package as you might expect.  It is of course
not entirely satisfactory that it can do this only for function definitions
and not for other uses of symbols.  The symbol NAME appears in LISPM2;KWDPKG.
Most of these symbols are only global for historical reasons which no
longer remain valid, however you can easily see that making a symbol
un-global causes all sorts of compatibility problems since compiled
programs that formerly referred to the same symbol will now refer to
different symbols.  One of these days we should bite the bullet and
unglobalize these, forcing users to recompile many of their programs.

Date: 26 January 1980 09:39-EST
From: John L. Kulp <JLK at MIT-MC>
To: BUG-LISPM at MIT-AI

    Date: 25 JAN 1980 2104-EST
    From: zvona0 at MIT-AI
    Attempting to define a function NAME causes a spurious warning....
I would also like to know the answer to this.  I have seen it with a number of
other symbols like WIDTH, HEIGHT, SIZE, TOP, BOTTOM, LEFT, RIGHT to name a few.


Date: 25 JAN 1980 2104-EST
From: zvona0 at MIT-AI
To: (BUG LISPM) at MIT-AI

In system 25.0, with microcode 612, on LISP Machine One:
Attempting to define a function NAME causes a spurious warning. This seems to be because
the (cdr (package-cell-location 'name)) is #<Package GLOBAL> rather than USER. Natheless,
(apropos) does not turn up any symbol in GLOBAL or anywhere else called NAME and 
GLOBAL:NAME is unbound, has no function definition, no plist, and no description. The
symbol NAME is not shadowed or otherwise declared by GLOBAL's package declaration. Bug
or feature?

Date: 25 JAN 1980 1702-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
Subject: Ease of use of arrays
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

I agree that lack of read/print capability is one stumbling
block to use of arrays in LISP.  I would suggest that this
is a special case of the more general problem that there
aren't a lot of high-level routines for dealing with arrays;
for example, things of the power of MAPCAR, ASSOC, and so on.
NIL has defined a lot of functions for use on its VECTOR
data type.  Maybe also some functions should be borrowed
from APL.

Date: 25 JAN 1980 0230-EST
From: DLW at MIT-AI (Daniel L. Weinreb)
To: sipb at MIT-MC
CC: (BUG LISPM) at MIT-AI

Hi.  The rest of us (DLW, JMB, LSP and HWC) who were here in Livermore
during the earthquake are all fine, as is everyone I know.  There has
been some damage to lab buildings, but not any of our buildings and not
to any holding anything dangerous; the lab got closed today for
extensive building inspection, and now that they have determined which
buildings are dangerous, they have reopened everything else.  {ur
apartments are all OK--all that happened to mine is that my slasses
were knocked to the floor.  But I can tell you, it was one hell of a
way to wake up.  Very exciting for a minute there...

Date: 24 JAN 1980 0923-EST
From: MOON at MIT-AI (David A. Moon)
Subject: (STATUS FEATURE STRING)
To: INFO-LISPM at MIT-AI

There was a typo which spelled this (STATUS FEATURE STRINGS).  It has been
corrected; the correction will appear in system 26.0.  I hope no one cares.

Date: 24 JAN 1980 0837-EST
From: Moon at MIT-AI (David A. Moon)
To: (BUG LISPM) at MIT-AI

The chaos background process should not run interrupt functions when it
the machine is warmbooted and the chaosnet connections are closed.

Date: 23 JAN 1980 0542-EST
From: DLW at MIT-AI (Daniel L. Weinreb)
Subject: Feature "STRING" and "STRINGS"
To: JONL at MIT-MC
CC: (BUG LISPM) at MIT-AI

    JONL@MIT-MC 01/22/80 19:04:46 Re: Feature "STRING" and "STRINGS"
    Agreed, that the LISPM should be fixed, not only because
    "STRING" was first, but also that the other feature names
    are singular (i.e. BIGNUM).  But who's going to do it?
    Until that day comes, I'll just have the string package
    put both "features", and let the loser decide which to
    ask for.  

There is a typographical error in the Lisp Machine Manual; in the Lisp
Machine, the feature is called STRING just as it is in MACLISP.  See
LISPM;QMISC > for the initial value of the feature list.

Date: 23 JAN 1980 0320-EST
From: CENT at MIT-AI (Pandora B. Berman)
To: (BUG LISPM) at MIT-AI

anybody know where the current dc prints
are hiding? i need to compare them to my parts list
in preparation for the next (moby and badly needed)
inventoryH.

Date: 22 JAN 1980 0805-EST
From: JONL at MIT-MC (Jon L White)
Subject: Feature:  "STRING" or "STRINGS"
To: NIL at MIT-MC
CC: INFO-LISPM at MIT-MC

Multics maclisp has used (STATUS FEATURE STRING) to indicate the
presence of the string data type, whereas the LISPMachine uses
(STATUS FEATURE STRINGS).  Rees and others and I propose that NIL
have the status feature "STRING" to indicate the presence of all
the NIL string primitives, as described in MC:NIL;NEWFUN >, and
have the status feature "STRINGS" to indicate the additional presence
of the named functions found on pages 79 thru 83 of the LISPM manual.
The maclisp STRING package will begin doing this too.
N.B.: Exceptions - NSUBSTRING wont be done, due to implementational problems
                   STRING wont be done, due to LISPM's inconsistent definition
Reasoning: status feature BIGNUM rather than BIGNUMS, etc for the
           basic data type capability.


Date: 21 JAN 1980 0619-EST
From: CWH at MIT-AI (Carl W. Hoffman)
To: (BUG LISPM) at MIT-AI

Typing (FUNCALL 1 1) at top level causes the error handler to have an error
while trying to print the stack frame.  It handles the (FUNCALL 1) cases
correctly.


Date: 20 JAN 1980 1732-EST
From: Agre at MIT-AI (Philip E. Agre)
To: (BUG LISPM) at MIT-AI

In system 21.7, with microcode 604, on LISP Machine Three:
I got CHAOS net lossage, packet in CHAOS:HOST-DOWN-STATE, "not a valid state",
in CHAOS:GET-NEXT-PKT <- SI:FILE-NEXT-READ-PKT.  This was with all interrupts
turned SI:SB-ON.  If you want, I can reproduce it for you personally (I hope;
it occurs at random places).


Date: 20 JAN 1980 0007-EST
From: DLW at MIT-AI (Daniel L. Weinreb)
Subject: arrays
To: (BUG LISPM) at MIT-AI

    Date: 19 JAN 1980 0341-EST
    From: rms,cwh at MIT-AI
    Sent-by: RMS at MIT-AI
    To: (BUG LISPM) at MIT-AI
    
    Maybe one reason why arrays in Lisp just don't seem as easy to use
    as they do in APL is that they don't print out as their components.
    
    Sometimes it would be a pain if arrays printed out as their components,
    but sometimes it would be a win.  Suppose there were a new array type
    for an array that would be like ART-Q but would print out as its components
    with a syntax that would read back into an EQUAL (so to speak) array.

My plan for solving this problem has always been to implement "hunks".
Hunks would be another array type, internally like ART-Q, but treated
differently by the reader and printer.  Furthermore, CXR and RPLACX and
HUNK or MAKHUNK or whatever and all those things would be defined for
Maclisp compatibility.  Finally CAR and CDR would work on hunks, also
for compatibility.  I realize it might seem silly to be compatible with
such a crock, but it should be considered.  In any case, the printed
notation for hunks might be a good one for a kinds of array that prints
and reads back, whether or not you put in the rest of the compatibility features.


Date: 19 JAN 1980 2347-EST
From: RMS at MIT-AI (Richard M. Stallman)
To: INFO-LISPM at MIT-AI

Can anyone think of a good name for a function which would return all
its arguments as values?  That is, 

(DEFUN FOO (&REST ARGS)
   (PROG () (RETURN-LIST ARGS)))

Date: 19 JAN 1980 1748-EST
From: Moon at MIT-AI (David A. Moon)
Subject: Slowness
To: (BUG LISPM) at MIT-AI

I have made changes (in the source) which will make the FINGER server
do substantially less paging and (I think) no consing.  This seemed
to be causing stoppage of the machine for several seconds when the
name dragon on AI asked it who was logged in.

Date: 19 JAN 1980 1318-EST
From: JlK at MIT-AI (John L. Kulp)
To: (BUG LISPM) at MIT-AI

If I type CALL while there is a typeout window on the screen (from either DRAW or ZWEI)
and something in the typeout window is reverse-videoed, it often causes the
LISP-LISTENER that I'm returning to, to get a black blob on its window at the
corresponding place (most likely a timing screw somewhere -- but all such lossage
will be fixed in the new window system, right?).  The same thing occassionally happens
with permanent menus.  It is not consistent, in that trying it several times in a
row doesn't always produce the same result (but it is reproduceable).


Date: 19 JAN 1980 0403-EST
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

As part of implementing PROG*, I've gone through the directories
LISPM, LISPM2, LMIO, LMIO1, LMWIN, ZWEI, NZWEI, LMCONS and LCADR
and changed all the PROGs which depended on order of binding
into PROG*'s.  There were only about 10 of them.
There is no need to recompile the changed files.
From now on, when you want to depend on sequential computation of
the initial values, please use PROG*.

Date: 19 JAN 1980 0341-EST
From: rms,cwh at MIT-AI
Sent-by: RMS at MIT-AI
To: (BUG LISPM) at MIT-AI

Maybe one reason why arrays in Lisp just don't seem as easy to use
as they do in APL is that they don't print out as their components.

Sometimes it would be a pain if arrays printed out as their components,
but sometimes it would be a win.  Suppose there were a new array type
for an array that would be like ART-Q but would print out as its components
with a syntax that would read back into an EQUAL (so to speak) array.

Date: 19 JAN 1980 0338-EST
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

WHo was it who commented out all the MULTIPLE-VALUE-RETURNs
in QFCTNS?  When?

Date: 18 JAN 1980 1051-EST
From: JONL at MIT-MC (Jon L White)
Subject: STRING coercion
To: GSB at MIT-MC
CC: NIL-I at MIT-MC, INFO-LISPM at MIT-MC, WELG at MIT-MC
CC: fahlman at CMU-10A

The maclisp string package now has STRING accepting a list as
argument, in which case it does something like
  (APPLY 'STRING-APPEND (MAPCAR 'STRING <list-argument>))
In particular, this means that STRING will work as a general
compress-list-of-characters/fixnums-into-string.   Would the 
LISPM be capable of extending the definition of STRING too?
(N.B.: the phrase "something like" means that it is only one
level deep - kludged for speed - thus (STRING '( (65. 66.) 67.))
loses, whereas (STRING '(ABC "def" 71.)) ==> "ABCdefG")
Note also the addition of helpfun functions STRING-EXPLODEN
and STRING-PRIN1, for the maclisp-without-nilaid world.


Date: 17 JAN 1980 2216-EST
From: DHD at MIT-AI (David Hodgson Dennis)
Subject: Free lispm TV display
To: (BUG LISPM) at MIT-AI

The display said that CADR-9, in 918A was free, when it was not operational.
Not sure how important this is, but you might want to investigate ways of
automatically compensating for defective lispms in the esc-F list.

Date: 15 JAN 1980 2103-EST
From: Agre at MIT-AI (Philip E. Agre)
To: (BUG LISPM) at MIT-AI

In system 21.7, with microcode 604, on LISP Machine Two:
 I created an 3072.x1536. ART-1B array A and did (BITBLT 0 3072. 1536. A 0 0 A 0 0)
to zero it out, and it never returned.  Is there a limit to the size of arrays
that BITBLT can handle?


Date: 15 JAN 1980 2006-EST
From: Agre at MIT-AI (Philip E. Agre)
To: (BUG LISPM) at MIT-AI

In system 21.7, with microcode 604, on LISP Machine Two:
 (i) Why shouldn't C-X 1 send you to the buffer that the cursor is currently active in?  
 (ii) When you C-S on a string beginning with a cr and there is no match, ZWEI sends
      you to the bottom of the file rather than feeping you.  If, in this state, you
      hit C-S again, you get feeped.


Date: 14 January 1980 17:11-EST
From: Howard I. Cannon <HIC at MIT-MC>
Subject:  Output holds and windows
To: JERRYB at MIT-AI
cc: AGRE at MIT-AI, BUG-LISPM at MIT-AI

Yes, perhaps having a enu around would be a good iea, and it would be 
basically trivial to do I suspect.  In the new window system, output hold
is just a message sent to a window, so....(actually, the standard handler
is pretty hairy, allowing you to send an arbitrary message to the window
when it tries to go into output hold..)


Date: 14 JAN 1980 1411-EST
From: RG at MIT-AI (Richard Greenblatt)
To: (BUG LISPM) at MIT-AI

System 25 is now installed on several machines.  This mainly incorporates
bug fixes and generalized updates, but there are some new functions and hooks.

 (1) Sequence breaks seem to work pretty well now.  It is recommended that all
   users turn them on.  They will be on by default in the next system.
   (SI:SB-ON '(:clock :chaos :keyboard)) turns on all interrupt sources.
   SI:SB-ON now does an ADD-INITIALIZATION so the interrupt-enable state
   is restored after a warm boot.
 (2) (MONITOR-VARIABLE sym &OPTIONAL current-binding-instance-only-p monitor-function)
   Arranges for the monitoring function to be called whenever the given symbol
   is SETQed.  Arguments supplied to the monitor function are the old value and
   the new value.  At the time the monitor function is called, the SETQ has already
   taken place. If monitor-function is not supplied, a simple default is used
   which just prints the old and new values.  If current-binding-instance-only-p is
   non-NIL, the monitoring applies only to the current instance of binding, ie
   if the symbol is rebound, SETQs affecting the new binding will not be monitored.
   When the original binding is eventually popped back, monitoring will resume.
   (UNMONITOR-VARIABLE sym) removes the monitor, (UNMONITOR-VARIABLE) removes all
   monitors.  A glitch in system 25 is that UNMONITOR-VARIABLE is not global and
   must be referred to in SI package.
     Note that only SETQ type operations are monitored.  BINDing type operations
   are not.
     Implementation note:  This feature is triggered by setting the FLAG bit in
   the value cell being monitored.
     Restriction:  It does not work to monitor variables which are forwarded to 
   A-MEMORY, such as INHIBIT-SCHEDULING-FLAG.  Monitoring closure, entity or
   instance variables works, although there is no convenient user interface to
   allow that currently.
 (3) The CHAOSnet receive process is flushed.  Instead, its top level function
   is called directly from the scheduler process.  This saves some time, and reduces the
   effective system working set.
 (4) Some slight changes have been made to the scheduler with the object of reducing
   the number of pages it touches.  A semi-visible consequence of this is that
   ACTIVE-PROCESSES is now an association list, with the process in the key position.
 (5) SI:SCHEDULER-HOOK, if non-nil, should be set to a function of one argument.
   The scheduler calls it every time it is about hand control to a process,
   supplying as argument the process about to be resumed. 
     SI:DEFAULT-SCHEDULER-HOOK-FUNCTION is a
   simple function suitable to put in SI:SCHEDULER-HOOK that will display the
   name of the process last resumed near the lower right corner of the screen.
 (6) (TV-STRING-OUT-EXPLICIT string xpos ypos) now exists.  This allows you to zonk a string
   directly onto a screen without worrying about windows, pieces of paper, locking
   problems or interactions with other code.  Format effectors are ignored.
     Since it does not turn off blinkers, etc
   funny things can happen on the screen itself.  The main intended use is in
   debugging.  The actual function takes a lot more (optional) arguments than shown
   here, which allow you to specify the font, alu-function, etc etc if you want.
 (7) When a PKG-LOAD results in more than one compilation, the compiler-warnings in
   the ZWEI buffer COMPILER-WARNINGS will be concatenated.

Date: 14 January 1980 11:47-EST
From: Gerald R. Barber <JERRYB at MIT-AI>
Subject:  Output holds and windows
To: HIC at MIT-MC
cc: AGRE at MIT-AI, BUG-LISPM at MIT-AI


I think the hooks should be there such that the output hold function can do
fairly general things.  For example one should be able to have a menu around
of windows that are on output-hold which is hard to do in a reliable fashion
in the present system.

Date: 13 January 1980 18:39-EST
From: Howard I. Cannon <HIC at MIT-MC>
Subject:  Output holds and windows
To: JERRYB at MIT-AI
cc: AGRE at MIT-AI, BUG-LISPM at MIT-AI

Yes, it would be possible to see which window the process that the
wholine reflects is waiting for.  (It would require symevaling self
in that process' stack group, I believe).  RMS may know a kludge to do
it in the current window system.  On the other hand, this is a kludge.
The problem is that there may be an arbitrary number of processes in
output-hold, and output-hold is a legitimate state for a process to
be in!  Therefore, it is not clear what the right thing to do is.


Date: 13 January 1980 18:19-EST
From: Gerald R. Barber <JERRYB at MIT-AI>
Subject:  Output holds and windows
To: AGRE at MIT-AI
cc: BUG-LISPM at MIT-AI

    Date: 13 JAN 1980 1446-EST
    From: Agre at MIT-AI (Philip E. Agre)
    To:   (BUG LISPM)

    A suggestion: when you get an output hold condition and you go to select
    a window, it would be nice if the menu of possible windows contained a marking
    indicating which window has the output hold condition.  

Unfortunately this is difficult in the present window system.  Output hold
functions are associated with pieces of papers and pieces of paper know
nothing of the windows they are part of.  In fact pieces of paper may belong
to windows that have gone away but where some stream has still hung on to the
piece of paper.  The new window system is strucuted in such a way (I
think/hope) such that this problem does not arise.

Date: 13 January 1980 18:20-EST
From: Howard I. Cannon <HIC at MIT-MC>
To: JLK at MIT-MC
cc: BUG-LISPM at MIT-MC, Agre at MIT-AI

Thanks for the public flailing -- being a masochist I truly appreciate it!!

The system was designed around the presumption that the Chaosnet does
not go down arbitrarily, and that a process ca get "interrupts" when
a Chaosnet  packet arrives.  These two premises are true on all other systems
that support the Chaosnet.  Unfortunatly, the Lisp Machine is not up to the
task of doing this -- no one turns on sequence breaks because they are
afraid everything will break (possibly a justifiable concern), and I can't
be expected to make the system be perfect under all possible circumstances.
(Next you will be asking me to make sure it dies gracefully when someone
pulls an arbitrary chip out of the processor -- it's VERY MUCH THE SAME
THING.  The system is expected to operate well under constraints which
are different from those that it was designed for.)  I will fix bugs of
this nature that arise when sequence breaks are on -- otherwise, I will
not WASTE my time making the system robust under unrealistic conditions.

The Lisp Machine as it currently stands IS A MARGINAL COMPUTING ENVIRONMENT,
and all users of it better understand that.  It's probably the best
environment there is in certain respects, but in others...we are
doing our damndest to fix it, but arbitrary flames to BUG-LISP, JLK, about
problems that I have already explained to you, is irresponsible and
wastes all of our time.


Date: 13 JAN 1980 1448-EST
From: Agre at MIT-AI (Philip E. Agre)
To: (BUG LISPM) at MIT-AI

In system 21.7, with microcode 604, on LISP Machine Five:
When you do (BUG) at the top level and then to c- to send the msg, you get
put in the editor in some other buffer rather than being returned to the
top level.  Is this a feature?


Date: 13 JAN 1980 1446-EST
From: Agre at MIT-AI (Philip E. Agre)
To: (BUG LISPM) at MIT-AI

A suggestion: when you get an output hold condition and you go to select
a window, it would be nice if the menu of possible windows contained a marking
indicating which window has the output hold condition.

Date: 13 January 1980 11:13-EST
From: John L. Kulp <JLK at MIT-MC>
To: Agre at MIT-AI
cc: BUG-LISPM at MIT-MC

I have mentioned similar problems to HIC, the file system maintainer,
and he claims users should not be suprised when this happens and
it is not a bug.  Perhaps this is true, but it certainly makes for
a marginal computing environment when every user has to know about
the dynamics of the chaos network, and have to repeat file operations
several times manually to get it to win.


MOON@MIT-MC 01/13/80 01:53:45
To: Agre at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date: 12 JAN 1980 2316-EST
    From: Agre at MIT-AI (Philip E. Agre)
    To: (BUG LISPM) at MIT-AI
    
    In system 25.0, with microcode 612, on LISP Machine One:
    I am trying to load in a very large file, and at some random time into the
    reading of the file, I get CHAOS net lossage of the following flavor:
    
    Attempt to get a packet from #<CHAOS Connection 7003750>, which is in
    CHAOS:HOST-DOWN-STATE, not a valid state.  While in CHAOS:GET-NEXT-PKT <- ...
    
    Neither AI nor my Lisp Machine was down, so I can't figure out the sense
    of this.  It's happened 5 times in a row with different amounts of the
    file read in.

You probably have something in your file that computes for more than
90 seconds without allowing interrupts.  Thus things time out and each
end thinks the other end is down.  Try turning on sequence breaks
(si:sb-on ':clock)

Date: 12 JAN 1980 2316-EST
From: Agre at MIT-AI (Philip E. Agre)
To: (BUG LISPM) at MIT-AI

In system 25.0, with microcode 612, on LISP Machine One:
I am trying to load in a very large file, and at some random time into the
reading of the file, I get CHAOS net lossage of the following flavor:

Attempt to get a packet from #<CHAOS Connection 7003750>, which is in
CHAOS:HOST-DOWN-STATE, not a valid state.  While in CHAOS:GET-NEXT-PKT <- ...

Neither AI nor my Lisp Machine was down, so I can't figure out the sense
of this.  It's happened 5 times in a row with different amounts of the
file read in.


Date: 11 JAN 1980 2218-EST
From: Moon at MIT-AI (David A. Moon)
To: (BUG LISPM) at MIT-AI

QSEND is broken in systems 22.0 and later.  However, you can ignore the inevitable
bug reports as I have fixed it in the source (LMIO;CHSAUX).

MOON@MIT-MC 01/11/80 17:23:37
To: HES at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date: 11 JAN 1980 1022-EST
    From: HES at MIT-AI (Howard Shrobe)
    To: (BUG LISPM) at MIT-AI
    
    In system 24.0, with microcode 612, on LISP Machine One:
    (ii) color:color-machine-list is not bound in the initial load. This used to be the
         way a program could tell if it was running on a machine with a color tv; was 
         the omitted by intention (if so what is the replacement?).
COLOR:(XBUS-LOCATION-EXISTS-P TV-COLOR-ADR 1)


Date: 11 JAN 1980 1022-EST
From: HES at MIT-AI (Howard Shrobe)
To: (BUG LISPM) at MIT-AI

In system 24.0, with microcode 612, on LISP Machine One:
(i) The variable concatenate-compiler-warnings-p (someting like that) is not bound in
    the initial load

(ii) color:color-machine-list is not bound in the initial load. This used to be the
     way a program could tell if it was running on a machine with a color tv; was 
     the omitted by intention (if so what is the replacement?).


GLS@MIT-MC 01/09/80 14:25:01
To: (BUG zwei) at MIT-AI
CC: gls at MIT-AI, (BUG lispm) at MIT-AI
All sorts of things go wrong with the file system if AI is down.
Presumably this should be all straightened out one day.  The current
screw is that in ZWEI I want to type C-X C-W MC:FOO;BAR BAZ <return>,
but typing C-X C-W causes it to try to calculate the default file
name, and it blows up trying to get the HSNAME from AI.  It can't
tell that intended to tell it MC anyway.  I got around it by
disassembling a lot of functions (can't look at the source code,
of course) and determining that I should clobber SI:LAST-FILE-DEVICE
or whatever it is called to "MC".


Date: 8 JAN 1980 1120-EST
From: KDF at MIT-AI (Ken Forbus)
To: (BUG LISPM) at MIT-AI

	Is there any good reason why roughly 610 blocks of our all too short
disk space are being tied up by what looks like backup files from a number of
lisp machine directories?  These files are on ROBIN;, a directory belonging to
Robin Stanton (authorized, by the way) and where written late one evening on the
21st of december....
	Ken

Date: 8 JAN 1980 1039-EST
From: Moon at MIT-AI (David A. Moon)
Subject: Question
To: (BUG LISPM) at MIT-AI

Should the interpreter pick up function definitions, particularly macro
definitions, temporarily made for purposes of the current compilation
when executing inside the compiler?  It doesn't do this now, but it seems
appropriate since otherwise if macros in a file use other macros in that
file, they will not work when compiling the file if it is not already loaded.
This happened to me with structure accessing macros.  Anyone have any opinions?

CWH@MIT-MC 01/07/80 23:33:46
To: (BUG LISPM) at MIT-MC
DEFVAR should accept a documentation string as its fourth argument.  For
that matter, it should be possible to include documentation strings in
DEFCLASS, DEFMETHOD, DEFSTRUCT, and other symbol definition forms.  The
documentation information may want to be more structured than just a simple
string, and perhaps a protocol should be designed which can be used and
extended by other subsystems.  But while tools may not currently exist for
viewing documentation strings from ZWEI or the error handler, DEFVAR should
accept them so that they can be included in new code.  I.e. we can write

(DEFVAR X 0.0 "current x position")

instead of

(DEFVAR X 0.0)  ;current x position

Is anybody thinking about compiling part of the manual from documentation
contained in the code?


Date: 7 JAN 1980 1454-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI

In the version of QSEND on system 22.1, with microcode 610, on LISP Machine Seven:
If I give QSEND a bad destination (but I thought "BKERNS@AI" used to work),
it just returns a string which is an error message, AFTER I type the message.
There is no clue as to how to recover without typing the whole stupid message.
(Actually, QSEND shoul;d be re-written to use ZWEI, like BUG does.)


Date: 5 JAN 1980 1552-EST
From: DLW at MIT-AI (Daniel L. Weinreb)
To: (BUG LISPM) at MIT-AI

The rash of bug reports that I just sent to various Lispm people
claimed to be from HIC but were really from DLW.  Sorry about that.

Date: 3 JAN 1980 2011-EST
From: DLW at MIT-AI (Daniel L. Weinreb)
To: (BUG LISPM) at MIT-AI

Previous TV-DRAW-LINE complaint was from DLW.

Date: 3 JAN 1980 2009-EST
From: MOON at MIT-AI (David A. Moon)
To: (BUG LISPM) at MIT-AI

There should be a function like TV-DRAW-LINE that clips the arguments
so that they will fit on the screen and then calls TV-DRAW-LINE.  This
is very important for random graphic hacks that people want to whip up
quickly, to prevent them from dying all over the place, in cases in which
the inefficiency of the clipping (not so terrible) is not very important.
This sort of thing is important for making Lisp Machines a truly convenient
programming environment.

MOON@MIT-MC 01/03/80 16:19:36 Re: Slight change in next world
To: info-lispm at MIT-AI
In the next Lisp machine system, the variable DEFAULT-ARRAY-AREA
will be gone.  In most cases you can use NIL to mean "allocate
storage in the default area".  Otherwise, use the variable
DEFAULT-CONS-AREA.  (Hopefully there are no user programs that
use this variable, but a warning seems in order.)

Date: 3 JAN 1980 1547-EST
From: PGS at MIT-AI (Patrick G. Sobalvarro)
To: (BUG LISPM) at MIT-AI


This one is slightly silly, but:

On CADR-8, running System 21.7, microcode 604, and on CADR-1 and
CADR-2, also running 21.7:

The function si:closure-variables is broken. It returns only the
first of the closure's variables. Looking at the source code, on
LISPM2; CLASS 68, one is unsure why it even does that, as there is
a misplaced paren in a do-loop:

;RETURNS LIST OF VARIABLES CLOSED BY A ENTITY
(DEFUN CLOSURE-VARIABLES (CLOSURE)
   (CHECK-ARG CLOSURE (OR (ENTITYP CLOSURE) (CLOSUREP CLOSURE)) "an entity or a closure")
   (DO ((L (CDR (%MAKE-POINTER DTP-LIST CLOSURE)) (CDDR L))
        (ANS NIL (CONS (%MAKE-POINTER-OFFSET DTP-SYMBOL (CAR L) -1)) ANS))
       ((NULL L) ANS)))

Fifth line should be:

        (ANS NIL (CONS (%MAKE-POINTER-OFFSET DTP-SYMBOL (CAR L) -1) ANS)))

Date: 3 JAN 1980 0208-EST
From: cent at MIT-AI (Pandora B. Berman)
Subject: new feature
To: (BUG LISPM) at MIT-AI

the hardware contingent of the LISPMachine factory is proud to announce
a new(?) feature which has been added to all machines: the pilot light.
this is an LED attached to the far upper right-hand corner of the
processor page. if the LED is lighted, the machine has power, and you
should be careful about playing with it. this feature will be added to
all future machines during manufacture.

Date: 1 JAN 1980 1643-EST
From: DLW at MIT-AI (Daniel L. Weinreb)
Subject: (mail)
To: (BUG LISPM) at MIT-AI

I just tried (MAIL) on the Lisp Machine in Moon & HIC's office with
the installed system.  It is highly unclear that this should put
you into ZMACS; the whole point of the ZWEI/ZMACS separation is that
subsystems that want to let the user edit text should NOT have
to go "into the editor".  It is even more dubious that when you quit,
you end up in ZMACS rather than the Lisp Top Level you came from.
I hope that the only reason this situation is tolerated is that it
will be fixed in the Great New Window System In The Sky.


Date: 30 DEC 1979 2013-EST
From: RMS at MIT-AI (Richard M. Stallman)
Subject: Axiom of Choice
To: INFO-LISPM at MIT-AI

The Axiom of Choice has been implemented.  To turn it on,
load LISPM2;CHOICE QFASL.  Enabling this axiom will allow
some programs to be greatly simplified, but may make others
impossible, so be warned.

Work on GCH is continuing but don't expect anything
for a few more months.

Date: 29 DEC 1979 2332-EST
From: CWH at MIT-AI (Carl W. Hoffman)
To: (BUG LISPM) at MIT-AI

We need a form for binding the filename defaults over a given scope.
For instance, if USER-FUNCTION is a function which may be typed from
toplevel and should default filename components, then it should be written
as:

(DEFUN USER-FUNCTION (FILE-NAME ...)
       ...
       (BIND-FILE-NAME-DEFAULTS
	  ;; In here are calls to functions which may change
	  ;; the file name defaults, such as LOAD.
	  (LOAD SOME-OTHER-NEEDED-FILE))
       ;; Here we want to default from the thing the user typed
       ;; previously, not from the call to LOAD.
       (MAKE-USE-OF (FILE-EXPAND-PATHNAME FILE-NAME)))

Likewise, calls to USER-FUNCTION from within other code would be enclosed
in a BIND-FILE-NAME-DEFAULTS.  Using this form is preferable to explicitly
binding FILE-DEFAULT-FN1, etc. since it is file system independent.


Date: 29 DEC 1979 1324-EST
From: MOON at MIT-AI (David A. Moon)
Subject: Speeding up I/O
To: (BUG LISPM) at MIT-AI

The file AI:MOON;FAST I/O contains a proposal for a simple microcode
assist which should eliminate the overhead caused by character at a time
I/O without complicating the interface seen by the user.  Comments?

Date: 29 DEC 1979 1203-EST
From: RG at MIT-AI (Richard Greenblatt)
Subject: #,
To: KEN at MIT-AI
CC: (BUG LISPM) at MIT-AI

  for eval at load time to make sense, it has to be
part of a quoted structure at compile time.  So you
want (defun foo nil ',#(+ 2 2)).  However, it does not
have to be at the "top level" which is why the quoting
action is not included in the #, .

Date: 28 DEC 1979 2124-EST
From: ken0 at MIT-AI
Subject:  #,
To: (BUG LISPM) at MIT-AI

the following function compiles ok in Zwei but not with qc-file
(defun foo nil
  #,(+ 2 2))

The compiler warns me
and when loaded I get the error
about si:**execution-context-eval** is undefined

I'm on cadr-4 system 21.8


cent@MIT-MC 12/21/79 09:50:16 Re: dips again
To: (BUG LISPM) at MIT-MC
i just took the last tube of 74S138s out of the stockroom; we use
10 per cadr so more are needed soon. also, i took out the last tube
of 74LS374s (39/cadr). this was grossly obviously marked as 
coming from Eli Hefron's, which caused me to remember a rumor a
while back about lossage involving parts from eli's. are these good,
or should they be tossed, or what? in any case there are no other
around, so we need more.

Date: 20 DEC 1979 0311-EST
From: RMS at MIT-AI (Richard M. Stallman)
Subject: DEFUN and local declarations
To: (BUG LISPM) at MIT-AI

DEFUN will now process ARGLIST and RETURN-LIST local declarations from
either an outside LOCAL-DECLARE or a DECLARE at the start of the body,
and put them into the debugging info of the NAMED-LAMBDA.

Also, any other local declarations from either source are put into a
DECLARE at the start of the body of the NAMED-LAMBDA, so that, for
example, any special declarations will be remembered if COMPILE is
used to compile the function later.

Date: 19 DEC 1979 1905-EST
From: RWK at MIT-AI (Robert W. Kerns)
To: (BUG LISPM) at MIT-AI

In system 21.6, with microcode 604, on LISP Machine Five:
(SUPDUP 'MC) fails, and puts "SUPDUP -- not connected" at the bottom, and
prompts for who to connect to.  I say AI, and it connects me, but doesn't
update the "not connected" at the bottom of the window.


Date: 19 DEC 1979 1046-EST
From: XCONOS at MIT-AI (Alec Destry)
To: (BUG LISPM) at MIT-AI

Chaos:chaos-time is acting up on lisp-machine 5.

Date: 18 DEC 1979 1445-EST
From: CPR at MIT-AI (Ryland)
To: (BUG LISPM) at MIT-AI

This may be a silly comment, since I am just trying the LISPMs for the first real time,
but it seems that when you're mousing a menu, the mode line should have something
more informative than just NIL as the state.  How about MENU-WAIT or some such?

Date: 16 December 1979 23:45-EST
From: Howard I. Cannon <HIC at MIT-MC>
To: KEN at MIT-AI
cc: BUG-LISPM at MIT-AI

    Date: 16 December 1979 23:00-EST
    From: Kenneth Kahn <KEN at MIT-AI>
    To:   BUG-LISPM at MIT-AI

    It would be nice when the system is going down for people on the lisp machines
    to be told.  Perhaps one's file job could do it?
Such a feature is planned for the near future.


Date: 16 DEC 1979 2300-EST
From: KEN at MIT-AI (Kenneth Kahn)
To: (BUG LISPM) at MIT-AI

It would be nice when the system is going down for people on the lisp machines
to be told.  Perhaps one's file job could do it?

ALAN@MIT-MC 12/16/79 07:17:57 Re: ##
To: INFO-LISPM at MIT-MC
If I hear no objections I am going to flush ##.
(How could anyone object?)

We have had well over a year to flush out all occurences of ## so
any remaining ones can only be found by pulling out the rug.

(if you don't know what ## does suffice it to say that "##<space><char>"
is the same thing as "#/<char>".)

Date: 16 DEC 1979 0334-EST
From: RMS at MIT-AI (Richard M. Stallman)
Subject: local declarations
To: (BUG LISPM) at MIT-AI

A local declaration around an entire function definition can
now be written with a DECLARE as the first object in the body.
If there are both a declaration and a documentation string,
they can appear in either order (if anything checks for documentation
strings in interpreted functions, it needs to be fixed to do this).

Such local declarations work even in interpreted code.  This doesn't
matter for SPECIAL declarations but it could potentially matter for
other kinds.

A new local declaration (RETURN-LIST names) exists.  It specifies
names (as documentation only) for the values returned by a function.
This list will be the second value returned by ARGLIST.


Date: 14 DEC 1979 0131-EST
From: cent at MIT-AI (Pandora B. Berman)
Subject: 74LS257s
To: RG at MIT-AI
CC: (BUG LISPM) at MIT-AI

we are out of them. also we have no 74 257s to substitute.
please add to the list of things you harrass people to expidite
(they have been added to the white board list). 
priority: immediate. XBUS MEM 22 will have to go without
until we get more.

Date: 10 DEC 1979 1351-EST
From: RICH at MIT-AI (Charles Rich)
To: (BUG LISPM) at MIT-AI
CC: (BUG XGP) at MIT-AI

How about putting LMSCN's on SECOND: or VISION: (if available).
Otherwise five or ten of these waiting to be printed on .XGPR.;
can easily gobble up all available disk space.

Also, it might be logical to have these always printed as soon
as possible, since they are only 1 page, but take up a lot
of disk space.

	yt, Chuck.

MOON@MIT-MC 12/08/79 05:00:24
To: HOBBIT at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date: 8 DEC 1979 0117-EST
    From: HOBBIT at MIT-AI (John C. Gonzalez)
    To: (BUG LISPM) at MIT-AI
    
    In system 21.6, with microcode 604, on LISP Machine Five:
      Telenet has problems going from a LISP machine to Multics.
    Telenet apparently will work for MC and XX.  Although the connection
    is initiated and at first appears to work, as soon as you type a character
    a background process buffer (window) pops up into which you can't type anything
    until you reset it.

The bug here is that it is doing local echoing since Multics won't
echo itself, but the echoing is coming out on STANDARD-OUTPUT instead
of the Telnet window.  Someone should correct this.

Date: 8 DEC 1979 0117-EST
From: HOBBIT at MIT-AI (John C. Gonzalez)
To: (BUG LISPM) at MIT-AI

In system 21.6, with microcode 604, on LISP Machine Five:
  Telenet has problems going from a LISP machine to Multics.
Telenet apparently will work for MC and XX.  Although the connection
is initiated and at first appears to work, as soon as you type a character
a background process buffer (window) pops up into which you can't type anything
until you reset it.



Date: 6 DEC 1979 2325-EST
From: nm at MIT-AI (Neil Maron)
Sent-by: ___031 at MIT-AI
To: (BUG LISPM) at MIT-AI

if you do (eh current-process) and try to warm-boot out of it you are stuck and
have to cold-boot.

JONL@MIT-MC 12/06/79 16:48:38 Re: DEFVST and DEFSTRUCTURE
To: GLS at MIT-MC
CC: (BUG LISPM) at MIT-MC, NIL-I at MIT-MC
To reply to a point or two you made in your TTY message
[b] the default state of the constructor name is a verrry
    minor point since you can just do 
    #M (SETQ CONSTRUCTOR-NAMESTRING-PREFIX 'MAKE- 
             SELECTOR-NAMESTRING-STYLE () )
   and thus standardize on the LISPM style.
   I would like to see the LISPM provide these two global switches
   also.
[c] many of the hairier options can't be supported in maclisp
    (package stuff, for example), and its not clear that the
    "storeage type" options improve things in the maclisp world.
    But two areas *ought* to be compatible:
    [c1] (DEFSTRUCTURE SHIP ...) should be the same as
         (DEFSTRUCTURE (SHIP) ...)
    [c2] now that LDB is available in maclisp, DEFVST should 
         allow subfields of components with "byte-specs"
    As it happens, both DEFVST and DEFSTRUCTURE permit default
    values for components to be specified the same way, e.g.
    (DEFVST SHIP (SAILS 4)) like (DEFSTRUCTURE (SHIP) (SAILS 4))
    I would undertake to fix [c2] if someone in the LISPM
    community would fix [c1] and the point under [b] above.
[a] The fact that DEFVST  is not called DEFSTRUCTURE lies in
    the comment in the documentation, that as soon as NIL
    needs structures to reflect VAX File-Descriptor-Blocks,
    we will need a DEFBST (BITS-like structure); then
    the NIL/MACLISP version of a DEFSTRUCTURE can deal
   with the union of these more complicated objects.
Actually, far from being "flaming", your comments are
quite constructive, to get us to shape these things
up together.


GLS@MIT-AI 12/06/79 14:16:42
To: jonl at MIT-MC
CC: (BUG LISPM) at MIT-AI
DEFVST and DEFSTRUCT are *almost* compatible, but not quite,
and it is the fact that they are so close but not interchangeable
that is so annoying.  (Rant, rave!  But this has been an issue
for at least a year and still hasn't been fixed much.)
[a] The names ARE different.  LISPM doesn't recognize the name
DEFVST, and MacLISP doesn't recognize the name DEFSTRUCT.
[b] The default state is that constructor names begin with
CONS-A- for DEFVST, and MAKE- for DEFSTRUCT.
[c] The format of options lists is completely different for
the two, which makes it more difficult to fix [b].

I don't care whether DEFVST or DEFSTRUCT changes to accommodate
the other; I'd just like them to have some common, if small,
intersection which I can use without putting garbahge at the
front of every file I write which wants structures.

Date: 4 DEC 1979 1451-EST
From: TK at MIT-AI (Tom Knight)
To: (BUG LISPM) at MIT-AI

I strongly agree with GLS about the byte pointer issue.  The PPSS format is
a kludge.  If we want compatiblility for a while, fine, but new code should
be using a more legible form.

Date: 4 DEC 1979 1016-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
Subject: [1] LIST* [2] LOAD-BYTE
To: MOON at MIT-AI, JONL at MIT-MC
CC: GLS at MIT-AI, (BUG LISPM) at MIT-AI, (BUG LISP) at MIT-AI

[1] LIST* of zero arguments ought to be an error, as has
    already been pointed out.  I originally wanted (LIST* a) => a,
    but forget whether that was done originally or not.
[2] [a] Regarding byte pointers, the LISP Machine syntax still has the
    two severe disadvantages that (i) you can't parse it unless it is
    in octal notation, and (ii) the byte size is limited to 63 decimal.
    I have in the past suggested that a function BPTR be introduced
    such that (BPTR p s) takes two non-negative fixnums p and s and
    produces a byte pointer.  The nature of this pointer is machine-
    dependent, but may be given to the LOAD-BYTE etc. functions
    and be expected to work.  Probably also there would have to be
    functions BPTR-SIZE and BPTR-OFFSET to extract the s and p
    numbers from a byte pointer.
    The advantages of this are several.
    (i) Neither p nor s is limited in value by these definitions.
    (ii) The precise representation of a byte pointer can be machine-dependent
    for greater efficiency.  For example, the LISP Machine byte pointer
    format is not suitable for the VAX.
    (iii) When writing (BPTR p s) one can write p and s in whatever radix
    one pleases.
    [b] Regarding left-to-right versus right-to-left, I would suggest that
    bits always come out in right-to-left order *when converted to fixnums*
    for the reasons expounded by Moon.  Thus (LOAD-BYTE #B"0101100" (BPTR 2 3))
    produces the fixnum 6.  (Are not bits naturally numbered this way
    anyway in the VAX?)  For machine-@dependent crocks, a machine-dependent
    set of primitives may also extract byte in whatever way is convenient
    for the machine.
    The S-1 will store bits in left-to-right order (bag-biters they),
    but the compiler will gladly output bit-reverse instructions to keep
    this compatible interpretation (eliding them when possible).

Date: 2 DEC 1979 1702-EST
From: RG at MIT-AI (Richard Greenblatt)
To: (BUG LISPM) at MIT-AI

there is a bug in the time server which manifests itself if MC is
down.  Typically it bombs out when processing your init file that
turns on NWATCH.  Do (load "lmio;chsaux") to load the fix.  System
21.7 will have this fix loaded.

Date: 30 NOV 1979 0136-EST
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

PACKAGE-DECLARE doesn't ignore the case of characters in the filenames.

Date: 29 NOV 1979 1901-EST
From: RICH at MIT-AI (Charles Rich)
To: (BUG LISPM) at MIT-AI

Please clean directories 

LISPM, LISPM1, LISPM2, LMCONS, LMIO, LMIO1, LMMAN, ZWEI, etc.

There are literally hundreds of wasted blocks here, while 
people are pestered all day with messages from Comsat
to delete unnecessary files!!


Date: 29 NOV 1979 1759-EST
From: KMP at MIT-MC (Kent M. Pitman)
Subject: LIST*
To: MOON at MIT-MC, RWK at MIT-MC, HENRY at MIT-MC
CC: (BUG LISP) at MIT-MC, (BUG LISPM) at MIT-MC

MacLISP doesn't support (LIST*) [the zero-arg case]. While it is ``obvious''
that the 1-arg case has meaning, it is not so obvious the 0-arg case does.

(LIST* () () ()) => (() ())
(LIST* () ()   ) => (()   )
(LIST* ()      ) => (     )
(LIST*         ) => ??? ; I see nothing really logical to go here.

() may be a nice thing for LIST* of 0 args to return, just so it isn't
an error, but it hardly 'follows' from the others. It is indistinguishable
then from what (LIST* ()) does. I'm not altogether convinced that the zero-arg
case should be supported. Is the existance of (LIST* ,@X) with worries that
X might be NIL sufficient reason? Maybe so. I think I still need to be
convinced, tho'.
-kmp


MOON@MIT-MC 11/29/79 06:49:12 Re: LIST* with 0 or 1 argument
To: Henry at MIT-AI, (BUG LISP) at MIT-AI, (BUG LISPM) at MIT-AI
I have rectified this oversight on the Lisp machine (in the source
only).  I haven't tested it since there don't seem to be any Lisp machines
in the immediate vicinity out here.  I also rewrote the code to make
it readable and to remove a bug.  Bob, the reason the 0- and 1-argument
cases work out naturally in Maclisp and not in the Lisp machine is that
Maclisp lacks cdr-coding, allowing LIST* to be written as iterated
calling of CONS.

Date: 29 November 1979 01:56-EST
From: Robert W. Kerns <RWK at MIT-MC>
To: Henry at MIT-AI
cc: BUG-LISP at MIT-AI, BUG-LISPM at MIT-AI

    Date: 29 November 1979 00:41-EST
    From: Henry Lieberman <Henry at MIT-AI>
    To:   BUG-LISP at MIT-AI, BUG-LISPM at MIT-AI

    Since the trivial case for LIST is
      (LIST 'ONE-THING) is (ONE-THING)
    I think the trivial case for LIST* should be
      (LIST* '(ONE-THING)) is (ONE-THING)
    rather than complaining when given less than two args.
    Perhaps also 
      (LIST*) is NIL
    These cases would make (APPLY 'LIST* ...) work out more nicely.
Consider:
(LIST* () () () ) => ( () () )
(LIST* () () )	  => ( () )
(LIST* () )	  => ()

i.e. from right to left, each of the arguments before the last is NCONSd onto
the rightmost argument.

This is what MacLisp does.  I'm supprised the LISP Machine doesn't also
do this; it makes life easier for BackQuote....


Date: 29 NOV 1979 0154-EST
From: KMP at MIT-MC (Kent M. Pitman)
To: HENRY at MIT-MC
CC: (BUG LISP) at MIT-MC, (BUG LISPM) at MIT-MC

MacLISP does allow (LIST* <single-arg>) as an identity operator. Your
suggestions are what has been implemented for a long time... 


Date: 29 NOV 1979 0041-EST
From: Henry at MIT-AI (Henry Lieberman)
To: (BUG LISP) at MIT-AI, (BUG LISPM) at MIT-AI

Since the trivial case for LIST is
  (LIST 'ONE-THING) is (ONE-THING)
I think the trivial case for LIST* should be
  (LIST* '(ONE-THING)) is (ONE-THING)
rather than complaining when given less than two args.
Perhaps also 
  (LIST*) is NIL
These cases would make (APPLY 'LIST* ...) work out more nicely.


Date: 28 NOV 1979 1203-EST
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

We now have 8 file servers and the system is full
with nobody else doing anything gross.

Date: 22 NOV 1979 1453-EST
From: RG at MIT-AI (Richard Greenblatt)
Sent-by: RG0 at MIT-AI
To: (BUG LISPM) at MIT-AI

System 21 installed on CADR1.  It has the
last month's worth of fixes and improvements.

Date: 21 November 1979 23:28-EST
From: Robert W. Kerns <RWK at MIT-MC>
Subject:  ASSOQ and ASSQ and atoms
To: RMS at MIT-AI
cc: BUG-LISP at MIT-MC, NIL-I at MIT-MC, TLP at MIT-AI,
    BUG-LISPM at MIT-AI

When is it useful to allow non-null atoms in an ASSQ list?


Date: 21 November 1979 22:41-EST
From: Robert W. Kerns <RWK at MIT-MC>
Subject:  Mailing-lists
To: Scott at SRI-KL
cc: BUG-LISP at MIT-MC, BUG-LISPM at MIT-MC

The problem is that everybody in the world (almost) knows to send to
BUG-LISP for their MacLisp complaints.  While your idea is valid and
good, it is completely incompatible with the programs everybody has
in their heads....


MOON@MIT-MC 11/21/79 18:30:52 Re:  Missing TV-SELECT-SCREEN in window system
To: hes at MIT-AI
CC: (BUG LISPM) at MIT-MC
Your diagnosis is correct.  There should also be a WITHOUT-INTERRUPTS
enclosing the TV-OPEN-SCREEN, TV-SELECT-SCREEN, and TV-ERASE (in that
order).  I suggest that you fix this yourself by fixing the relevant
functions in the source, writing out the updated source, copying the
functions into a patch file, making sure it has a package:si in its
mode line, writing it out, compiling it, rebooting the machine, loading
the patch qfasl file, and disk-save'ing.

Date: 21 NOV 1979 1744-EST
From: hes at MIT-AI (Howard Shrobe)
Sent-by: JLK at MIT-AI
To: (BUG LISPM) at MIT-AI

there are two places in the file lispm2;window where a (tv-open-screen) is followed
by a (tv-erase) without an intervening (Tv-select-screen screen).  I believe this is
a bug which has led to problems that I've had on cadr2 which occur when there is an active
and exposed window on the color screen.  The typical sequence is that while popping down
a pop-up menu the system barfs with an error "attempt to erase past screen" (something like
that) in the function window-restore-1.

would a wizard who understands such stuff determine whether I'm right (or superstitious)
since this depends on understanding what the micro-code for tv-select-screen, etc. does.

The two fixes are in the function tv-restore-1 and in (window-class clean).

This has some importance for the ic graphics editor program so I would appreciate someone
checking this out and installing the patches, even though there is a whole new approach
to windows coming along soon.

Thanx muchly

howie.

Date: 20 NOV 1979 1638-EST
From: HENRY at MIT-AI (Henry Lieberman)
To: MESSAGE-PASSING-SEMANTICS at MIT-AI, (BUG LISPM) at MIT-AI

There's an article in the current ACM SigSmall magazine
about some guys who implemented a SmallTalk on a
(would you believe?!) Z-80. Not as good as Xerox's, of
course, by a long shot, but kind of astonishing that they
could do it at all.

Date: 20 Nov 1979 0809-PST
From: Scott at SRI-KL (Scott J. Kramer)
Subject: Re: ASSOC and ASSQ on lists with atomic entries
To: JONL at MIT-MC, TLP at MIT-MC, ALAN at MIT-MC, RWK at MIT-MC, RMS at MIT-MC
Cc: (BUG LISP) at MIT-MC, (BUG LISPM) at MIT-MC
In-reply-to: Your message of 20-Nov-79 0651-PST

In response to multiple mailing lists:  if implemented, they should be
named BUG-MACLISP, BUG-LISPM, BUG-NIL and BUG-LISP with the last being
bug mail pertaining to all LISPs.  Sounds reasonable?  (sorry for the
multiple copies on this)
			   Scott
-------


Date: 20 NOV 1979 0951-EST
From: JONL at MIT-MC (Jon L White)
Subject: ASSOC and ASSQ on lists with atomic entries
To: TLP at MIT-MC, ALAN at MIT-MC, RWK at MIT-MC, RMS at MIT-MC
CC: (BUG LISP) at MIT-MC, (BUG LISPM) at MIT-MC

1) as for maclisp, it appears to be a bug  in the manual that this
   isn't documented - the manual seems to imply that "association lists"
   must contain only dotted pairs.  The "feature" of maclisp's ASSQ 
   under which it really takes car of each item in the association
   list must be considered a speed kludge in the same cattegory as that
   of converting ATOM check for end of list in the various MAPs into
   a NULL check in compiled code;  one  could construct pathological
   cases which exploited/demonstrated this difference, but in fact in
   the 5+ years that it has been installed, there has never been a
   naturally-occurring complaing agains ASSQ/ASSOC.  (on the other hand,
   there have been a few complaints that compiled MAPs do not do the
   same endtest check as the interpreted version, i.e. that NULL has
   been substituted for ATOM).
2) the utility of being able to delete entries from an "association list"
   by means of RPLACAing them to (), rather than having to re-invent
   and/or open-code the mechanisms of DELETE, is supremely useful;  
   likely we should ensure that all of MACLISP/LISPM/NIL permit it.
3) some of us will receive multiple copies of this note, due to the
   mail-forwarding process - should we perhaps define a new mailing
   list which reaches BUG-LISP, BUG-LISPM, and NIL mailing lists?


Date: 19 NOV 1979 1726-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
Subject: File Mode Lines
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

I can't find a single place that document all of (or even ANY of)
the various things you can put in -*- brackets on the first line of
a file, such as Mode, Package, Ibase, Fonts (these are the ones I know
about right now).  Is there a single file somewhere?

Date: 19 November 1979 01:06-EST
From: Richard M. Stallman <RMS at MIT-AI>
Subject: ASSOQ and ASSQ and atoms
To: TLP at MIT-AI, BUG-LISPM at MIT-AI, RWK at MIT-MC,
    BUG-LISP at MIT-MC

Why in the world shouldn't ASSOC and ASSQ ignore atoms in the alist?
It's clearly useful, much more useful than getting an error, because
it makes those functions usable in situations where they would now be
worthless.  In fact people have functions called ASSQ-CAREFULLY, etc.,
on the Lisp machine which do precisely this.  Who would be screwed by
extending the functionality of ASSOC and ASSQ in this way?

Date: 18 November 1979 09:51-EST
From: Robert W. Kerns <RWK at MIT-MC>
To: ALAN at MIT-MC, TLP at MIT-MC
cc: BUG-LISP at MIT-MC, BUG-LISPM at MIT-AI

    Date: 14 November 1979 03:45-EST
    From: Alan Bawden <ALAN at MIT-MC>
    To:   BUG-LISPM at MIT-AI
    cc:   BUG-LISP

        Date: 13 NOV 1979 0925-EST
        From: TLP at MIT-AI (Tomas Lozano-Perez)

        Why doesn't ASSOC in LISPM LISP just ignore atoms in the
        list argument (like MacLisp does) instead of barfing by
        trying to take CAAR of them?

    Is this really a feature of MacLisp? I can't seem to find
    this in the moonual or in LISP NEWS or in the new MacLisp
    manual.  It does behave this way on both ITS and Multics,
    but I would have reported it as a bug if I had found out
    about it on my own.  It really is a shame that the
    LispMachine is forced to continue such lossages.  Another
    example is the MacLisp definition of new-style DO in the
    case where the second "argument" is nil, it executes the
    body just once!  This one is documented at least, but it
    sure is random!
The DO feature is at least useful ...

Anyway, ASSOC happens to behave this way, because it lets you use
'((A . B) NIL (C . D)) and have the NIL entry ignored.  This
ends up carrying over to symbols because it uses (ATOM X) instead
of (NULL X).  Lose, lose.  I think MacLisp should be changed...
even the feature of ignoring null entries is kind of marginal.
It should just do a null-check, like ASSQ does.

TLP:  If you're using ASSQ in MacLisp, it will LOOK like it's working, but
will merely be taking the CAR of the symbol, which is unlikely to match
your argument.  It is merely randomness that this isn't also true of
ASSOC.  I.e. your code is bugous.


Date: 17 NOV 1979 1755-EST
From: HENRY at MIT-AI (Henry Lieberman)
To: (BUG LISPM) at MIT-AI

The keyboard on the Lounge Lizard Lispmacho doesn't work.

Date: 17 NOV 1979 1209-EST
From: kmp at MIT-AI (Kent M. Pitman)
To: (BUG LISPM) at MIT-AI
CC: kmp at MIT-MC

Some random things...

(1) Why is there no LOGIN-FSET and/or LOGIN-DEFUN ...? Those would seem like
    reasonably useful things to have for init files.

(2) I got a message from DLW earlier and it offered to let me reply -- I typed
    a couple lines and went to rub out quite a bit of it -- the reader seems
    to have given up on me in the middle of those rubouts, tho' cuz it sent my
    partially-written message when I tried to rub back over a carriage return.
    Maybe it's just the keyboard (it was sending stray characters earlier) but
    maybe it is a software bug -- I'm sure I didn't hit anything close to control-c
    tho'...

(3) I need the ability to do pointer arithmetic as an atomic operation without
    having to worry that the garbage collector is going to relocate the array
    underneath me -- the kinds of things it would be nice to do are:

     (+ <locative> <fixnum>) => <locative>

    It is the case that this locative will live in a variable and I would like
    to be able to declare all this good stuff to the compiler. What are chances
    of being able to do any of this?

-kmp


Date: 16 NOV 1979 1658-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

In system 20.4, with microcode 600, on LISP Machine One:
The same thing sometimes happens with (BUG)!  If I am in a LISP-LISTENER window
but also have been in the editor, then after I do (BUG) and mail the bug,
I am left in the editor, not where I was.  This is annoying.  Sigh.


Date: 16 NOV 1979 1656-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI

In system 20.4, with microcode 600, on LISP Machine One:
The QSEND server seems to be non-transparent with respect to window-switching.
If I have two windows on my screen, and get interrupted by a QSEND server,
then sometimes I am left in the other screen.


Date: 15 NOV 1979 1305-EST
From: WELG at MIT-AI (W. Eric L. Grimson)
To: (BUG LISPM) at MIT-AI

It seems to me that having the lisp machines list keyboard idle time is perhaps
not the most optimal thing.  For people in the vision group, it is often the case
that the programs we run are very long, for example 1 hour - 2 hours.  The problem
is that if we start up a job like this, as soon as it stops running, the console
lists the keyboard idle time as 2 hours.  If someone comes along at this time, they
will reboot the machine and start using it, thereby destroying the results of that 
two hour computation.  Although it is possible to leave a note on the machine, asking
people not to use it, it seems like it might be more optimal to have the console list
machine idle time, rather than keyboard idle time.  Is it possible to change this?
Both ELN and I have been screwed by people taking our machine, thinking we hadn't used it
in the last 90 minutes, whereas, in fact, we had been running a very large program
and were still using the machine.
		- Eric

Date: 14 NOV 1979 1617-EST
From: RICH at MIT-AI (Charles Rich)
Subject: Please clean directories
To: (BUG LISPM) at MIT-AI

Sorry to bother you guys, but could you please clean
up the many LISPM directories.  At this moment there
are zero blocks free on all disks.  The Lispm directories
are a particular problem because they are nobodies
"personal" directory.
	Thank you,	Chuck Rich.

MOON@MIT-MC 11/14/79 15:53:09 Re: autoload on the lispmachine
To: Nis at MIT-AI
CC: (BUG LISPM) at MIT-MC
It works to call LOAD recursively, so you can have one file that consists
of a lot of things of the form
	(or (fboundp 'foo) (load "nis;foo"))
which check whether a certain file is loaded and if not load it.
The only case where autoload would be useful is if there are a lot
of things you want around but don't want to load because you aren't
likely to use them except occasionally.  We may put in autoload in
the next system or the one after that for the sake of this, it's not
terribly hard, but involves some improvements to the condition mechanism.

MOON@MIT-MC 11/14/79 15:49:52 Re: dumparrays and loadarrays on the lispmachine
To: Nis at MIT-AI, (BUG LISPM) at MIT-AI
Use one of the undocumented functions COMPILER:FASD-SYMBOL-VALUE
and COMPILER:FASD-FILE-SYMBOLS-PROPERTIES.  The former will put the
value of a single symbol into a qfasl file, while the latter is more
elaborate and takes a lot of arguments, but allows you to put a variety
of values and properties of several symbols into a qfasl file.  In either
case the resulting qfasl file can be loaded in the ordinary way.
As far as I know all types of arrays and numbers should work in qfasl
files; please complain if there are any problems.

MOON@MIT-MC 11/14/79 15:42:46 Re: small flonum contagion
To: Nis at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date: 14 NOV 1979 1201-EST
    From: Nis at MIT-AI (H. Keith Nishihara)
    To: (BUG LISPM) at MIT-AI
    
    re: small flonum contagion
    
    could the trig functions and sqrt be fixed so that when given 
    small flonum arguments they return small flonum results like 
    log and exp currently do.   
Yes someone should fix them.  This requires looking at the argument
to decide what precision of internal constants to use.
    also is it true that so long as no special variables are set that 
    computations on small flonums (using say log and exp in a compiled function
    where the results come and go to an art-q array)
    does not generate garbage?  what about the regular flonum case? 
    I guess what im asking is are there any useful rules of thumb for minimizing 
    garbage generation.  - keith
You're somewhat confused.  The actual situation is that use of small
flonums never generates any garbage (unless functions like log and exp
have internal large flonum intermediate results, which they shouldn't but may.)
Reading and printing small flonums very possibly generates garbage,
although I won't swear to it.

Large flonums and bignums will become permanent (i.e. generate garbage)
if you store them in any permanent place, including special-variable
values, list structure, arrays, etc., or if you have process scheduling
while holding onto temporary results.  (E.g. you read from the
keyboard.)  The only time they don't generate garbage is when temporary
results are only stored in local variables, passed as arguments, and
returned as single function-values.

Some time in the future things will be changed so that garbage will never
be generated by any use of objects other than hanging onto them for a long
time then discarding them.  However this has not been done yet.

Date: 14 NOV 1979 1201-EST
From: Nis at MIT-AI (H. Keith Nishihara)
To: (BUG LISPM) at MIT-AI

re: small flonum contagion

could the trig functions and sqrt be fixed so that when given 
small flonum arguments they return small flonum results like 
log and exp currently do.   

also is it true that so long as no special variables are set that 
computations on small flonums (using say log and exp in a compiled function
where the results come and go to an art-q array)
does not generate garbage?  what about the regular flonum case? 
I guess what im asking is are there any useful rules of thumb for minimizing 
garbage generation.  - keith


Date: 14 NOV 1979 1015-EST
From: Nis at MIT-AI (H. Keith Nishihara)
To: (BUG LISPM) at MIT-AI

re: dumparrays and loadarrays on the lispmachine
would it be possible to get something like maclisp's dumparrays 
functions on the lispmachine. BEE wrote us some functions for saveing
image files but we have no good means for saving say flonum arrays or multiple
arrays in a single file efficiently -- keith


Date: 14 NOV 1979 1009-EST
From: Nis at MIT-AI (H. Keith Nishihara)
To: HIC at MIT-AI, (BUG LISPM) at MIT-AI

re: autoload on the lispmachine
my need for autoload is not urgent ... i just thought it would nice to have around
if it wasnt to difficult to implement.  Its true one can have all ones files loaded
on a band of the lispmachine  but are there enought bands to go around so that i can
have one to myself on each machine that i use?  Also we are beginning to share many of
our software packages and in many cases id like to be able to tell someone to load
just one file to use, say, my graphing functions even though the graph package may
require some subroutines in another one of my files.. and i dont want to have to 
duplicate those subroutines in each file that uses them.  .. any thoughts on alternative 
ways to get around these problems? -- keith


Date: 14 November 1979 03:45-EST
From: Alan Bawden <ALAN at MIT-MC>
To: BUG-LISPM at MIT-AI
cc: BUG-LISP at MIT-MC

    Date: 13 NOV 1979 0925-EST
    From: TLP at MIT-AI (Tomas Lozano-Perez)

    Why doesn't ASSOC in LISPM LISP just ignore atoms in the
    list argument (like MacLisp does) instead of barfing by
    trying to take CAAR of them?

Is this really a feature of MacLisp? I can't seem to find
this in the moonual or in LISP NEWS or in the new MacLisp
manual.  It does behave this way on both ITS and Multics,
but I would have reported it as a bug if I had found out
about it on my own.  It really is a shame that the
LispMachine is forced to continue such lossages.  Another
example is the MacLisp definition of new-style DO in the
case where the second "argument" is nil, it executes the
body just once!  This one is documented at least, but it
sure is random! 

HIC@MIT-MC 11/13/79 16:20:43
To: GLS at MIT-AI
CC: (BUG LISPM) at MIT-MC
    Date: 13 NOV 1979 0950-EST
    From: GLS at MIT-AI (Guy L. Steele, Jr.)

    The new window system 20.5 now on CADR-6 seems to be hopeless.
    I got a ZWEI, then started a SUPDUP via mouse, and there was
    total confusion as to which window was selected for both redisp0lay and
    character input.
-----
Which "new" window system are you talking about?

If you mean the NEW window system (mine and mmcm's, as opposed to
RMS'), then you probably shouldn't have been using it as it
doesn't work completely yet.  If you mean simply an "updated"
copy of RMS', then this bug report is somewhat vauge.


Date: 13 NOV 1979 0950-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

The new window system 20.5 now on CADR-6 seems to be hopeless.
I got a ZWEI, then started a SUPDUP via mouse, and there was
total confusion as to which window was selected for both redisp0lay and
character input.

Date: 13 NOV 1979 0925-EST
From: TLP at MIT-AI (Tomas Lozano-Perez)
To: (BUG LISPM) at MIT-AI

Why doesn't ASSOC in LISPM LISP just ignore atoms in the
list argument (like MacLisp does) instead of barfing by
trying to take CAAR of them?

Date: 12 November 1979 22:48-EST
From: Mike McMahon <MMCM at MIT-AI>
To: JLK at MIT-MC
cc: BUG-LISPM at MIT-AI

    JLK@MIT-MC (Sent by JLK0@MIT-MC) 11/12/79 18:17:45
    Would someone please fix the LISP machine software in general, and SI:FILE-USER-ID-HSNAME
    in specific, not to have the string "AI" compiled in as the machine to use.  This
    makes LISP machines unusable when AI is down which is a screw for users that
    have most of their files on MC.  Also, it is all going to have to be changed
    when the file computer exists, so why not generalize it now.
"AI" is only the default argument to that function, all the callers i know about give it
the correct machine.  Doing (LOGIN'MMCM'MC) works completely for me.  If you don't say
"MC", then it has to assume some default of course, and that is "AI" for the time being.

JLK@MIT-MC (Sent by JLK0@MIT-MC) 11/12/79 18:17:45
To: (BUG LISPM) at MIT-AI
Would someone please fix the LISP machine software in general, and SI:FILE-USER-ID-HSNAME
in specific, not to have the string "AI" compiled in as the machine to use.  This
makes LISP machines unusable when AI is down which is a screw for users that
have most of their files on MC.  Also, it is all going to have to be changed
when the file computer exists, so why not generalize it now.


Date: 10 NOV 1979 0330-EST
From: RMS at MIT-AI (Richard M. Stallman)
To: (BUG LISPM) at MIT-AI

I have installed my version of QCP2.
Also, I have defined PROG*.  PROG is still unchanged.
When the running system actually includes PROG*,
I'll start converting PROG's to PROG*'s as appropriate.

Date: 10 NOV 1979 0132-EST
From: KMP at MIT-MC (Kent M. Pitman)
Sent-by: ___036 at MIT-MC
Subject: LAMBDA*
To: ALAN at MIT-MC
CC: (BUG LISPM) at MIT-MC, (BUG LISP) at MIT-MC, NIL at MIT-MC

No, FEXPR's lose utterly -- you couldn't compile

 (LAMBDA (&QUOTE X Y Z)
		 &AUX A) ; You left this var out, I'll assume it was implied
	 (SETQ A (EVAL X) A (EVAL Y) A (EVAL Z))
	 (1+ A))

correctly (or at all) unless your compiler is CONSIDERABLY smarter
than I think it is ... There's no hint of what's getting EVAL'd!

 ((LAMBDA* (A A A) <body>) <arg1> <arg2> <arg3>)

would be the same as ...

 ((LAMBDA (A) ((LAMBDA (A) ((LAMBDA (A) <body>) <arg3>)) <arg2>)) <arg1>)

Then LET* could just turn into a LAMBDA* ... 

I'm not sure if I'm serious or not. I'm also not sure if it matters. I thought
I would throw it out for laughs, comments, or consideration and see if someone
could help me make up my mind ...

If anyone gives this any serious consideration, they'll have to also address
what ((LAMBDA* (A A &OPTIONAL (B 1)) A) (* 0. B)) means ... or even worse
((LAMBDA* (A &OPTIONAL (A A))...) ...) and/or
((LAMBDA* (A &OPTIONAL (A A) &AUX (A A)) ...)...) mean ...

I guess I'm probably not serious ... 
-kmp


Date: 10 November 1979 01:09-EST
From: Alan Bawden <ALAN at MIT-AI>
Subject: PROG* and related forms
To: KMP at MIT-MC
cc: BUG-LISPM at MIT-AI, BUG-LISP at MIT-AI, NIL at MIT-MC

    Date: 10 NOV 1979 0048-EST
    From: KMP at MIT-MC (Kent M. Pitman)

    Could we introduce a LAMBDA* operator which did bindings sequentially? 
    Consider the following form, which returns the value 4.

    ((LAMBDA* (A A A) (1+ A)) 1 (1+ A) (1+ A))

Are you serious?  You must be kidding.  You can't really mean this.
Consider:  what does (LAMBDA* (A A A) (1+ A)) mean under your scheme?
It would have to be the equivalent to: 

	(LAMBDA (&QUOTE X Y Z)
		(SETQ A (EVAL X))
		(SETQ A (EVAL Y))	
		(SETQ A (EVAL Z))
		(1+ A))

Surely this ugly thing cannot be considered usefull.  Clearly what you
have in mind is that LAMBDA* only be used in places like the one you
gave as an example: "((LAMBDA*", in which case What you want is LET*.

Date: 10 NOV 1979 0048-EST
From: KMP at MIT-MC (Kent M. Pitman)
Sent-by: ___005 at MIT-MC
Subject: PROG* and related forms
To: (BUG LISPM) at MIT-MC
CC: (BUG LISP) at MIT-MC, NIL at MIT-MC

Could we introduce a LAMBDA* operator which did bindings sequentially? 
Consider the following form, which returns the value 4.

((LAMBDA* (A A A) (1+ A)) 1 (1+ A) (1+ A))

-kmp


MOON5@MIT-MC 11/09/79 23:11:49 Re: New system installation
To: INFO-LISPM at MIT-MC
System 20 is now installed on CADR-3.

If you need to use one of the system 19 bands, you will have to
revert the microcode back from 604 to 579.  When done, please remember
to change it back.  There is a plain system 20 and a Macsyma in system 20;
hopefully someone will make a vision system 20 shortly.

Installing new systems on all of these machines takes a lot of time; I
would like to have users take over some of this burden.  Instructions
on how to do it may be found in the file AI: LMDOC; INSTAL NEWSYS.  The
version numbers of the current microcode and current system may be
found at the front of this file.  There is not yet a newer system wanting
to be installed, but if you are interested you could read the file and
see if it makes sense to you.

However, it is easy to break the machine doing this, so if you want to
be helpful but don't totally understand the instructions, please don't
try to figure it out by experimentation, ask me or another Lisp machine
wizard.  Also, these instructions will not work in system 19; it will
appear to work but the system you get will fail to boot. 

Date: 9 NOV 1979 1637-EST
From: Nis at MIT-AI (H. Keith Nishihara)
To: (BUG LISPM) at MIT-AI

can we get system 20 on cadr3 some time? -- keith


Date: 9 NOV 1979 1138-EST
From: Nis at MIT-AI (H. Keith Nishihara)
To: (BUG LISPM) at MIT-AI

is there or would it be possible to setup something
like maclisp's autoload feature on the lispmachine?  this would be very useful to me
and probably others  -- keith


MOON@MIT-MC 11/08/79 12:48:29 Re: parallel and sequential binding.
To: ALAN at MIT-AI
CC: (BUG LISPM) at MIT-MC
    ALAN@MIT-AI 11/07/79 23:45:33 Re: parallel and sequential binding.
    To: MOON at MIT-MC
        MOON@MIT-MC 11/07/79 21:35:53 Re: parallel and sequential binding.
            Date: 7 NOV 1979 0508-EST
            From: RMS at MIT-AI (Richard M. Stallman)
            
            How about changing PROG to bind its variables in parallel
            like DO and LET, but introducing PROG* which would bind them
            sequentially as PROG does now.  PROG* would be like LET*....
        I don't see how this could be worth the incompatibility.  Better would
        be to leave PROG alone and not use it new programs.
    Well I hate to be the one to say this, but there are still places where
    PROG (or some PROGlike thing without the repeatness of DO) is what
    is wanted.  A parallel PROG would only be incompatable for LispMachine
    code, since the MacLisp PROG doesn't need to make the distinction.
    Now this is not to say that we should make this proposed change,
    but perhaps it can't be brushed off that easily. (Have you ever used
    PROG in such a way that it would make a difference?)
Yes, I forgot that in Maclisp you can't give initial values.  So the
incompatibility is not so gross as I thought.   There are certainly lots
of macros which use PROG in such a way that they can tell whether it
is sequential or parallel.  However, since this would only be in code
written for the Lisp machine making the change is at least
contemplatable.

It still sounds like an unimportant change that would get in the
way of a lot of people's work, but if RMS or someone wants to do
all the work involved in making the change, I won't object.  However,
it -is- important that &AUX binding be left sequential.

Date: 8 NOV 1979 1121-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

In system 20.3, with microcode 604, on LISP Machine Seven:
Why does not [BREAK]Q or [BREAK]L in SUPDUP kill the window so it isn't
hanging around uselessly?


Date: 8 NOV 1979 1034-EST
From: GLS at MIT-AI (Guy L. Steele, Jr.)
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI

In system 20.3, with microcode 604, on LISP Machine Seven:
SPRINTER is not defined.  What is the EXPR entry to the grind package??


Date: 8 NOV 1979 0828-EST
From: Jis at MIT-AI (Jeffrey I. Schiller)
To: (BUG LISPM) at MIT-AI

In system 20.2, with microcode 593, on LISP Machine Nine:
Cadr-9 doesn't appear to be able to talk to Cadr-7 or to Speech
through the ChaosNet. (Cadr-7 also claims not to be able to talke
to Cadr-9)
		-Jeff


Date: 8 NOV 1979 0815-EST
From: cent at MIT-AI (Pandora B. Berman)
To: (BUG LISPM) at MIT-AI

we are also out of 29701s.
please expidite (there is a busint in 936 which needs a dozen).

Date: 8 NOV 1979 0755-EST
From: cent at MIT-AI (Pandora B. Berman)
Subject: ttl chips
To: (BUG LISPM) at MIT-AI

i just took the last 20 TTLDM-100s out of the stockroom. we use
a few of these on just about everything, so we need more urgently.
please expidite....

MOON@MIT-MC 11/07/79 21:35:53 Re: parallel and sequential binding.
To: RMS at MIT-AI, (BUG LISPM) at MIT-AI
    Date: 7 NOV 1979 0508-EST
    From: RMS at MIT-AI (Richard M. Stallman)
    
    How about changing PROG to bind its variables in parallel
    like DO and LET, but introducing PROG* which would bind them
    sequentially as PROG does now.  PROG* would be like LET*....
I don't see how this could be worth the incompatibility.  Better would
be to leave PROG alone and not use it new programs.

Date: 7 NOV 1979 2101-EST
From: KEN at MIT-AI (Kenneth Kahn)
Subject: parallel and sequential binding.
To: RMS at MIT-AI
CC: (BUG LISPM) at MIT-AI

I agree completely.  Since I never use PROG the change would not
affect me and DO* would be useful.

Date: 7 NOV 1979 0508-EST
From: RMS at MIT-AI (Richard M. Stallman)
Subject: parallel and sequential binding.
To: (BUG LISPM) at MIT-AI

How about changing PROG to bind its variables in parallel
like DO and LET, but introducing PROG* which would bind them
sequentially as PROG does now.  PROG* would be like LET*.
Then there could also be DO*.  This would result in more functions
with more choices, but the whole lot would be easier to keep straight
than the set which we have now.
To convert, we just have to change PROG's to PROG*'s in existing code
when they look like they might possibly depend on the order of binding.

MOON@MIT-MC 11/05/79 00:34:38 Re: Garbage collector
To: KDF at MIT-AI
CC: INFO-LISPM at MIT-AI
You can get rid of all typeout by the garbage collector by setting
the variable SI:GC-REPORT-STREAM to NIL.  It was originally intended
that the default value of this be NIL, and only those who were interested
would turn it on.  Anyone with an opinion about what the default should
be, send me mail.

You can also set SI:GC-REPORT-STREAM to the value of TERMINAL-IO evaluated
in a Lisp listener, to make the messages go to that Lisp listener.  Don't
set it to the value of STANDARD-OUTPUT; that won't work because it simply
indirects through the value of TERMINAL-IO in the current environment.

Date: 4 NOV 1979 1938-EST
From: KDF at MIT-AI (Ken Forbus)
Subject: Garbage collector
To: (BUG LISPM) at MIT-AI

	When the GC-process window decides to expose itself, it does NOT
de-expose itself and let the normal processing continue.  This makes it very
hard to run programs unattended when the GC is on.  There is also an unfortunate
state wherein the GC seems to have done its job, all three lights flash in various
combinations and orders, the "wholine" tag is NIL, and despite updating the mouse
occasionally, the system menu will not pop up.  Sigh.
		Ken

KEN@MIT-AI 11/02/79 03:56:04 Re:  Ignore and Nil as args
To: (BUG LISPM) at MIT-AI
A few days ago I complained about a superflurous warning when NIL
is the name of an arguement.  Now (on cadr-2 20.2) I find the NIL
is ignored.  E.g.
(defun foo (x nil)
       (list x))
compiles to a function of only one argument and complains of too
many arguments when given 2.  Why can't the Lisp Machine treat both
NIL and IGNORE the same in this situation?

gls@MIT-AI 11/01/79 11:53:41
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI
In system 20.3, with microcode 600, on LISP Machine One:
When you type p to a break, it fails to print a <cr>
as confirmation that you have returned from the break.
(It also looks nicer.)  Also, an extra <cr> gets printed
after the ;BKPT message.  These are minor, but very annoying,
and inconsistent with MacLISP.


cent@MIT-AI 11/01/79 09:08:34 Re: cadr10
To: (BUG LISPM) at MIT-AI
has been stuffed. i think we had everything we needed. 
the memory used is 4K of 2141s. in the ICMEM, some of the
9328s used are marked 932859; i'm not sure they're the
same thing, but they were in the same drawer.
fixing of wire-warping has not yet been done; that will
get hacked presently.
stuff needed has been added to the expidite list on the white board.

cent@MIT-AI 11/01/79 05:25:33 Re: bus strips
To: (BUG LISPM) at MIT-AI
some bus strips for the mem and tv boards appeared in the lispm factory
recently -- the good kind with legs only at the 1/20 positions, instead
of everywhere. then today a note appeared on the white board that they
should be used to replace the kludged ones. 
unless there is gross complaint OR i see lots more of these winning bus
strips, they are going into new mem/tv boards, not into already-built ones
to replace the kludged versions. there are only about a dozen of the new
ones. even if none of them break when used, they will only fill 3 mem. boards.
i think it would be a waste of effort to take the kludges out and replace
with these winning ones, only to have to make more of the kludges for
later boards.
speaking of which, where did the more losing bus strips go? there were a couple 
of packages of them in 936 until yesterday. they should not disappear
until we get lots of the winning ones, because if we don't get lots
of winning ones, we will have to use the losing ones (a pain, but much
better than not having any). whoever took them please return them.

GLS@MIT-AI 10/31/79 18:14:02
To: (BUG LISPM) at MIT-AI, (BUG ZWEI) at MIT-AI
CC: GLS at MIT-AI
In system 20.2, with microcode 593, on LISP Machine Two:
The grinding algorithms used by C-M-G and C-M-Q ought to be consistent.
(And NEITHER of them does what I want to be done with DEFUN,
namely just the obvious dumb thing.  Bah, humbug.)


GLS@MIT-AI 10/31/79 17:23:04 Re: Grindef
To: MOON at MIT-MC
CC: GLS at MIT-AI, (BUG LISPM) at MIT-AI
    MOON@MIT-MC 10/31/79 11:16:17 Re: Grindef
        GLS@MIT-AI 10/30/79 16:58:27
        In system 20.2, with microcode 593, on LISP Machine Eight:
        GRINDEF of no arguments is supposed to use the arguments last given it;
        but it traps out with an error instead.  This is a royal pain.

    I never heard of this "feature" before.  Is it really useful?
    I suppose it could be put in....

Well, it has always worked that way on the PDP-10, and it
is incredibly useful when you are making iterated versions of
one function and constantly re-reading it.  This I find
especially true when the function involved was generated by
three levels of hairy macro and has a very long (generated) name.
If I'm debugging the three levels of hairy macro, iterated
GRINDEF's are essential to figuring out what's going on.
(I was doing just this when I complained.)

Date: 31 OCT 1979 1123-EST
From: MOON at MIT-MC (David A. Moon)
Subject: DOLIST
To: GLS at MIT-AI
CC: (BUG LISPM) at MIT-MC, (BUG LISP) at MIT-MC

Unfortunately there are a lot of useful generalizations of DOLIST.
I think we decided to hold the line and not make any extensions,
to keep it simple and easy to understand.  You can always use this
LOOP crock (not yet installed), which is like FOR in Interlisp
and LIBLSP;FOR, except cleaned up and made less crockish.
e.g. (LOOP FOR var1 IN list1 FOR var2 IN list2 ... DO body)

MOON@MIT-MC 10/31/79 11:16:17 Re: Grindef
To: GLS at MIT-AI
CC: (BUG LISPM) at MIT-MC
    GLS@MIT-AI 10/30/79 16:58:27
    In system 20.2, with microcode 593, on LISP Machine Eight:
    GRINDEF of no arguments is supposed to use the arguments last given it;
    but it traps out with an error instead.  This is a royal pain.

I never heard of this "feature" before.  Is it really useful?
I suppose it could be put in....

MOON@MIT-MC 10/31/79 11:07:14
To: cwh at MIT-AI
CC: (BUG LISPM) at MIT-MC
ZWEI offers to create missing packages so that you can LOOK AT files
whose package declarations you haven't loaded.  Actually compiling
something without loading its correct package declaration is a good
way to lose, unless the package declaration is completely trivial.
For example, it would not be a good idea to do this for Macsyma.
So I don't think this should be done for qc-file, as it would just
make it easier to have an obscure bug without adding significant convenience.

HES@MIT-AI 10/31/79 09:16:13
To: (BUG LISPM) at MIT-AI
If there is an active window whose screen is the color screen, various screwups
happen.
1) If for example you attempt to go into zwei, the system traps and leaves some
   lock set (sorry about the vagueness, I can recreate the problem if someone
   wants to look at it).

2) When a pop up menu (as in menu choose) is popped up on the cpt monitor and
then finishes its work, it decides to clear a portion of the color window as
part of its deexposing.

If someone wants to figure out what's going on I'll be  glad to help.

howie.

cwh@MIT-AI 10/31/79 04:39:00
To: (BUG LISPM) at MIT-AI
Attempting to do a disk-save on cadr 1 with a world (20.2) which has Macsyma loaded fails
sometime after the new system-version-string is written to the disk.  It stops with
the disk light on.  Attempting to reload that band wins, but gets what was there before.
Saving a regular system (20.2) on that band wins.

Also, qc-file should offer to create missing packages rather than giving an error
like meta-z does in zwei.


KEN@MIT-AI 10/31/79 02:02:18
To: (BUG LISPM) at MIT-AI
The following two functions seem to compile to the same code but compiling the
first one gives a warning that NIL is bound 

(defun foo nil
 (bar (function (lambda (nil) t))))

(defun foo2 nil
 (bar2 (function (lambda (ignore) t))))

GLS@MIT-AI 10/30/79 16:58:27
To: (BUG LISPM) at MIT-AI
CC: GLS at MIT-AI
In system 20.2, with microcode 593, on LISP Machine Eight:
GRINDEF of no arguments is supposed to use the arguments last given it;
but it traps out with an error instead.  This is a royal pain.


GLS@MIT-AI 10/30/79 11:33:48 Re: DOLIST
To: (BUG LISPM) at MIT-AI
CC: (BUG LISP) at MIT-AI, GLS at MIT-AI
I would find it useful if DOLIST were compatibly generalized to
more than one list.  If the first argument form had a non-atomic
car, then it would be a list of variable specifications:
	(DOLIST ((FOO LIST1) (BAR LIST2)) . body)
and FOO and BAR would take on successive elements of their
respective lists.

Date: 29 OCT 1979 1049-EDT
From: Moon at MIT-AI (David A. Moon)
Subject: Time wrong
To: INFO-LISPM at MIT-AI

If you want your Lisp machine to know the right time, load in the
file LMIO;CHSAUX.  Or wait until 2 AM Tuesday morning, when the bug
will evaporate by itself.

MOON@MIT-MC 10/28/79 21:02:37
To: KDF at MIT-AI
CC: (BUG LISPM) at MIT-MC
    KDF@MIT-AI 10/27/79 21:38:58
    To: (BUG LISPM) at MIT-AI
    	The options of :break and :exitbreak do not seem to work.  They don't 
    cause trace to error out (why can't it just type a ? style maclisp form instead
    of bombing?), but just don't cause breaks.
They take a following argument of a condition on which to break.  If you
omit it evidently it just takes CADR of NIL and gets NIL as the condition.
I guess it should be fixed to check for this and complain.  What documentation
did you read that told you about the :break and :exitbreak options but
didn't mention that they take a follwoing argument?

If you use the trace operation in the system menu you won't be able to
input bad syntax, as it uses a menu of options and prompts you for
following arguments.

KDF@MIT-AI 10/27/79 21:38:58
To: (BUG LISPM) at MIT-AI
	The options of :break and :exitbreak do not seem to work.  They don't 
cause trace to error out (why can't it just type a ? style maclisp form instead
of bombing?), but just don't cause breaks.
		Ken

cent@MIT-AI 10/27/79 09:40:00 Re: dips again
To: (BUG LISPM) at MIT-AI
we are entirely out of 29701s. there is currently a bus int board
sitting in 936 whihc will not be able to be fully stuffed until we get more.
order/expidite please?
also, we are running low on TTL dip-like frobs. specifically TTLDM-100s,
but also 25s, 50s, and 250s, also MTTLDL-100s. again, order/expidite?
also, we are out of several flavours of slashified sips, which are holding up
stuffing or updating of several boards and things. order/....?

Moon@MIT-AI 10/27/79 08:57:16
To: (BUG LISPM) at MIT-AI
Someone please call Century Data to fix the disk on CADR7.  It is
(again) retracting the heads with no other error indication, now
and then.  It also makes moderately funny noises while spinning
up and spinning down.

cent@MIT-AI 10/27/79 02:02:15 Re: misplacement
To: (BUG LISPM) at MIT-AI
on checking over a board i just stuffed, i found an s151 where an s158
should have been. further investigation indicated that probably a tube
of s151s got dumped into the s158 drawer at some point. exactly where
the mistake lies (person wanted s151s but put them in wrong drawer,
person wanted s158s and got wrong tube, mfgr. mixed dips in tube, etc.)
is unclear. but please, be careful that the dips you get are the ones you
want, and that you put them into their correctly-labelled drawer.

because only some of the dips in the s158 drawer were wrong, it's not clear
that anything has been fucked. i will check over the few boards i
recently stuffed. people who know of other uses of thesae should check
them.

Jis@MIT-AI 10/26/79 13:28:58
To: (BUG LISPM) at MIT-AI
Machine Eight: If you use DEFSELECT on the name of a function that
already exists (but is a FEF not a SELECT-METHOD) you lose bad when
defselect tries to rip apart the FEF (thinking it is a select-method).
It is unclear to me what the right thing is to do in this situation, but
clearly the error you get now is unacceptable (it blows up screwing
around with the insides of the FEF)

			-Jeff


Moon@MIT-AI 10/25/79 04:27:07 Re: Marksman disk
To: (BUG LISPM) at MIT-AI
The Marksman disk is temporarily installed as the system disk on CADR8.  This is
not intended to be permanent since this disk is small and slow, limiting the address
space available and making the machine noticeably slower.  However I would like to
leave it hooked up for a week or so to make sure that the hardware and software
work completely.  Please let me know of any problems.  Instructions for removing
the Marksman and re-installing the Trident are taped to the machine.

Moon@MIT-AI 10/25/79 04:25:12 Re: Bootstrap PROMs
To: (BUG LISPM) at MIT-AI
If you make some more bootstrap PROMs, please either use the latest version on disk
(using PROGRAMMER-MAKE-BOOTSTRAP) or copy the ones labelled "v.7".  The earlier
ones, before version 7, do not work with the Marksman disk, so we should not make
any more of them.  There is one set of v.7 PROMs currently in existence, installed
in CADR8.

MOON@MIT-AI 10/25/79 03:11:40
To: (BUG LISPM) at MIT-AI
If you change the speed of the PROM programmer, please change it back.
Someone left it set to a non-standard speed, thus giving me a hard time when
I went and tried to use it.

MOON@MIT-MC 10/23/79 05:13:46
To: RMS at MIT-AI
CC: (BUG LISPM) at MIT-MC
    RMS@MIT-AI (Sent by ___035@MIT-AI) 10/23/79 01:41:13
    To: (BUG LISPM) at MIT-AI
    The machine in 902 which is not CADR 3 got parity errors
    a few times recently.  Can someone please write down where to look
    with CC to find the relevant information, or create a command
    to analyse them?

(CC-PARITY-SWEEP 2 T) seems to be the relevant command.  In the case I looked
at, all parity errors were at the same row address, which seems to be the usual
refreshing problem that has supposedly been fixed.

cwh@MIT-AI 10/23/79 04:15:43
To: (BUG LISPM) at MIT-AI
Please do not flush the band labelled "APS Demo".


RMS@MIT-AI (Sent by ___035@MIT-AI) 10/23/79 01:41:13
To: (BUG LISPM) at MIT-AI
The machine in 902 which is not CADR 3 got parity errors
a few times recently.  Can someone please write down where to look
with CC to find the relevant information, or create a command
to analyse them?

Henry@MIT-AI 10/20/79 22:24:12 Re:  grind
To: (BUG LISPM) at MIT-AI
Now that macros are compiled, GRINDEF doesn't
seem to be able to handle them.
  (GRINDEF FIRST) ;; Blows up, while
  (GRINDEF CONS)  ;; Does something reasonable with compiled function.
  (DEFMACRO A-MACRO ....)
  (GRINDEF A-MACRO) ;; Grinding interpreted macros works.


Date: 20 OCT 1979 1246-EDT
From: JONL at MIT-MC (Jon L White)
To: GSB at MIT-MC
CC: (BUG LISP) at MIT-MC, (BUG LISPM) at MIT-MC, BSG at MIT-MC

    Date: 18 October 1979 21:34-EDT
    From: Glenn S. Burke <GSB at MIT-ML>
    Subject: format of (status features)

    The maclisp manual claims that (car (last (status features))) is
    the implementation name.  
Actually, it was meant to mean "name of operating system type", such
as TOPS-10, TOPS-20, TENEX, ITS, MULTICS . . .
			      I have also been under the impression
    that (cadr (reverse (status features))) was itself significant, ie
    the "machine identifier" or somesuch (eg "ML"), but i don't have
    an old manual handy to see if it actually claims this.  
This is not really a "feature" - it was used in the days when the
various ITS machines had to have different assemblies of LISP.  But
now, the same code is used on all three systems (yes, Virginia, we
don't make use of the fact that the KL10 has . . .)
							    I see however
    that multics maclisp now has "Maclisp" as the last element, and the
    lisp machine uses neither of those last elements.  It would be kind
    of nice if these items could be found by some means other than 
    enumeration.
This might seem a bug, if we would expect the last element to be the
supporting operating system name.


RMS@MIT-AI 10/20/79 02:03:57
To: (BUG LISPM) at MIT-AI
The transformer-winding kit is getting depleted of several items
including the plastic screws.

CENT@MIT-AI 10/19/79 22:55:11 Re: lack of dips
To: (BUG LISPM) at MIT-AI
we have one tube left of 74S253s in the stockroom.
i just took out the last tube there of 74LS163s.
and we haven't had any 74LS193/25LS193s in ages.
someone please expidite?

