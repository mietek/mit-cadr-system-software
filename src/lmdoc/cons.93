.xgp
.squish
.font 0 25fr3
.font 1 22fg
.font 2 30vrb
.font 3 66vr
.font 4 25vqxb
.quote 
.dummy _
.twinch 6.3
.sidm 50
.tlinch 9.3
.topm 40
.crcomp
.spw 16
.sblock 5
.adjust
.spread
/3DRAFT/DRAFT/DRAFT/
.sp 2
.center
2MASSACHUSETTS INSTITUTE OF TECHNOLOGY
.CENTER
ARTIFICIAL INTELLIGENCE LABORATORY
.sp 4
.spread
/AI Memo\WP No. ???//
.sp
.center
3CONS
.sp 2
.center
2by
.sp
.center
Guy L. Steele Jr.
.sp
.center
(gross revision of Working Paper 80 by Tom Knight)
.sp 3
0Abstract:
.sp 10
Comments and corrections, technical or typographical, are solicited.

.spage
.php1
.he1
1Guy L. Steele Jr.     
.he2
DRAFT    The CONS Microprocessor
.page
.sect
4Acknowledgements0
.sp
	The CONS machine was designed by Tom Knight.
Ideas for this design were taken from
the DEC PDP-11/40 and the 11/40 extensions at Carnegie-Mellon University.
Sam Fuller from CMU suggested
the instruction modification technique.  Locally, Jack Holloway contributed ideas
on the timing of scratchpad references, and Richard Greenblatt has helped make
sure the machine will do enough to perform its intended work.
Dave Moon has helped modify the multiply/divide logic and suggested
minor changes; Guy Steele has suggested a few marginal changes.
.sp
	Pitts Jarvis
maintained the Stanford drawing system and assisted in documenting the instruction
formats.  Thanks also are due to Dick Helliwell and the Stanford Foonly design crew
who developed the drawing system without which this machine would have been impossibly
difficult to design.
.sp
	The CONSLP assembler and CC debugger were designed and written
by Richard Greenblatt.  Dave Moon has been assisting in software development.
.sp
	The original version of part 1 of this document was written by Tom Knight.
The current revision by Guy Steele includes new drawings;
updated information concerning recent changes to the prototype processor;
new parts on the CONSLP assembler, the diagnostic interface, and the CC debugger;
programming examples;
and a large amount of textual reorganization.
.sp 2
<<any more suggestions for acknowledgements?>>

.sp 2
.sect
4Disclaimer0
.sp
	The CONS machine is still undergoing small changes in design,
and will continue to do so, under the influence of hardware additions
and requirements of developing software.
Because of this, the document you are reading now may not reflect
current truth.  The author would appreciate being notified of any
observed discrepancies, and also please send any errors, comments,
etc. to :BUG LISPM.

.sp 2
.sect
4Notational Conventions0
.sp
	All numbers used to describe bit positions, field widths,
memory sizes, etc. are decimal.  Octal is used only
(and exclusively) to describe the values of fields.
Bits within a word are consistently numbered from right
to left, the least significant bit being bit <0>.
Fields are described by the numbers of their most and 
least significant bits (e.g. "bits <22-10>").
	Whenever a particular field value is described as
"illegal", it does not mean that specifying that value will
screw up the operation of the machine.  It merely indicates a value
which happens to have a certain function, not because
it is considered directly useful, but because
the internal workings of the machine may force
certain selectors to that value for other reasons,
and the user can select this value too even though it is not normally
useful.  These illegal values are described for the benefit
of someone who may wish to fathom these inner workings.
	A field value described as "unused"
is reserved for possible design expansion and should not be
used in programs.  Bit fields described as "unused" should be
zero in programs, for the sake of future compatibility.
.page
.sect
4Overview0
.sp
	The CONS microprocessor is a general purpose processor designed
for convenient emulation of complex order codes, particularly those involving
stacks and pointer manipulation.
It is the central processor in the LISP machine project, where it
interprets the bit-efficient 16-bit order code produced by the LISP machine compiler.
(The terms "LISP machine" and "CONS machine" are sometimes confused.
In this document, the CONS machine is a particular design of microprocessor,
while the LISP machine is the CONS machine plus the microcode which
interprets the LISP machine order code.)
	The data paths of the CONS machine are 32 bits wide.
Each 44-bit-wide microcode instruction
specifies two 32-bit data sources from a variety of internal scratchpad registers;
the two data-manipulation instructions can also specify a destination address.
The internal scratchpads include a 1K pointer-addressable RAM intended for
storing the top of the emulated stack, in a manner similar to a cache.  Since
in the LISP machine a large
percentage of main memory references will be to the stack, this should materially speed
up the machine.
	The CONS machine has a 12-bit program counter, which behaves much like that of a
traditional processor, allowing up to 4K of writable microprogram memory.
Also included is a 32-location microcode subroutine return stack.
	Memory is accessed through a two-level virtual paging system, which maps
23-bit virtual addresses into 20-bit physical addresses.
	There are four classes of micro-instructions.
Each specifies two sources (A and M); the ALU and BYTE operations
also specify a destination (A, or M plus functional).
The A bus supplies data from the 256-word A scratchpad memory,
while the M bus supplies data from either the 32-word M scratchpad memory
or a variety of other internal registers.
The four classes of microinstruction are:
.sp
.in 11
.un 11
ALU________The destination receives the result of a boolean or
arithmetic operation performed on the two sources.
.sp
.un 11
BYTE_______The destination receives the result of a byte extraction, byte deposit,
or selective field substitution from one source to the other.
The byte so manipulated can be of any non-zero width.
.sp
.un 11
JUMP_______A transfer of control occurs, conditional on the value of any bit
accessible to the M bus, or on a variety of ALU and other internal conditions
such as pending interrupts and page faults.
.sp
.un 11
DISPATCH___A transfer of control occurs to a location
determined by a word from the dispatch memory selected
by a byte of up to seven bits extracted from the M bus.
.in 0
.sp
	There are several sources and destinations whose loading and use
invoke special action by the microprocessor.  These include the memory address and
memory data registers, whose use initiates main memory cycles.
	Some of the ALU operations are conditional, depending upon the
low order bit in the Q register and the sign of A source.
These operations are used for multiply and divide steps.
	The main features of this machine which make it suitable for interpreting
the LISP machine order code are its dynamically
writable microcode, its very flexible dispatching
and subroutining, its excellent byte manipulation abilities, and its internal stack
storage.
While the design of CONS was strongly influenced
by the requirements of the LISP machine design,
a conscious attempt was made to avoid features that are
extremely special-purpose.
The goal is a machine that happens to be good at interpreting
the particular order code of the LISP machine, but which is general
enough to interpret others almost as well.
In particular, no critical parts of the LISP machine design
(such as LISP machine instruction formats) are "wired in";
thus any changes to the LISP machine design can be easily
accomodated by CONS.
	Since the use of the term "micro" in referring to registers and instructions
becomes redundant, its use will be dropped from here on in this part
of the document.
All instructions discussed are microinstructions.

.page
.sect
4Data Paths0
.sp
	The data paths of the machine consist of two source busses A and M,
which provide data to the ALU and byte extractor,
and an output bus OB, which is selected from the ALU (optionally shifted left or right)
or the output of the byte extractor, and whose data can be routed
to various destinations.
We first describe the specification of the source busses, which are identically
specified for all instructions; then the destination specifiers which control where
results are stored; and finally the two instructions for controlling the ALU and
the byte extractor.
.sp 20
.center
<<picture CHODAM goes here - use DPLT>>


.page
.sect
4Sources0
.sp
	All instructions specify sources in the same way.  There are two source
busses in the machine, the A bus and the M bus.  The A bus is driven only from the
A scratchpad memory of 256 32-bit words.
The M bus is driven from the M scratchpad of
32 32-bit words and a variety of other sources, controlled by the M selector.
Among these other sources are main memory data,
the PC stack (for restoring the state of the processor after traps),
the internal stack buffer and its pointer registers, and the Q register.
Addresses for the A and M
scratchpads are taken directly from the instruction.  The alternate sources of data
for the M source are specified with an additional bit in the M source field.
.sp
.nofill
IR<37-30> = A source address
IR<29-24> = M source address
	If IR<29> = 0,
		IR<28-24> = M scratchpad address
	If IR<29> = 1,
		IR<28-24> = M multiplexor source
				 0  M scratchpad (illegal)
				 1  M scratchpad pass-around path (illegal)
				02  Main memory read data (MRD register)
				12  Main memory write data (MWD register)
				22  Virtual memory address (VMA register)
				32  Memory map data
				 3  Q register
				 4  PDL POINTER <19-10>, PDL INDEX <9-0>
				05  SPC POINTER <31-27>, SPC data <17-0>
				15  Like 05, but also decrement
					SPC POINTER (pop)
				 6  DISPATCH CONSTANT register <7-0>
				07  Pdl data addressed by PDL INDEX
				17  Pdl data addressed by PDL POINTER,
					then decrement PDL POINTER (pop)
				27  Unused
				37  Pdl data addressed by PDL POINTER
.sp
.adjust
Programming hint: it is often convenient to reserve one A memory word and one
M memory word and fill them with constant zeros, to provide
a zero source for each source bus.  It is also convenient to have an
M memory word containing all ones.  These are particularly
useful for byte extraction, masking, bit setting, and bit clearing operations.
The CONSLP assembler in fact assumes that A memory location 1
and M memory location 1 are sources of zeros.
.page
.sect
4Destinations0
.sp
The 10-bit destination field in the BYTE and ALU instructions
specifies where the result of the instruction is deposited.
It is in one of two forms, depending upon the high-order bit.
If the high-order bit is 1, then the low 8 bits are the address of
an A memory location, and the remaining bit is unused.
If the high order bit is 0, the low 9 bits are divided
into a 4-bit "functional destination" field, and a 5-bit M scratchpad address,
and both of the places specified by these fields get written into.
.sp
.nofill
IR<23-14> = Destination
	If IR<23> = 0,
		IR<21-14> = A scratchpad write address
	If IR<23> = 1,
		IR<22-19> = Functional destination write address
			0  None
			1  Memory write data (MWD register)
			2  MWD, initiate write using address in VMA
			3  MWD, write map data
			4  Virtual memory address (VMA register)
			5  VMA, initiate read
				(data eventually appears in MRD)
			6  VMA, initiate write using data in MWD
			7  VMA, write map data
		       10  PDL location addressed by PDL POINTER
		       11  Like 10, but first increment PDL POINTER (push)
		       12  PDL location addressed by PDL INDEX
		       13  PDL INDEX
		       14  PDL POINTER
		       15  SPC location addressed by SPC POINTER,
				but first increment SPC POINTER (push)
		       16  Next instruction modifier
				("OA register"), bits <23-0>
		       17  Next instruction modifier
				("OA register"), bits <43-24>
		IR<18-14> = M scratchpad write address
.sp
.adjust
Note:  If you write into the M-memory, the machine will also write into the corresponding
A-memory address.  Therefore you should never write into A-memory locations 0-37; this
way the first 40 locations of A-memory "map into" the M-memory.  This makes programming
more convenient since you can bring M-memory data into either side of the alu or shifter.

.sp
	The Q register is loaded by using the ALU instruction,
not by using a functional destination.
	When initiating a main memory write cycle, the memory
write data and the VMA may be loaded in either order, using
functional destinations 4 and 2 or 1 and 6.
.sp
Programming hint:  if a functional destination is specified, an M
scratchpad location must also be specified.
It is convenient to reserve one location of
the M scratchpad for "garbage"; this location can be specified
when it is desired to write into a functional destination
but not into any other M scratchpad location.
Since the CONSLP assembler defaults the M write address to zero,
it is best to let location 0 be the garbage location.
For similar reasons, it is a good idea
to let location zero of the A memory be a garbage location also.
.page
.sect
4The ALU Instruction0
.sp
	The ALU operation performs most of the arithmetic in the machine.  It specifies
two sources of 32 bit numbers, and an operation to be performed by the ALU.
The operation can be any of the 16 boolean functions on two variables,
two's complement addition or subtraction, left shift, and several less useful operations.
The carry into the ALU can be forced to be 0 or 1.
The output of the ALU is optionally shifted one place, and
then written into the specified destinations via the output bus.
Additionally, the ALU instruction specifies one of four operations upon the Q register.
These are do nothing, shift left, shift right, and load from the output bus.
An additional bit in the
ALU operation field is decoded to indicate conditional operations;
this is how the "multiply step" and "divide step"
operations are specified.  (Multiplication and division are
explained in greater detail in another section.)
.sp 2
.nofill
IR<44>    = Parity bit
IR<43-42> = Unused
IR<41>    = ILONG (1 means slow clock)
IR<40-39> = 0 (ALU operation)
IR<38>    = POPJ transfer
IR<37-30> = A source
IR<29-24> = M source
IR<23-14> = Destination
IR<13-12> = Output bus control
		0  Byte extractor output (illegal)
		1  ALU output
		2  ALU output shifted right one,
			duplicating the sign bit (ALU<31>)
		3  ALU output shifted left one,
			shifting in Q<31> from the right
IR<11-10> = Miscellaneous Functions
		0  Normal
		1  Halt the processor
		2  Unused
		3  Load the LOW PC BIT register from the
			low bit of the ALU output (ALU<0>)
IR<9-4> = ALU operation
		If IR<9> = 0,
			IR<8-4> = ALU op code (see table)
		If IR<9> = 1,
			IR<8-4> = Conditional ALU op code
				 0  Multiply step
				 1  Divide step
				 5  Remainder correction
				11  Initial divide step
IR<3>   = Unused
IR<2>   = Carry into low end of ALU
IR<1-0> = Q control
		0  Do nothing
		1  Shift Q left, shifting in the inverse
			of the sign of the ALU output (ALU<31>)
		2  Shift Q right, shifting in the low bit
			of the ALU output (ALU<0>)
		3  Load Q from output bus
.adjust
.sp 3

.nofill
.block 36
Opcode 0  	ALU
.sp
1
     42    39    36    33    30    27    24    21    18    15    12     9     6     3     0
      |     |     |     |     |     |     |     |     |     |     |     |     |     |     | 
 | |   | |   | |               |           |                   |   |   |           | | |   |
 |1| 2 |1| 2 |1|       8       |     6     |        10         | 2 | 2 |     6     |1|1| 2 |
 | |   | |   | |               |           |                   |   |   |           | | |   |
  |  |  |  |  |        |             |               |           |   |       |      | |  |
Parity  |  |  |        |             |               |           |   |       |      | |  |
     |  |  |  |        |             |               |           |   |       |      | |  |
Unused  |  |  |        |             |               |           |   |       |      | |  |
        |  |  |        |             |               |           |   |       |      | |  |
ILONG---'  |  |        |             |               |           |   |       |      | |  |
           |  |        |             |               |           |   |       |      | |  |
Opcode (0)-'  |        |             |               |           |   |       |      | |  |
              |        |             |               |           |   |       |      | |  |
POPJ----------'        |             |               |           |   |       |      | |  |
                       |             |               |           |   |       |      | |  |
A source---------------'             |               |           |   |       |      | |  |
                                     |               |           |   |       |      | |  |
M source ----------------------------'               |           |   |       |      | |  |
                                                     |           |   |       |      | |  |
Destination------------------------------------------'           |   |       |      | |  |
                                                                 |   |       |      | |  |
Output bus control-----------------------------------------------'   |       |      | |  |
                                                                     |       |      | |  |
Miscellaneous Functions----------------------------------------------'       |      | |  |
                                                                             |      | |  |
ALU opcode-------------------------------------------------------------------'      | |  |
                                                                                    | |  |
Unused------------------------------------------------------------------------------' |  |
                                                                                      |  |
Carry code----------------------------------------------------------------------------'  |
                                                                                         |
Q control--------------------------------------------------------------------------------'
0
.sp 2
.block 22
ALU bit operation functions (from Table 1 of 74181 specifications).
All arithmetic operations are two's complement.
Names in square brackets are the CONSLP mnemonics for the operations.
.sp
	Boolean (IR<8>=1)		  Arithmetic (IR<8>=0)
IR<7-4>				Carry in = 0		Carry in = 1
 0	M	[SETCM]		M			M+1	   [M+1]
 1	AM	[ANDCB]		MA			(MA)+1
 2	MA	[ANDCM]		MA			(MA)+1
 3	ZEROS	[SETZ]		-1			0
 4	MA	[ORCB]		M+(MA)		M+(MA)+1
 5	A	[SETCA]		(MA)+(MA)		(MA)+(MA)+1
 6	MÓA	[XOR]		M-A-1	   [M-A-1]	M-A	   [SUB]
 7	MA	[ANDCA]		(MA)-1		(MA)
10	MA	[ORCM]		M+(MA)			M+(MA)+1
11	MA	[EQV]		M+A	   [ADD]	M+A+1	   [M+A+1]
12	A	[SETA]		(MA)+(MA)		(MA)+(MA)+1
13	MA	[AND]		(MA)-1			MA
14	ONES	[SETO]		M+M	   [M+M]	M+M+1	   [M+M+1]
15	MA	[ORCA]		(MA)+M			(MA)+M+1
16	MA	[IOR]		(MA)+M		(MA)+M+1
17	M	[SETM]		M-1			M
.twinch 6.3
.adjust

.page
.sect
4The BYTE Instruction0
.sp
	The BYTE instruction specifies two sources and a destination in the same way
as the ALU instruction, but the operation performed is one of selective insertion of
a byte field from the M source into an equal length field of the word from the A source.
The rotation of the M source is specified by the SR bit as either zero or equal to the
contents of the ROTATE field.  The rotation of the mask used to select the bits replaced
is specified by the MR bit as either zero or equal to the contents of the ROTATE field.
The length of the mask field used for replacement is specified in the LENGTH MINUS 1
field.  The four states of the SR and MR bits yield the following operations:
.sp
.in 12
.un 12
MR=0_SR=0___Not useful__________(This is a subset of other modes.)
.sp
.un 12
MR=0_SR=1___LOAD BYTE___________PDP-10 LDB instruction
(except the unmasked bits are from the A source).
A byte of arbitrary position from the M source is right-justified
in the output.
.sp
.un 12
MR=1_SR=0___SELECTIVE DEPOSIT___The masked field from the M source is used to
replace the same length and position byte in the word from the A source.
.sp
.un 12
MR=1_SR=1___DEPOSIT BYTE________PDP-10 DPB instruction.
A right-justified byte from the M source
is used to replace a byte of arbitrary position in the word from the A source.
.in 0
.sp
The BYTE instruction automatically makes the output of the byte extractor
available by forcing the output bus select code to 0 (byte extractor output).
.sp 2
.nofill
IR<44>    = Parity bit
IR<43-42> = Unused
IR<41>    = ILONG (1 means slow clock)
IR<40-39> = 3 (BYTE operation)
IR<38>    = POPJ transfer
IR<37-30> = A source
IR<29-24> = M source
IR<23-14> = Destination
IR<13>    = MR = Mask Rotate (see above)
IR<12>    = SR = Source Rotate (see above)
IR<11-10> = Miscellaneous Functions
		0  Normal
		1  Halt the processor
		2  Unused
		3  XOR the LOW PC BIT register into
			the high bit of the rotation count
IR<9-5>   = Length of byte minus 1 (0 means byte of length 1, etc.)
IR<4-0>   = Rotation count (to the left) of mask and/or M source
.adjust
.sp 2
	The byte operation rotates the M source by 0 (if SR=0)
or by the rotation count (if SR=1), producing a result called R.
It also uses the MR bit, the rotation count, and the length minus 1
field to produce a selector mask (see description below).  This mask
is all zeros except for a contiguous section of ones denoting
the selected byte.  This mask is used to merge the A source with R,
bit by bit, selecting a bit from A if the mask is 0 and from R
if the mask is 1.  This result is then written into the specified
destination(s).

.page
.sp 2
Output of mask memories:
	Right mask memory is indexed by 0 (MR=0) or by rotation count (MR=1).
	Left mask memory is indexed by (the index into right mask memory) plus
		(the length minus 1 field), mod 32.
.sp
.nofill
1
octal	LEFT MASK MEMORY contents		RIGHT MASK MEMORY contents
index
  0	00000000000000000000000000000001	11111111111111111111111111111111
  1	00000000000000000000000000000011	11111111111111111111111111111110
  2	00000000000000000000000000000111	11111111111111111111111111111100
  3	00000000000000000000000000001111	11111111111111111111111111111000
  4	00000000000000000000000000011111	11111111111111111111111111110000
  5	00000000000000000000000000111111	11111111111111111111111111100000
  6	00000000000000000000000001111111	11111111111111111111111111000000
  7	00000000000000000000000011111111	11111111111111111111111110000000
 10	00000000000000000000000111111111	11111111111111111111111100000000
 11	00000000000000000000001111111111	11111111111111111111111000000000
 12	00000000000000000000011111111111	11111111111111111111110000000000
 13	00000000000000000000111111111111	11111111111111111111100000000000
 14	00000000000000000001111111111111	11111111111111111111000000000000
 15	00000000000000000011111111111111	11111111111111111110000000000000
 16	00000000000000000111111111111111	11111111111111111100000000000000
 17	00000000000000001111111111111111	11111111111111111000000000000000
 20	00000000000000011111111111111111	11111111111111110000000000000000
 21	00000000000000111111111111111111	11111111111111100000000000000000
 22	00000000000001111111111111111111	11111111111111000000000000000000
 23	00000000000011111111111111111111	11111111111110000000000000000000
 24	00000000000111111111111111111111	11111111111100000000000000000000
 25	00000000001111111111111111111111	11111111111000000000000000000000
 26	00000000011111111111111111111111	11111111110000000000000000000000
 27	00000000111111111111111111111111	11111111100000000000000000000000
 30	00000001111111111111111111111111	11111111000000000000000000000000
 31	00000011111111111111111111111111	11111110000000000000000000000000
 32	00000111111111111111111111111111	11111100000000000000000000000000
 33	00001111111111111111111111111111	11111000000000000000000000000000
 34	00011111111111111111111111111111	11110000000000000000000000000000
 35	00111111111111111111111111111111	11100000000000000000000000000000
 36	01111111111111111111111111111111	11000000000000000000000000000000
 37	11111111111111111111111111111111	10000000000000000000000000000000
0
.sp
.adjust
	After the two masks are selected, they are AND'ed together
to get the final mask.  This mask is all zeros, except for a field
of contiguous ones defining the byte.
	As an example, if MR=1, rotation count=5, and length minus 1=7,
then the right mask index is 5 and the left mask index is 14 (octal).
This results in a final mask as follows:
.sp
.nofill
		Right mask 5	11111111111111111111111111100000
		Left mask 14	00000000000000000001111111111111
	AND them together	--------------------------------
		Final mask	00000000000000000001111111100000
.sp
.adjust
The byte is 8 bits wide, 5 positions from the right.
.sp
.block 8
Programming hint: if the byte is "too large" (i.e. its position and
size specifications cause it to hang over the left-hand edge of a word),
then the masker does not truncate the byte at the left-hand edge.
Instead, it produces a zero mask, selecting no byte at all;
thus, the output of the byte operation equals the A source.
The reason for this is that an overflow occurs in calculating the
index into the left mask memory, and so the final mask is zero.
For example, if MR=1, rotation count=20 (octal), and length minus 1=27 (octal),
then the right mask index is 20 and the left mask index is 477 (mod 32).
This results in a final mask as follows:
.sp
.nofill
		Right mask 20	11111111111111110000000000000000
		Left mask 7	00000000000000000000000011111111
	AND them together	--------------------------------
		Final mask	00000000000000000000000000000000
.adjust

.sp 4
.nofill
.block 34
Opcode 3	  BYTE
.sp
1
     42    39    36    33    30    27    24    21    18    15    12     9     6     3     0
      |     |     |     |     |     |     |     |     |     |     |     |     |     |     | 
 | |   | |   | |               |           |                   | | |   |         |         |
 |1| 2 |1| 2 |1|       8       |     6     |        10         |1|1| 2 |    5    |    5    |
 | |   | |   | |               |           |                   | | |   |         |         |
  |  |  |  |  |        |             |               |          | |  |      |         |
Parity  |  |  |        |             |               |          | |  |      |         |
     |  |  |  |        |             |               |          | |  |      |         |
Unused  |  |  |        |             |               |          | |  |      |         |
        |  |  |        |             |               |          | |  |      |         |
ILONG---'  |  |        |             |               |          | |  |      |         |
           |  |        |             |               |          | |  |      |         |
Opcode (3)-'  |        |             |               |          | |  |      |         |
              |        |             |               |          | |  |      |         |
POPJ----------'        |             |               |          | |  |      |         |
                       |             |               |          | |  |      |         |
A source---------------'             |               |          | |  |      |         |
                                     |               |          | |  |      |         |
M source-----------------------------'               |          | |  |      |         |
                                                     |          | |  |      |         |
Destination------------------------------------------'          | |  |      |         |
                                                                | |  |      |         |
MR (1 means rotate M source)------------------------------------' |  |      |         |
                                                                  |  |      |         |
SR (1 means rotate selection mask)--------------------------------'  |      |         |
                                                                     |      |         |
Miscellaneous Functions----------------------------------------------'      |         |
                                                                            |         |
Length of byte minus 1------------------------------------------------------'         |
                                                                                      |
Rotation count------------------------------------------------------------------------'
.adjust

.page
.sect
4Control0
.sp
	The control section of the processor consists of a 12-bit program
counter (the PC), a 32-location PC stack (SPC) and stack pointer (SPCPTR),
and a 1K dispatch memory, used during the DISPATCH instruction.
Unlike some microprocessors, and like most traditional machines, the normal mode
of operation is to execute the next sequential instruction by incrementing the PC.

	The processor uses single instruction look ahead, i.e. the lookup of the
next instruction is overlapped with execution of the current one.  This implies that
after branching instructions the processor
normally executes the following instruction, even if the branch was successful.
Provision is made in these instructions to inhibit
this execution (with the N bit), but the cycle it would have used will then be wasted.
.sp 4
.nofill
.center
(I2 is a branch instruction to the location of I8)

TIME ===>

|              |              |              |              |              |
|  fetch I1    |  fetch I2    |  fetch I3    |  fetch I8    |  fetch I9    |
|  execute I0  |  execute I1  |  execute I2  |  execute I3  |  execute I8  |
|              |              |              |              |              |
                  |              |              |              |
Fetch of branch---'              |              |              |
                                 |              |              |
Execution of branch--------------'              |              |
                                                |              |
Execution (optionally inhibited)                |              |
of following instruction------------------------'              |
                                                               |
Execution of instruction branched to --------------------------'
.adjust
.sp 4
	Two types of instruction
affect flow of control in the machine. The conditional JUMP
specifies a new PC and transfer type in the instruction itself, while the DISPATCH
instruction looks up the new PC and transfer type in the 1K dispatch memory.
In either case, the new PC is loaded into the PC register, and the operation
specified by the 3-bit transfer type is performed. These operations are:
.sp
.in 12
.un 12
N_bit_______If on, inhibits execution of the (physically)
next instruction, i.e. the instruction at the address one greater than
that of the transfer instruction.
The cycle that would have executed that instruction is wasted.
.in 0
.sp
.block 9
The P and R bits are decoded as follows:
.sp
.in 27
.un 27
P=0_R=0_____BRANCH_________Normal program transfer.
.un 27
P=1_R=0_____CALL___________Save PC+2, or PC+1 if the N bit is also on, on the SPC stack before jumping.
.un 27
P=0_R=1_____RETURN_________Ignore new PC; instead pop PC off the SPC stack.
.un 27
P=1_R=1_____FALL_THROUGH___In a DISPATCH instruction, do not dispatch.
.un 27
____________WRITE__________In a JUMP instruction, write into the instruction memory, and do not jump.
.in 0
.sp
	The BRANCH transfer type is the normal program transfer, without saving
a return address.
	The CALL transfer type pushes the current PC, plus 2 (plus 1 if the N bit
is also on) onto the SPC stack.
This stack is 32 locations long.  It is the responsibility of the programmer
to avoid overflows.
	The RETURN transfer type pops a return PC from the SPC stack,
ignoring the PC specified in the instruction or dispatch table.
	The FALL THROUGH transfer type for dispatches allows some entries
in a dispatch table to specify that the dispatch should not occur after all.
The following instruction is executed (unless inhibited),
followed by the one after that (unless the first following one branches
and inhibits it!).
	The WRITE transfer type is the mechanism for writing instructions into the
microprogram instruction memory, and is described in a later section.
(The dispatch memory, unlike the instruction memory, is not written
into by setting the P and R bits; instead, the Miscellaneous Function field
is used.)
.sp
	An additional bit in every instruction, including ALU and BYTE
instructions, called the POPJ bit, allows specification
of simultaneous execution of a RETURN transfer type along with execution of any
instruction.  That is, it does the same thing as if this instruction, in addition
to whatever else it does, had executed a RETURN transfer type jump without the N bit on.
It is the responsibility of the programmer to avoid conflicts in the use
of this bit simultaneously with other types of transfers.
.page
.sect
4The DISPATCH Instruction0
.sp
	The dispatch instruction allows selection of any source available on the
M multiplexor [see description of M bus sources in the Data Path section],
and the dispatch on any sub-field of up to 7 bits from the selected word.
The selected subfield is ORed with the "dispatch offset" field of the instruction
to produce a 10 bit address.  This address is used to look up a 12 bit PC and 3
bit transfer type in the dispatch memory.
.sp 2
.nofill
IR<44>    = Parity bit
IR<43-42> = Unused
IR<41>    = ILONG (1 means slow clock)
IR<40-39> = 2 (DISPATCH operation)
IR<38>    = POPJ transfer
IR<37-30> = Dispatch constant
IR<29-24> = M source
IR<23-14> = Dispatch offset
IR<13-12> = Unused
IR<11-10> = Miscellaneous Functions
		0  Normal
		1  Halt the processor
		2  Write into dispatch RAM (and suppress dispatch!)
		3  XOR the LOW PC BIT register into
			the high bit of the rotation count
IR<9-8>   = Unused
IR<7-5>   = Length of byte (not minus 1!) from M source to dispatch on
IR<4-0>   = Rotation count (to the left) of M source
.adjust
.sp 2
	The dispatch operation takes the specified M source word and rotates it
to the left as specified by the rotation count.  All but the low K
bits are masked out, where K is the contents of the length field.
The result is OR'ed with the dispatch offset, and this is used to
address the 1K dispatch memory, which supplies the new PC and the R, P, and N bits. 

	The dispatch constant field is loaded into the DISPATCH CONSTANT register
on every dispatch instruction.  This register is accessible as an M source.
The dispatch constant field has nothing whatsoever to do
with the operation of dispatching; it is merely a convenient device
for loading a completely random register while doing something else.
(Uses for this feature are discussed in a later section.)

	Miscellaneous function 2 inhibits the normal action of the instruction
and instead loads the dispatch memory with the low order contents of the M memory
scratchpad location specified in the source.  The parity bit (bit 15) is also loaded,
and it is the responsibility of the programmer to load correct parity into the memory.
The data must come directly from the M memory and not from any other
M source; in particular, it may not come from
the pass-around path!  (The pass-around path can be
cleared by letting an extra instruction elapse between the writing of data in the
M memory and the transfer of the data to the dispatch memory.)
Normal addressing of the dispatch memory is in effect, so it is advisable to
have the length field contain 0 so that the dispatch memory location to
modify is uniquely specified by the dispatch offset.

.page
.sp
.nofill
.block 33
Opcode 2	  DISPATCH
.sp
1
     42    39    36    33    30    27    24    21    18    15    12     9     6     3     0
      |     |     |     |     |     |     |     |     |     |     |     |     |     |     | 
 | |   | |   | |               |           |                   |   |   |   |     |         |
 |1| 2 |1| 2 |1|       8       |     6     |        10         | 2 | 2 | 2 |  3  |    5    |
 | |   | |   | |               |           |                   |   |   |   |     |         |
  |  |  |  |  |        |             |               |           |   |   |    |       |
Parity  |  |  |        |             |               |           |   |   |    |       |
     |  |  |  |        |             |               |           |   |   |    |       |
Unused  |  |  |        |             |               |           |   |   |    |       |
        |  |  |        |             |               |           |   |   |    |       |
ILONG---'  |  |        |             |               |           |   |   |    |       |
           |  |        |             |               |           |   |   |    |       |
Opcode (2)-'  |        |             |               |           |   |   |    |       |
              |        |             |               |           |   |   |    |       |
POPJ----------'        |             |               |           |   |   |    |       |
                       |             |               |           |   |   |    |       | 
Dispatch constant------'             |               |           |   |   |    |       | 
                                     |               |           |   |   |    |       | 
M source-----------------------------'               |           |   |   |    |       | 
                                                     |           |   |   |    |       | 
Dispatch offset--------------------------------------'           |   |   |    |       | 
                                                                 |   |   |    |       | 
Unused-----------------------------------------------------------'   |   |    |       | 
                                                                     |   |    |       | 
Miscellaneous Functions----------------------------------------------'   |    |       | 
                                                                         |    |       | 
Unused-------------------------------------------------------------------'    |       | 
                                                                              |       | 
Number of bits to extract from M source---------------------------------------'       |
                                                                                      |
M rotation count----------------------------------------------------------------------'
1
.adjust
.sp 6
.nofill
.block 14
1
Dispatch Memory
                                                      12     9     6     3     0
                                                       |     |     |     |     | 
                                                  | | | |                       |
                                                  |1|1|1|          12           |
                                                  | | | |                       |
                                                   | | |            |
R bit (pop SPC stack into PC; ignores bits 0-11)---' | |            |
                                                     | |            |
P bit (push PC plus 1 or 2 onto SPC stack)-----------' |            |
                                                       |            |
N bit (inhibit execution of following instruction)-----'            |
                                                                    |
New PC--------------------------------------------------------------'
0
.adjust

.page
.sect
4The JUMP Instruction0
.sp
	The JUMP instruction allows conditional branching based on
any bit of any M source or on a variety of internal processor conditions,
including ALU output.  (While DISPATCH could also be used to test
single M source bits, the use of JUMP saves dispatch memory.)
The JUMP operation is also used, by means of a trick, to write into
the instruction memory.
.sp 2
.nofill
IR<44>    = Parity bit
IR<43-42> = Unused
IR<41>    = ILONG (1 means slow clock)
IR<40-39> = 1 (JUMP operation)
IR<38>    = POPJ transfer
IR<37-30> = A source
IR<29-24> = M source
IR<23-12> = New PC
IR<11-10> = Miscellaneous Functions
		0  Normal
		1  Halt the processor
		2  Unused          <<load dispatch constant??>>
		3  XOR the LOW PC BIT register into
			the high bit of the rotation count
IR<9>     = R bit (1 means pop new PC off SPC stack)
IR<8>     = P bit (1 means push return PC onto SPC stack)
IR<7>     = N bit (1 means inhibit next instruction if jump successful)
IR<6>     = If 1, invert sense of jump condition
IR<5>     = If 0, test bit of M source; if 1, test internal condition
IR<4-0>   = If IR<5>=0, rotation count for M source.
            If IR<5>=1, condition number:
		0  Low bit of shifter output (illegal)
		1  M source < A source
		2  M source  A source
		3  M source = A source
		4  Interrupt pending
		5  Page fault
		6  Interrupt pending or page fault (4 and 5 combined)
		7  Unconditionally true
.adjust
.sp 2
	The jump condition is determined as follows.
If IR<5>=0, then the M source is rotated left by the rotation count;
the low-order bit of the result is then tested.
Thus, to test the sign bit, a rotation count of 1 should be used.
The jump condition is true if the low-order bit is 1.
If IR<5>=1, then the specified internal condition is tested.
In either case, the sense of the jump condition is inverted
if IR<6>=1.
In particular, this allows testing of all six arithmetic relations
between the M and A sources.
	If the final jump condition, possibly after inversion,
is true, then the new PC field and the R, P, and N bits are used to
determine the new contents of the PC.
.sp
<<what about mod to make successful jump inhibit POPJ bit?>>
.sp
	If both the R and P bits are set (WRITE), then A and M sources
are (conditionally!) written into the instruction memory.
Bits <40-32> are taken from A source bits <8-0>; bits <31-0>
are taken from M source <31-0>.  Notice that this is not
the same alignment of bits as is used for the "next instruction modify"
functional destinations (16 and 17).  No transfer takes place.
The reason for the odd location of WRITE in the instruction
set is due to the way in which it operates.  It causes the same operations as
the CALL transfer type, resulting in the the old PC plus 1 or 2 being saved on the
SPC stack and the PC register being loaded with the address to
be modified.  Then, when the instruction memory would normally be fetching the
instruction to be executed from that location, a write pulse is generated, causing
the data from the A and M sources to be written into the
instruction memory.  Meanwhile, the machine
simulates a RETURN transfer instruction, causing the SPC stack to be popped
back into the PC and instruction execution
to proceed from where it left off.  Note that this instruction requires use
of a word on the SPC stack and requires an extra cycle.  It is highly recommended that
the N bit also be on during this instruction, since the processor will be executing a
RETURN transfer type unconditionally during what should be the execution of the
instruction following the write.
If, however, this does not conflict with other things that this following
instruction specifies, then the following instruction
may be executed.  Care is required.

.sp 2
.nofill
.block 37
Opcode 1	  JUMP
.sp
1
     42    39    36    33    30    27    24    21    18    15    12     9     6     3     0
      |     |     |     |     |     |     |     |     |     |     |     |     |     |     | 
 | |   | |   | |               |           |                       |   | | | | | |         |
 |1| 2 |1| 2 |1|       8       |     6     |          12           | 2 |1|1|1|1|1|    5    |
 | |   | |   | |               |           |                       |   | | | | | |         |
  |  |  |  |  |        |             |                 |             |  | | | | |     |
Parity  |  |  |        |             |                 |             |  | | | | |     |
     |  |  |  |        |             |                 |             |  | | | | |     |
Unused  |  |  |        |             |                 |             |  | | | | |     |
        |  |  |        |             |                 |             |  | | | | |     |
ILONG---'  |  |        |             |                 |             |  | | | | |     |
           |  |        |             |                 |             |  | | | | |     |
Opcode (1)-'  |        |             |                 |             |  | | | | |     |
              |        |             |                 |             |  | | | | |     |
POPJ----------'        |             |                 |             |  | | | | |     |
                       |             |                 |             |  | | | | |     |
A source---------------'             |                 |             |  | | | | |     |
                                     |                 |             |  | | | | |     |
M source-----------------------------'                 |             |  | | | | |     |
                                                       |             |  | | | | |     |
New PC-------------------------------------------------'             |  | | | | |     |
                                                                     |  | | | | |     |
Miscellaneous Functions----------------------------------------------'  | | | | |     |
                                                                        | | | | |     |
R bit (pop SPC stack into PC; ignores new PC)---------------------------' | | | |     |
                                                                          | | | |     |
P bit (push PC plus 1 or 2 onto SPC stack)--------------------------------' | | |     |
                                                                            | | |     |
N bit (inhibit execution of following instruction)--------------------------' | |     |
                                                                              | |     |
Invert sense of test if 1-----------------------------------------------------' |     |
                                                                                |     |
Test M source bit (0) or test internal condition (1)----------------------------'     |
                                                                                      |
Rotation count or condition number----------------------------------------------------'
0
.adjust

.page
.sect
4Program Modification0
.sp
	A novel technique is used for variabilizing fields in the program
instruction.  Two of the "functional destinations" of the output bus are
(conceptual) registers (sometimes collectively referred to as the OA register),
whose contents get OR'ed with the next instruction executed.  
Combined with the shifter/masker ability to move any contiguous set of bits
into an arbitrary field, this feature provides, for example, variable rotation counts
and the ability to use program determined addresses of registers;
for example, it can be used to index into the A scratchpad memory.
	Functional destination 16, when written into, effectively OR's
bits <16-0> into bits <43-24> of the next instruction;
functional destination 17 effectively OR's bits <23-0> into bits <23-0>
of the next instruction.  The place between bits <24> and <23> is a natural
dividing line for all classes of instructions.  Note that only one half of
an instruction can be modified, since it is impossible to write into both
functional destinations simultaneously.
	When this feature is used, parity checking is disabled for the
word fetched from the instruction memory, since the OA register is OR'ed
directly into the output of the memory.
	This feature is particularly useful for supplying the address
of a location of instruction memory or dispatch memory to be written into,
for specifying variable addresses in the A and M memories, and for
operations on bytes of variable length or position.  Examples of these
are detailed in a later section.

.page
.sect
4Clocks0
	The CONS processor uses only one clock signal.
This clock loads output data into the designated registers, and a new
PC and instruction are also loaded.  The only events which do not
take place synchronous with the clock are the control signals for
the A, M, and PDL scratchpads and the SPC stack.  For these devices,
a two stage cycle is performed.  During the first phase, the source addresses of the
respective devices are gated into the address registers.  After the output data has
settled, the outputs of these devices are latched.  Then, the address
is changed to that specified as the write location from the 
previous instruction.  After the address has settled, a write pulse is
generated for the scratchpad memory to perform the write.  Pass-around paths
are provided (invisibly to the programmer) for the A, M, and SPC stack memories,
which notice and correct read references to a location which was written into
on the previous cycle but has not yet actually been written into the scratchpad.
No such pass-around path is provided for the PDL memory, because on any cycle
in which the PDL memory is written into, the M scratchpad must also be written into,
and so the next instruction can refer to that M scratchpad location, thereby
using the M pass-around path.  (It is also possible to use M source number 41
if one is very careful.  There are also a few situations, such as writing
into the dispatch memory, when the data may not come
from a pass-around path.  It is the responsibility of the programmer
to be careful about these cases.)
	The clock cycle is of variable length.  The duration of
the first half of the cycle (the "read phase") is controlled by both
the ILONG bit of the instruction (IR<41>) and by a bit from the diagnostic
interface.  The duration of the second half (the "write phase")
may be extended by such conditions as waiting for main memory,
Miscellaneous Function 1 in an instruction,
single step mode (controlled by the diagnostic interface),
and error halts (parity error, loss of power).

.page
.sp 10
.center
<<picture CHODTM goes here - use SCNV>>
.sp 30
.center
<<picture CHODT1 goes here - use SCNV>>

.page
.sect
4Accessing Memory0
.sp
	Access to main memory is accomplished through use of several functional
sources and destinations.  These perform three functions; first, they allow access
to three registers, VMA, MRD, and MWD.  Secondly, they can initiate memory operations.
Thirdly, they can wait for a memory operation to be completed.
	The MRD (Memory Read Data) register holds data read from memory until it
is picked up by the program.  The MWD (Memory Write Data) register holds data to
be written into memory until the memory accepts it.
	The VMA (Virtual Memory Address) register contains the virtual address
of the location to be referenced.  This is 23 bits long.  The high 9 bits of the
register exist but are ignored by the hardware.  The VMA contains a "virtual"
address; before being sent to the memory it is passed through the "map", which
produces a 20 bit physical address, controls whether permission for the read or
write operation requested is allowed, and remembers five bits which the software
(microcode) can use for its own purposes.
	The map consists of two scratchpad memories.  The First Level Map
contains 2048 5-bit locations, and is addressed by bits 22-12 of the VMA.
The Second Level map contains 1024 20-bit locations, and is addressed by
the concatenation of the output from the First Level Map and bits 11-7 of the VMA.
The virtual address space consists of 2048 blocks, each containing 32 pages.
Each page contains 128 words (of 32 bits, of course).
Each block of virtual address space has a corresponding location in the
First Level Map.  Locations in the Second Level Map are not permanently allocated
to particular addresses; instead, the First Level Map location for a block of
virtual addresses indicates where in the Second Level Map those addresses
are currently described.
The Second Level Map contains sufficient space to describe 32 blocks,
so at any given time most blocks must be described as "no information available."
This done by reserving one block in the Second Level Map for this purpose;
all blocks to be described as "no information available" will point to
this block.
	The output of the Second Level Map consists of:
.sp
.nofill
MAP<19>    = access permission
MAP<18>    = write permission
MAP<17-13> = available to software
MAP<12-0>  = physical page number
.adjust
.sp
The physical address sent to memory is the concatenation of the physical
page number and bits 6-0 of the VMA.
	The two maps can be read by putting an appropriate address in the
VMA, and reading the functional source MEMORY-MAP-DATA:
.sp
.nofill
MMD<31-27> = First Level Map [VMA<22-12>]
MMD<26-7>  = Second Level Map [MMD<31-27>]
MMD<6-2>   = zero
MMD<1>     = 1 if a write into main memory has been attempted at
	       an address that does not have both access permission
	       and write permission
MMD<0>     = 0 if a read from main memory has been attempted at
	       an address that does not have access permission
.adjust
.sp
	The maps can be written by using one of the functional destinations
VMA-WRITE-MAP, WRITE-MEMORY-DATA-WRITE-MAP.  The VMA should have an
address and the MWD should have data as above, except that bit 0 is zero
to write into the First Level Map or one to write into the Second Level
Map.  Note that you have to write the First Level Map first, in order
to be able to address the Second Level Map.  Writing to one of these functional
destinations loads one of the registers and causes the map to be written
on the next cycle; the other register should be set up first.     << BLEAGH >>
	Main memory operations are initiated by using one of the functional
destinations VMA-START-READ, VMA-START-WRITE, and WRITE-MEMORY-DATA-START-WRITE.
In the case of a write, if the VMA-START-WRITE destination is
used the MWD must have previously been set up; otherwise the VMA must have
previously been set up.
The register named (VMA or MWD) is loaded with the result of the instruction
(from the Output Bus) at the end of the cycle during which that instruction
is executed.  During the following cycle, the map is read.  The instruction
executed during this cycle should be a JUMP instruction which checks for
a page fault condition.  At the end of this cycle, if no page fault occurs,
the memory operation begins.  The CONS machine continues executing while
the memory operation happens, but if any reference to a functional source
or destination which conflicts with the memory being busy is attempted,
the machine hangs until the memory operation has been completed.  Such
references include asking for the results of a read cycle by using the
READ-MEMORY-DATA functional source, writing the map, or starting another
cycle with a functional destination such as VMA-START-WRITE.
.sp
<< Trap mode should be described here, when it is implemented. >>
.sp 2
.sect
4The Memory Interface0
.sp
	The Memory Interface connects the CONS machine to two busses,
the Unibus and the Xbus.  The Unibus is a regular pdp11 bus, used
to attach peripheral devices.  The Xbus is a 32-bit bus used to attach
memory.  The present disk interface is on the Unibus, but future ones
will probably be on the Xbus.
	The Memory Interface allows the CONS machine to access memory
on the Xbus and devices on the Unibus, allows independent devices on the
Xbus to access the busses, and allows Unibus devices to access Xbus memory
(through a map since the Unibus address space is not big enough.)
Buffering is provided to convert 32-bit words into 16-bit words.
It also implements the Diagnostic interface, which is described later.
<<Eventually it will implement interrupts.>>

<<much much more>>
.page
.sect
4The CONSLP Assembler0
.sp
	CONSLP is a symbolic assembler written in MacLISP which
reads in source code for the CONS machine and produces
a file loadable by the CC debugger.  The source code is written
in the form of LISP S-expressions; symbols are LISP atomic symbols,
and instructions or data items are written as lists.
Comments can thus be written using MacLISP's semicolon convention.
The input radix for numbers is 8 (octal), except that a trailing decimal
point forces radix 10 (decimal).
.sp
<<describe how to invoke it?>>
<<which reminds me, current implementation is a kludge>>
.sp 2
.sect
4Localities0
.sp
	A program can specify data to be loaded into the instruction,
dispatch, A, and M memories.
To specify which of the memories to assemble data for,
the LOCALITY pseudo-op is used:
.sp
.nofill
	(LOCALITY I-MEM)	;following data goes into instruction memory
	(LOCALITY D-MEM)	;ditto, dispatch memory
	(LOCALITY A-MEM)	;ditto, A memory
	(LOCALITY M-MEM)	;ditto, M memory
.adjust
.sp 2
.sect
4Location Tags and Symbols0
.sp
	When an atomic symbol is encountered in the instruction
stream being assembled, it is taken to be a location tag (label).
The tag is defined, as usual, to be the value of the next location
in the current locality to be assembled into,
but shifted to put the tag value into its "normal" position.
For A memory tags, the normal position is the A-source field
of an instruction; similarly for M memory tags.
For I memory tags, the normal position is the New PC field
of a JUMP instruction; for D memory tags, the Dispatch Offset
field of a DISPATCH instruction.  Thus, if FOO is a tag for
location 7 of dispatch memory, then the effective value of FOO is 340000.
	By convention, tags in A memory begin with the letters "A-",
and in M memory with "M-", but this is not enforced by CONSLP.
	Symbols canalso be defined by means of the ASSIGN pseudo-operation:
.sp
(ASSIGN <symbol> <value>)
.sp
For example:
.sp
.nofill
(ASSIGN CDR-IS-NORMAL 0)
(ASSIGN CDR-IS-ILLEGAL 1)
(ASSIGN CDR-IS-NIL 2)
(ASSIGN CDR-IS-NEXT 3)
.adjust
.sp
The <value> may be an expression program, in general.
When a symbol is referenced, the expression program is
evaluated to produce the symbol's value (which may be
conditional on the context in which it appears).
Expression programs are discussed in a later section.

.sp 2
.sect
4Instructions0
.sp
	In general, CONSLP assembles a list into a data
item by evaluating all the elements of the list and adding
them up.  There is a fairly rich language for specifying
complex expression programs and assigning symbolic names to them;
for now, however, we will merely
use the symbols predefined by CONSLP.
CONSLP also allows the fields of an instruction to be
written in almost any order, but we will describe only the
conventional order for writing them.
	The general form of an I-MEM instruction is:
.sp
.nofill
	(<popj>  (<destinations>)  <operation>  <condition> 
	   <M-source>  <byte-descriptor>  <A-source>  <target-tag>  <other fields>)
.adjust
.sp
The <popj> field is POPJ-AFTER-NEXT to specify that the POPJ bit be set.
.br
The <destinations> field may be an A or M memory tag, or the name
of a functional destination, or both an M memory tag and a
functional destination.
.br
The <operation> specifies the instruction type, and possibly other
fields (such as the jump condition) as well.
.br
The <condition> may also be a separate field, though it usually
is encoded as part of the operation.
.br
The <byte-descriptor> describes the byte to be used in a BYTE or DISPATCH
instruction.
.br
The <M-source> and <A-source> specify the sources; these may be tags
in the appropriate memories, or, for the <M-source>, the name of an
M multiplexor source.
.br
The <target-tag> is an I-MEM tag for JUMP instructions,
or a D-MEM tag for DISPATCH instructions.
.br
The <other fields> can be such things as the Q control and Miscellaneous Functions.
	Many of these fields can be omitted, and CONSLP will
default them appropriately.  If the <operation> is omitted,
then ALU is assumed, unless a <byte descriptor> is present either
implicitly or explicitly, in which case BYTE is assumed.
If only one source is present in an ALU instruction,
then an opcode of SETA is supplied for an A source, and SETM
for an M source, thus causing a simple movement of data.
If the A source is omitted in a BYTE instruction, then location 1
in A memory is assumed (which is supposed to contain zero).
	Here are some examples of instructions, with commentary.
We assume the convention described above for A and M memory tags.
.sp
.nofill
	((A-FOO) M-BAR)	;move from BAR in M-MEM to FOO in A-MEM
.sp
	(CALL ZAP)	;do a CALL transfer to instruction ZAP (N bit set)
.sp
	((A-FOO) SUB M-BAR A-BAZ)
			;subtract A-BAZ from M-BAR, put result in A-FOO
.sp
	(JUMP-EQUAL-XCT-NEXT M-BAR A-FOO LOSE)
			;jump to LOSE if M-BAR equals A-FOO; N bit is clear,
			; so instruction after the JUMP is executed
			; whether or not the JUMP succeeds
.sp
	(POPJ-AFTER-NEXT (M-FOO) READ-MEMORY-DATA)
			;put data from memory into M-FOO,
			; and also POPJ after next instruction
.sp
	((M-SAVE WRITE-MEMORY-DATA-START-WRITE)
		ADD READ-MEMORY-DATA A-ZERO ALU-CARRY-IN-ONE)
			;add one to the read memory data,
			; transfer to write memory data and M-SAVE,
			; and begin writing the data into main memory
			; at the address already in the VMA
.adjust

.sp 2
.sect
4Literals0
.sp
	CONSLP provides a facility for specifying literals in the A and M memories.
The constructs
.sp
.nofill
	(A-CONSTANT <expression>)   and   (M-CONSTANT <expression>)
.adjust
.sp
may appear as an A source or M source specification, causing CONSLP to allocate
a word in the appropriate memory, assemble the literal expression there, and use
the address of that location as the source location.  If the same constant
in the same memory is referenced many times, CONSLP will assemble only one copy of it.
Two constants are considered the same if their final binary values
are identical, regardless of the source expressions which reduced
to those values.
The zero constant is treated specially, and made to refer to location 1
of the appropriate memory (hence the user should reserve these locations
as constant sources of zeros).

.sp 2
.sect
4Byte Specifications0
.sp
	Rather than requiring the user to calculate the
rotation count and length (minus 1) fields for BYTE and DISPATCH
instructions, CONSLP provides a uniform method for specifying
a byte in terms of its size and position in the word;
CONSLP then calculates the fields appropriately.
	The simplest way to describe a byte is with the BYTE-FIELD
construct:
.sp
	(BYTE-FIELD <size in bits> <position from right>)
.sp
For example, (BYTE-FIELD 5 0) is the low five bits of a word,
and (BYTE-FIELD 7 5) is the seven bits above them.  The two arguments
to BYTE-FIELD must be constant integers.
	Another way to describe a byte is:
.sp
	(LISP-BYTE <ppss>)
.sp
where the low two octal digits of <ppss> are the size and
the next two are the position.  The argument <ppss> is
evaluated as a LISP form (see below under "Expression Programs").
	When a byte specifier appears in an instruction,
the op-code is defaulted to BYTE, and the type of byte
instruction defaulted to "load byte".
If specified  elsewhere in the instruction, the op-code
may be DISPATCH instead; the dispatch is based on the
specified byte.
The op-code may also be JUMP, but only if the byte is one
bit wide; this means that the jump will test the specified bit
of the M source.
	When CONSLP assembles the final instruction,
it constructs the rotation count and length minus 1 fields
on the basis of the byte specifier and the operation to be performed.
For JUMP, DISPATCH, and "load byte" type BYTE instructions,
this involves subtracting the byte position from 32
to obtain the correct rotation count.
(Recall that CONS rotates words to the left.)
If Miscellaneous Function 3 (LOW PC BIT specifies half word) is enabled,
then the position (which should be less than 16) is subtracted from 16 instead.
For "deposit byte" and "selective deposit" type BYTE instructions,
the byte position itself is used as the rotation count.
The length minus 1 field for BYTE and JUMP
is computed by subtracting 1 from the byte length,
unless the byte length is zero, in which case zero is used.
(Note that CONS cannot really handle zero-length bytes, but CONSLP
allows them to be defined on the theory that the "next instruction modify"
feature may be in use.  Programs which use this feature must be aware
of the hackery which the assembler pulls, and allow for the actual
values of the fields at run time.)
The DISPATCH instruction has a length field instead of a length minus 1
field, and so no subtraction of 1 is performed for it.
	Here are some examples of the use of byte specifiers:
.sp
.nofill
	((M-X) (BYTE-FIELD 7 4) M-Y)
			;extracts a 7-bit byte, 4 bits from
			; the right, from M-Y, and puts this
			; byte right-justified in M-X.  The
			; A source is defaulted to 1, which
			; should be a constant zero so that the
			; other bits in M-X will be zero.
.sp
	(JUMP-IF-BIT-SET (BYTE-FIELD 1 3) M-ZAP QUUX)
			;jump to QUUX if the "10" bit is set in M-ZAP
.sp
	(DISPATCH (BYTE-FIELD 3 0) M-ZAP DTABLE)
			;use the low three bits of M-ZAP to index
			; into the dispatch table DTABLE
.adjust
.sp
	It is possible to create a symbolic name for a byte field by using the
ASSIGN pseudo-operation:
.sp
   (ASSIGN LOW-HEX-DIGIT (BYTE-FIELD 4 0))
.sp
Since this is a common operation, another pseudo-op exists for the
purpose:
.sp
   (DEF-DATA-FIELD <symbol> <byte size> <byte position>)
.sp
For example:
.sp
   (DEF-DATA-FIELD LOW-HEX-DIGIT 4 0)
.sp
	It is also possible to associate a name with a byte field in
a particular register.  One way to do this is to sum the
byte specifier and the name of the register:
.sp
   (ASSIGN CONDITION-CODES (PLUS (BYTE-FIELD 4 0) PDP-11-PS))
   (ASSIGN TRACE-TRAP-BIT (PLUS (BYTE-FIELD 1 4) PDP-11-PS))
   (ASSIGN PRIORITY (PLUS (BYTE-FIELD 3 5) PDP-11-PS))
.sp
This case too is common enough to warrant a special pseudo-operation for the purpose:
.sp
   (DEF-BIT-FIELD-IN-REG <symbol> <byte size> <byte position> <register>)
.sp
For example:
.sp
   (DEF-BIT-FIELD-IN-REG CONDITION-CODES 4 0 PDP-11-PS)
   (DEF-BIT-FIELD-IN-REG TRACE-TRAP-BIT 1 4 PDP-11-PS)
   (DEF-BIT-FIELD-IN-REG PRIORITY 3 5 PDP-11-PS)
.sp
Note that the <register> had better be in the M-scratchpad.
With this definition, it is only necessary to mention, say, PRIORITY, in an instruction
to cause an appropriate byte reference to occur:
.sp
.nofill
	((A-PRIORITY) PRIORITY)	;extract the PRIORITY byte from PDP-11-PS
				; and place it right-justified in A-PRIORITY
.adjust
.sp
By special dispensation, it also works to use such symbols in the destination
field.  The appropriate DPB is assembled.
.sp
	Two more pseudo-operations make it easy to define names for many
consecutive bits or fields in a register.
.sp
   (DEF-NEXT-FIELD <symbol> <byte size> <register>)
.sp
This defines <symbol> to be a byte of the speicified size, in a position
to the left of any fields already defined by DEF-NEXT-FIELD.
If this is the first DEF-NEXT-FIELD for the specified register,
then the field position is zero (at the low end of the word).
For example:
.sp
.nofill
   (DEF-NEXT-FIELD REL-OFFSET 8 IBM-1130-INSTRUCTION)
   (DEF-NEXT-FIELD TAG-FIELD 2 IBM-1130-INSTRUCTION)
   (DEF-NEXT-FIELD FORMAT-BIT 1 IBM-1130-INSTRUCTION)
   (DEF-NEXT-FIELD OP-CODE 5 IBM-1130-INSTRUCTION)
.adjust
.sp
would be entirely equivalent to:
.sp
.nofill
   (DEF-BIT-FIELD-IN-REG REL-OFFSET 8 0 IBM-1130-INSTRUCTION)
   (DEF-BIT-FIELD-IN-REG TAG-FIELD 2 8 IBM-1130-INSTRUCTION)
   (DEF-BIT-FIELD-IN-REG FORMAT-BIT 1 10. IBM-1130-INSTRUCTION)
   (DEF-BIT-FIELD-IN-REG OP-CODE 5 11. IBM-1130-INSTRUCTION)
.adjust
.sp
The pseudo-operation:
.sp
   (DEF-NEXT-BIT <symbol> <register>)
.sp
is entirely equivalent to:
.sp
   (DEF-NEXT-FIELD <symbol> 1 <register>)
.sp
and so allocates a single bit.  It may be intermixed freely with DEF-NEXT-FIELD.
For example:
.sp
.nofill
   (DEF-NEXT-FIELD CONDITION-CODES 4 PDP-11-PS)
   (DEF-NEXT-BIT TRACE-TRAP-BIT PDP-11-PS)
   (DEF-NEXT-FIELD PRIORITY 3 PDP-11-PS)
.adjust
.sp
The construct:
.sp
   (RESET-BIT-POINTER <register>)
.sp
may be used to reset the pointer into <register> used by DEF-NEXT-FIELD
and DEF-NEXT-BIT.  This is useful if the data in <register> can have several
different formats.  For example:
.sp
.nofill
   (DEF-NEXT-BIT C PDP-11-PS)
   (DEF-NEXT-BIT V PDP-11-PS)
   (DEF-NEXT-BIT Z PDP-11-PS)
   (DEF-NEXT-BIT N PDP-11-PS)
   (RESET-BIT-POINTER PDP-11-PS)
   (DEF-NEXT-FIELD CONDITION-CODES 4 PDP-11-PS)
   (DEF-NEXT-BIT TRACE-TRAP-BIT PDP-11-PS)
   (DEF-NEXT-FIELD PRIORITY 3 PDP-11-PS)
.sp
   (DEF-NEXT-FIELD DST-REG 3 PDP-11-INSTRUCTION)
   (DEF-NEXT-FIELD DST-MODE 3 PDP-11-INSTRUCTION)
   (DEF-NEXT-FIELD SRC-REG 3 PDP-11-INSTRUCTION)
   (DEF-NEXT-FIELD SRC-REG 3 PDP-11-INSTRUCTION)
   (DEF-NEXT-FIELD OP-CODE 4 PDP-11-INSTRUCTION)
   (RESET-BIT-POINTER PDP-11-INSTRUCTION)
   (DEF-NEXT-FIELD BRANCH-OFFSET 8 PDP-11-INSTRUCTION)
   (DEF-NEXT-FIELD BRANCH-CONDITION 3 PDP-11-INSTRUCTION)
   (RESET-BIT-POINTER PDP-11-INSTRUCTION)
.adjust

.sp 2
.sect
4Dispatch Tables0
.sp
	When assembling into the dispatch memory (i.e. (LOCALITY D-MEM))
it is necessary to use two special pseudo-operations,
START-DISPATCH and END-DISPATCH,
to allocate blocks of dispatch memory.  These pseudo-operations
specify the length of the block required, and CONSLP undertakes
to pack the various odd-sized blocks into the dispatch memory
in an appropriate manner.
	The typical form for a dispatch block is:
.sp
.nofill
.in 3
(START-DISPATCH <log2 of size> <constant data>)
<dispatch table tag>
	<first word of table>
	...
	<last word of table>
(END-DISPATCH)
.in 0
.adjust
.sp
The <log2 of size> is the number of bits that will be dispatched on,
that is, the logarithm base 2 of the size of the dispatch block.
The <constant data> will be added into each of the words of the
dispatch table; this is useful for the P, R, and N bits
(which in CONSLP are called P-BIT, R-BIT, and INHIBIT-XCT-NEXT-BIT).
The END-DISPATCH is logically not necessary, but is used for error
checking.  Exactly the correct number of words must be assembled between
the START-DISPATCH and END-DISPATCH, or CONSLP will give an error message.
	As an example of a dispatch table, consider this code:
.sp
.nofill
.in 3
(LOCALITY M-MEM)
PDP-11-INSTRUCTION	(0)	;HOLDS SIMULATED PDP-11 INSTRUCTION
(DEF-NEXT-FIELD DST-REG 3 PDP-11-INSTRUCTION)
(DEF-NEXT-FIELD DST-MODE 3 PDP-11-INSTRUCTION)
(DEF-NEXT-FIELD SRC-REG 3 PDP-11-INSTRUCTION)
(DEF-NEXT-FIELD SRC-REG 3 PDP-11-INSTRUCTION)
(DEF-NEXT-FIELD OP-CODE 4 PDP-11-INSTRUCTION)
	...
.sp
(LOCALITY I-MEM)
	(DISPATCH-CALL-XCT-NEXT DST-MODE D-DST-MODE)
	...
.sp
(LOCALITY D-MEM)
(START-DISPATCH 3 P-BIT)
D-DST-MODE
	(DST-REGISTER)			;R0
	(DST-REG-INDIRECT)		;@R0
	(DST-AUTO-INCREMENT)		;(R0)+
	(DST-AUTO-INC-INDIRECT)		;@(R0)+
	(DST-AUTO-DECREMENT)		;-(R0)
	(DST-AUTO-DEC-INDIRECT)		;@-(R0)
	(DST-INDEXED)			;N(R0)
	(DST-INDEXED-INDIRECT)		;@N(R0)
(END-DISPATCH)
.in 0
.adjust
.sp
Note that the use in I-MEM of the op-code DISPATCH-CALL-XCT-NEXT
is purely for cosmetic purposes, to indicate that the P bit but not the N bit
is a constant in all of the dispatch table entries; it is otherwise
identical to the DISPATCH op-code.

.sp 2
.sect
4Standard Operation Codes0
.sp
	CONSLP supplies a large number of initial symbols
for various operations, particularly for the various conditional
jumps.  While it is possible to define different ones, use of these
standard ones is naturally encouraged.  (These symbols are defined
in the file LISPM; CONSYM >.)
.sp 2
.sect
4ALU Operations0
.sp
	The standard ALU operations supplied by CONSLP are:
.sp
.nofill
    Boolean
	SETCM		set to complement of M
	ANDCB		AND together complements of both M and A
	ANDCM		AND complement of M with A
	SETZ		set to zeros
	ORCB		OR together complements of both M and A
	SETCA		set to complement of A
	XOR		XOR (exclusive OR) M and A
	ANDCA		AND M with complement of A
	ORCM		OR complement of M with A
	EQV		EQV M and A (complement of XOR)
	SETA		set to A
	AND		AND together M and A
	SETO		set to ones
	ORCA		OR M with complement of A
	IOR		OR M and A (inclusive OR)
	SETM		set to M
.sp
    Arithmetic
	ADD		M plus A (two's complement addition)
	SUB		M minus A (two's complement subtraction)
	M+M		M plus M (two's complement addition)
	M+M+1		M plus M plus 1
	M+A+1		M plus A plus 1
	M-A-1		M minus A minus 1
	M+1		M plus 1
.sp
    Conditional Arithmetic
	MULTIPLY-STEP
	DIVIDE-FIRST-STEP
	DIVIDE-STEP
	DIVIDE-LAST-STEP
	DIVIDE-REMAINDER-CORRECTION-STEP
.adjust
.sp
The conditional ALU operations for multiplication
and division are explained in detail in a later section.
	The output bus selector field defaults to 1 (output bus
gets ALU output).  The other two choices must be specified explicitly:
.sp
.nofill
	OUTPUT-SELECTOR-RIGHTSHIFT-1
	OUTPUT-SELECTOR-LEFTSHIFT-1
.adjust
.sp
	The Q control field of an ALU instruction
may be specified by using one of these symbols:
.sp
.nofill
	SHIFT-Q-LEFT	shift Q left (shifts inverse of ALU<31> into Q<0>)
	SHIFT-Q-RIGHT	shift Q right (shifts ALU<0> into Q<31>)
	LOAD-Q		load Q from output bus
.adjust
.sp
If none of these is present, the default is to do nothing to Q.
(Instead of writing LOAD-Q, one may write Q-R in the destination
portion of the instruction. This does not mean that Q is a functional
destination; it merely forces the operation to be ALU, and
forces the Q control field to be LOAD-Q.)
	The carry field may be specified by ALU-CARRY-IN-ZERO
or ALU-CARRY-IN-ONE.  Note that the SUB, M+M+1, M+A+1, and M+1
operations have ALU-CARRY-IN-ONE
as part of their definitions, so it is not necessary to specify it explicitly.
.sp 2
.sect
4BYTE operations0
.sp
	If a byte specifier is present in an instruction
and the op-code is not explicitly forced to be JUMP or DISPATCH,
then the op-code is BYTE by default, performing a "load byte" type
of operation.
	To get a "deposit byte" type operation, the symbol DPB is used;
similarly, to get a "selective deposit", SELECTIVE-DEPOSIT is used.
For example:
.sp
.nofill
	((A-FOO) DPB M-BAR (BYTE-FIELD 3 6) A-FOO)
			;a true PDP-10 style DPB; the low octal
			; digit of M-BAR replaces the third lowest
			; octal digit of A-FOO.
.sp
	((A-ZAP) DPB M-BAR (BYTE-FIELD 3 6) A-FOO)
			;similar, but the result is placed in
			; A-ZAP.  A-FOO is not altered.
.sp
	((A-ZAP) SELECTIVE-DEPOSIT M-FOO (BYTE-FIELD 16. 8) (A-CONSTANT -1))
			;A-ZAP gets a copy of M-FOO with the high eight
			; bits and the low eight bits replaced with all ones
			; (alternatively, it gets a copy of the -1
			; with the middle 16. bits replaced with
			; the corresponding bits from M-FOO)

.adjust

.sp 2
.sect
4DISPATCH Operations0
.sp
	Four op-codes are defined in CONSLP for dispatching:
.sp
.nofill
	DISPATCH
	DISPATCH-CALL
	DISPATCH-XCT-NEXT
	DISPATCH-CALL-XCT-NEXT
.adjust
.sp
These are provided purely for cosmetic purposes, since the actual dispatch
action is controlled by the dispatch table.  CONSLP makes no attempt
to check that the "correct" op-code is used with a given dispatch table.
By convention, the XCT-NEXT versions are used iff the instruction following
the dispatch instruction will be executed (N bit not set), and the CALL
versions are used if the P bit is set.
	To specify the value of the 8-bit "immediate argument"
which is loaded into the DISPATCH CONSTANT register, one may use
.sp
.nofill
	(I-ARG <expression>)		;immediate argument
.adjust
.sp
in the dispatch instruction.
.sp
	There is a special pseudo-op to facilitate use of the DISPATCH CONSTANT
to pass a small, constant number as an argument to a subroutine.  The form
.sp
.nofill
	((ARG-CALL FOO) (I-ARG BAR))
.adjust
.sp
generates a DISPATCH instruction to a one-word table containing a CALL-type
transfer to FOO, and puts BAR in the dispatch constant field of the dispatch instruction.
FOO may then use the READ-I-ARG functional source to pick up and act on the argument.
.sp

	Miscellaneous Function 2 (write into the dispatch memory)
is specified by the symbol WRITE-DISPATCH-RAM.

.sp 2
.sect
4JUMP Operations0
.sp
	CONSLP defines a large number of names for the various JUMP
operations.  These are all built out of a logical progression of pieces:
.sp
.nofill
	<type>  <condition>  <xct next>
.adjust
.sp
The <type> may be either JUMP, CALL, or POPJ, meaning that no bits, the
P bit, or the R bit is set.  The <condition> may be one of the following:
.sp
.nofill
.block 14
	IF-BIT-SET
	IF-BIT-CLEAR
	EQUAL
	NOT-EQUAL
	LESS-THAN
	GREATER-THAN
	GREATER-OR-EQUAL
	LESS-OR-EQUAL
	IF-PAGE-FAULT
	IF-NO-PAGE-FAULT
	IF-INTERRUPT
	IF-NO-INTERRUPT
	IF-PAGE-FAULT-OR-INTERRUPT
	IF-NO-PAGE-FAULT-OR-INTERRUPT
.adjust
.sp
If omitted, the <condition> is assumed to be "always".
The <xct_next>, if present, is XCT-NEXT; its absence denotes the presence of the N bit,
which inhibits the instruction after the jump if the jump is successful.
The three parts are connected by "-".
	Examples of these operations:
.sp
.nofill
	CALL-LESS-THAN
	JUMP-LESS-THAN-XCT-NEXT
	CALL
	POPJ-IF-BIT-SET
	CALL-IF-PAGE-FAULT-OR-INTERRUPT
	CALL-IF-BIT-CLEAR-XCT-NEXT
	JUMP-XCT-NEXT
	POPJ-XCT-NEXT
.adjust
.sp
The POPJ-XCT-NEXT operation is not to be confused with POPJ-AFTER-NEXT,
which may be used in any instruction to set the POPJ bit.
	Jump instructions which perform an arithmetic comparison
should have both an A and an M source; the sources are compared.
Jump instructions which test a bit should have an M source and a byte specifier
for a 1-bit byte to test.

.sp 2
.block 21
.sect
4M Multiplexor Sources0
.sp
	The following names are supplied by CONSLP for the various M
multiplexor sources:
.sp
.nofill
02	READ-MEMORY-DATA		MRD register
12	WRITE-MEMORY-DATA		MWD register
22	VMA				VMA register
32	MEMORY-MAP-DATA			Map data
 3	Q-R				Q register
 4	PDL-BUFFER-INDEX		Byte specifier for bits <9-0>
	PDL-BUFFER-POINTER		Byte specifier for bits <19-10>
05	MICRO-STACK-PNTR-AND-DATA	SPCPTR and SPC data
	MICRO-STACK-POINTER		Byte specifier for bits <31-27>
	MICRO-STACK-DATA		Byte specifier for bits <14-0>
15	MICRO-STACK-PNTR-AND-DATA-POP	Like 05, but pops SPC stack
	MICRO-STACK-POINTER-POP		Like 05, but pops SPC stack
	MICRO-STACK-DATA-POP		Like 05, but pops SPC stack
 6	READ-I-ARG			DISPATCH CONSTANT register
07	C-PDL-BUFFER-INDEX		Pdl data addressed by PDL INDEX
17	C-PDL-BUFFER-POINTER-POP	Pdl data popped off PDL POINTER
37	C-PDL-BUFFER-POINTER		Pdl data addressed by PDL POINTER
.adjust

.sp 2
.block 24
.sect
4Functional Destinations0
.sp
	The following names are provided by CONSLP for functional
destinations.  Note that some of them are the same names used for
M multiplexor sources; CONSLP distinguishes usage by context.
.sp
.nofill
.twinch 6.8
 1	WRITE-MEMORY-DATA		MWD register
 2	WRITE-MEMORY-DATA-START-WRITE	MWD, initiate write cycle
 3	WRITE-MEMORY-DATA-WRITE-MAP	MWD, write map data
 4	VMA				VMA register
 5	VMA-START-READ			VMA, initiate read cycle
 6	VMA-START-WRITE			VMA, initiate write cycle
 7	VMA-WRITE-MAP			VMA, write map data
10	C-PDL-BUFFER-POINTER		Pdl location addressed by PDL POINTER
11	C-PDL-BUFFER-POINTER-PUSH	Push data onto PDL POINTER
12	C-PDL-BUFFER-INDEX		Pdl location addressed by PDL INDEX
13	PDL-BUFFER-INDEX		PDL INDEX register
14	PDL-BUFFER-POINTER		PDL POINTER register
15	MICRO-STACK-DATA-PUSH		Push data onto SPC stack
16	OA-REG-LOW			Next instruction modify, bits <23-0>
17	OA-REG-HI			Next instruction modify, bits <40-24>
.twinch 6.3
.adjust
.sp
	The symbol Q-R may also be used as a destination; it causes
an ALU instruction to have its Q control field to be set to "load Q from
output bus"; this is equivalent to specifying LOAD-Q in the instruction.

.sp 2
.sect
4Operations Common to All Instructions0
.sp
	The symbol for the POPJ bit is POPJ-AFTER-NEXT.
	Miscellaneous Function 1, which halts the processor in any kind of
instruction, is denoted by HALT-CONS.
	Miscellaneous Function 3 is denoted by LOAD-LOW-PC-BIT in
ALU instructions and by LOW-PC-BIT-SELECTS-HALF-WD in the others.  (This feature
is described in greater detail in a later section.)

.sp 2
.sect
4Expression Programs in CONSLP0
.sp
	Wherever an expression may be used in CONSLP, the following
arcane forms may be used.  In particular, the value of a symbol is
normally an expression instead of a simple number.  Whenever an
expression (or a symbol with an expression as its definition)
is encountered, it is evaluated according to the following rules:
.sp
.in 32
.un 32
<number>________________________Evaluates to itself.
.sp
.block 3
.un 32
(PLUS_<exp1>_<exp2>)____________Adds together the two expressions, and
combines their properties (such as byte-specifier-ness).
.sp
.block 3
.un 32
(DESTINATION-P_<exp>)___________A conditional: if encountered while assembling
a destination, returns the value of <exp>, and otherwise NIL.
.sp
.block 3
.un 32
(SOURCE-P_<exp>)________________A conditional: if encountered while assembling
a source (M or A), returns the value of <exp>, and otherwise NIL.
.sp
.block 3
.un 32
(DISPATCH-INSTRUCTION-P_<exp>)__A conditional: if encountered while assembling
a DISPATCH instruction, returns the value of <exp>, and otherwise NIL.
.sp
.block 3
.un 32
(JUMP-INSTRUCTION-P_<exp>)______A conditional: if encountered while assembling
a JUMP instruction, returns the value of <exp>, and otherwise NIL.
.sp
.block 3
.un 32
(ALU-INSTRUCTION-P_<exp>)_______A conditional: if encountered while assembling
an ALU instruction, returns the value of <exp>, and otherwise NIL.
.sp
.block 3
.un 32
(BYTE-INSTRUCTION-P_<exp>)______A conditional: if encountered while assembling
a BYTE instruction, returns the value of <exp>, and otherwise NIL.
.sp
.block 3
.un 32
(NOT_<conditional>)_____________Negation.  <conditional> must be one of the
above conditionsl forms.
.sp
.block 3
.un 32
(OR_<cond1>_..._<condn>)________Like a LISP OR, returns the first non-NIL
conditional.
.sp
.block 3
.un 32
(BYTE-FIELD_<size>_<pos>)_______As described earlier, defines a byte
with the given size and position from the right.
.sp
.block 3
.un 32
(LISP-BYTE_<ppss>)______________As described earlier; if ppss is written
in octal, then this is like (BYTE-FIELD ss pp).  If <ppss> is not a
number, then it is a LISP expression (not a CONSLP expression!),
and is evaluated in LISP.
.sp
.block 3
.un 32
(BYTE-MASK_<byte_specifier>)____Value is a word which is zero everywhere
except for being all ones in the specified byte.
This is a kind of conditional, in that it returns NIL if the byte
specifier doesn't really specify a byte.
.sp
.block 3
.un 32
(BYTE-VALUE_<byte_specifier>_<value>)__Value is a word which is zero
everywhere, except that it contains <value> in the specified byte.
This is a kind of conditional, in that it returns NIL if the byte
specifier doesn't really specify a byte.
.sp
.block 3
.un 32
(OA-HIGH-CONTEXT_<word>)________Assembles <word> as an instruction,
and returns the high half (bits <40-24>), as if for use by the OA register
feature (next instruction modify, functional destination 17).
.sp
.block 3
.un 32
(OA-LOW-CONTEXT_<word>)_________Assembles <word> as an instruction,
and returns the low half (bits <23-0>), as if for use by the OA register
feature (next instruction modify, functional destination 16).
.sp
.block 3
.un 32
(FORCE-DISPATCH_<exp>)__________Returns value of <exp>, but also forces
the instruction to be a DISPATCH instruction.  A conflict causes an error.
.sp
.block 3
.un 32
(FORCE-JUMP_<exp>)______________Returns value of <exp>, but also forces
the instruction to be a JUMP instruction.
.sp
.block 3
.un 32
(FORCE-ALU_<exp>)_______________Returns value of <exp>, but also forces
the instruction to be an ALU instruction.
.sp
.block 3
.un 32
(FORCE-BYTE_<exp>)______________Returns value of <exp>, but also forces
the instruction to be a BYTE instruction.
.sp
.block 3
.un 32
(FORCE-DISPATCH-OR-BYTE_<exp>)__Returns value of <exp>, but also forces
the instruction to be a DISPATCH or BYTE instruction.
.sp
.block 3
.un 32
(FORCE-ALU-OR-BYTE_<exp>)_______Returns value of <exp>, but also forces
the instruction to be an ALU or BYTE instruction.
.sp
.block 3
.un 32
(I-MEM-LOC_<tag>)_______________Returns the address represented by <tag>
in locality I-MEM as a right-justified value.
.sp
.block 3
.un 32
(D-MEM-LOC_<tag>)_______________Returns the address represented by <tag>
in locality D-MEM as a right-justified value.
.sp
.block 3
.un 32
(A-MEM-LOC_<tag>)_______________Returns the address represented by <tag>
in locality A-MEM as a right-justified value.
.sp
.block 3
.un 32
(M-MEM-LOC_<tag>)_______________Returns the address represented by <tag>
in locality M-MEM as a right-justified value.
.sp
.block 3
.un 32
(EVAL_<lisp_exp>)_______________Returns the result of evaluating
in LISP the S-expression <exp>.
.sp
.block 3
.un 32
(FIELD_<name>_<value>)__________Makes a note that the field <name>
has been specified, then multiplies together the values of <name>
and <value>; if <name> has a LISP CONS-LAP-ADDITIVE-CONSTANT property,
this is then added in.  (This obscurity is the primitive from which
all field specifications are made.)
.sp
.block 3
.un 32
(ERROR)_________________________Error if this is assembled.  Useful in conditionals.
.in 0
.sp
	As examples of how conditionals might be used in expressions,
consider these definitions (which are similar (but not identical)
to the ones actually used in CONSLP):
.sp
.nofill
.in 3
(ASSIGN Q-R (OR (SOURCE-P (FIELD M-MULTIPLEXOR-SOURCE 3))
		(FORCE-ALU 60)))
.sp
(ASSIGN READ-MEMORY-DATA
	(OR (SOURCE-P (FIELD M-MULTIPLEXOR-SOURCE 2))
	    (ERROR)))
.sp
(ASSIGN WRITE-MEMORY-DATA
	(OR (SOURCE-P (FIELD M-MULTIPLEXOR-SOURCE 12))
	    (FIELD FUNCTIONAL-DESTINATION 1)))
.sp
(ASSIGN WRITE-MEMORY-DATA-START-WRITE
	(OR (SOURCE-P (ERROR))
	    (FIELD FUNCTIONAL-DESTINATION 2)))
.in 0
.adjust

.sp 2
.sect
4Miscellaneous Pseudo-Operations0
.sp
	Several identical words may be assembled consecutively
by saying:
.sp
	(REPEAT <count> <word>)
.sp
	The location counter within the current locality may be set by
.sp
.nofill
	(LOC <value>)		;sets it to <value>
	(MODULO <n>)		;advances it to the next multiple of <n>
.adjust
.sp
If the MODULO operation is used in A-memory, wastage is avoided by filling
in the skipped-over locations with constants.

.page
.sp 2
.sect
4CONS Features and Programming Examples0
.sp
	In this section the various features of the CONS machine
are examined and discussed in detail.  An attempt is made to
give some feeling for how each feature fits into the overall
structure of the machine, and the purposes for which the feature
is intended.  Short programming examples using each feature
are presented.

.sp 2
.sect
4Timing - The N Bit and the POPJ Bit0
.sp
	Because CONS fetches the next instruction at the same time
it is executing the current one, by the time the effect of a JUMP
or dispatch is known the instruction following the JUMP or DISPATCH
has already been fetched.  Unless suppressed by the N bit,
this instruction is executed before the instruction branched to.
The effect of this on programming is that one should "code the
branch one instruction sooner".  The mnemonics CONSLP provides
for the various branching operations normally set the N bit,
thus doing the straightforward thing at the cost of wasted cycles;
one must append "-XCT-NEXT" to the mnemonic to clear the N bit
and so bum the code.
	For example, consider these two pieces of code:
.sp
.nofill
	((A-FOO) XOR M-BAR A FOO)			;XOR M-BAR into A-FOO
	(JUMP-IF-BIT-SET MUMBLE MUMBLIFY)		;branch on MUMBLE bit
.sp
	(JUMP-IF-BIT-SET-XCT-NEXT MUMBLE MUMBLIFY)	;branch on MUMBLE bit
       ((A-FOO) XOR M-BAR A FOO)			;XOR M-BAR into A-FOO
.adjust
.sp
These both perform an XOR and conditionally jump to MUMBLIFY,
but the first one wastes a cycle if the JUMP is successful.
Notice the convention of "exdenting" an instruction which
is under the influence of an XCT-NEXT to make it more visible.
	If a CALL transfer type is executed, the return address
saved on the SPC stack depends on the N bit:
.sp
.nofill
	(CALL THE-SUBROUTINE)		;call, N bit set
	((A-FOO) XOR M-BAR A-FOO)	;return here after call
.sp
	(CALL-XCT-NEXT THE-SUBROUTINE)	;call, N bit clear
       ((A-ARGUMENT) ADD M-BAZ A-FOO)	;do this before entering the subroutine
	((A-FOO) XOR M-BAR A-FOO)	;return here after call
.adjust
.sp
If the N bit is set, PC+1 is pushed on the SPC stack; otherwise
PC+2 is pushed.
	The POPJ bit may be set in any instruction.
It causes a RETURN transfer, but only after the next instruction has
also been executed:
.sp
.nofill
ADD-THREE-WORDS		;subroutine to add together A-1, A-2, and A-3
	((M-RESULT) A-1)
	(POPJ-AFTER-NEXT (M-RESULT) ADD M-RESULT A-2)
       ((M-RESULT) ADD M-RESULT A-3)
.adjust
.sp
Again, the idea is to specify the desired control "one instruction early".
.sp
	Consider the following program:
.sp
.nofill
START	(JUMP-XCT-NEXT FOO)
       (JUMP-XCT-NEXT BAR)
	...
FOO	(JUMP-XCT-NEXT FOO)
	...
BAR	(JUMP-XCT-NEXT BAR)
.adjust
.sp
When started at START, it will go into an infinite loop alternately
executing FOO and BAR.  Effectively it is in two "jump point" loops
at the same time!

.sp 2
.sect
4Byte Manipulation0
.sp
	By using M location 1 (by convention a source of zeros)
with a BYTE instruction, one can clear any bit or field of bits
in any A memory location:
.sp
	((A-FOO) DPB M-ZERO A-FOO (BYTE-FIELD 1 31.))	;clear sign bit
.sp
It is often convenient to reserve another M memory location
to contain -1 (all ones), in order to be able to set bits
easily:
.sp
	((A-FOO) DPB M-ONES A-FOO (BYTE-FIELD 1 31.))	;set sign bit
.sp
In a similar manner one can write a routine to extend a signed
23-bit number to 32 bits:
.sp
.nofill
SIGN-EXTEND				;extend 8-bit number in M-NUM
	(POPJ-AFTER-NEXT POPJ-IF-BIT-CLEAR M-NUM (BYTE-FIELD 1 7))
       ((M-NUM) SELECTIVE-DEPOSIT M-NUM (BYTE-FIELD 8 0) (A-CONSTANT -1))
.adjust
.sp
	Normally bytes can only be loaded from an M source.  However,
it is possible to load a byte from A-memory, provided that it is at one
end of the word, by the following trick:
.sp
.nofill
(DEF-DATA-FIELD X-FIELD 6 0)
(DEF-DATA-FIELD ALL-BUT-X-FIELD 32 6)

	((DEST) SELECTIVE-DEPOSIT M-ZERO ALL-BUT-X-FIELD A-FOO)
.adjust

.sp 2
.sect
4The LOW PC BIT0
.sp
	CONS contains a one-bit register called the LOW PC BIT.
(This register has nothing to do with the PC of the CONS machine.)
It is intended for use in interpreting 16-bit instructions.
The idea is to load it with the low bit of the simulated (i.e. macro-code)
PC and then use it to select the 16-bit halfword containing the
macro-code instruction to be interpreted.
	The use of the LOW PC BIT is controlled by Miscellaneous
Function 3 in each type of instruction.  In the ALU instruction,
it causes the register to be loaded from the low bit of the ALU output;
in the BYTE, JUMP, and DISPATCH instructions, it causes the register
to be XOR'ed into the high bit of the byte rotation count.
The CONSLP symbols for these operations are:
.sp
	LOAD-LOW-PC-BIT
	LOW-PC-BIT-SELECTS-HALF-WD
.sp
When CONSLP detects the latter in a "load byte" situation,
it calculates the rotation count by subtracting the byte position
from 20 (octal) instead of 40 (octal).  The net effect is
a conceptual inversion of its effect which is hard to explain;
instead, look at this example of a hypothetical instruction
interpretation loop for a PDP-11 simulator:
.sp 2
.nofill
.block 15
1
(LOCALITY M-MEM)
M-INST-BUFFER  (0)		;word containing two instructions;
				; even word is in right half
   (DEF-BIT-FIELD-IN-REG M-INST-OPCODE 4 12.
			 (PLUS M-INST-BUFFER LOW-PC-BIT-SELECTS-HALF-WD))
   (DEF-BIT-FIELD-IN-REG M-INST-SRC 6 6
			 (PLUS M-INST-BUFFER LOW-PC-BIT-SELECTS-HALF-WD))
   (DEF-BIT-FIELD-IN-REG M-INST-DST 6 0
			 (PLUS M-INST-BUFFER LOW-PC-BIT-SELECTS-HALF-WD))
   (DEF-BIT-FIELD-IN-REG M-INST-BRANCH-OFFSET 8 0
			 (PLUS M-INST-BUFFER LOW-PC-BIT-SELECTS-HALF-WD))
   (DEF-BIT-FIELD-IN-REG M-INST-BRANCH-OFFSET-SIGN 1 7
			 (PLUS M-INST-BUFFER LOW-PC-BIT-SELECTS-HALF-WD))
   ...
M-PC	(0)		;SIMULATED PC (R7)
.sp 2
.block 18
(LOCALITY I-MEM)
.sp
INSTRUCTION-LOOP
	((M-INST-BUFFER) READ-MEMORY-DATA)	;gobble two instructions
INSTRUCTION-LOOP-PC-EVEN	;branch returns here if PC loaded even
				; (LOW PC BIT = 0); but PC is actually odd now
				; since it has been incremented past instruction
	(DISPATCH-CALL M-INST-OPCODE D-OPCODE)	;go execute even instruction
	((M-PC) M+1 M-PC LOAD-LOW-PC-BIT)	;increment PC
INSTRUCTION-LOOP-PC-ODD		;branch returns here if new PC was odd
				; (LOW PC BIT = 1); but PC is actually even now
				; since it has been incremented past instruction
	(DISPATCH-CALL M-INST-OPCODE D-OPCODE)	;go execute odd instruction
INSTRUCTION-FETCH
	((VMA-START-READ) M-PC OUTPUT-SELECTOR-RIGHTSHIFT-1)	;fetch next word
	(CALL-IF-PAGE-FAULT-OR-INTERRUPT INTERRUPT-SERVER)	;check for fault
	(JUMP-XCT-NEXT INSTRUCTION-LOOP)
       ((M-PC) M+1 M-PC LOAD-LOW-PC-BIT)	;increment PC
.sp
	...
.sp
.block 21
UNCONDITIONAL-BRANCH	;successful conditional branches come here too
	((M-TEMP) M-INST-BRANCH-OFFSET)				;get branch offset
	(JUMP-IF-BIT-CLEAR-XCT-NEXT				;jump if offset
		M-INST-BRANCH-OFFSET-SIGN			; is positive
		BRANCH-ADD-OFFSET-INTO-PC)			;in either case,
       ((A-TEMP) M+M M-TEMP)					; double offset
	((A-TEMP) SELECTIVE-DEPOSIT				;extend sign for
		(M-CONSTANT -1) (BYTE-FIELD 23. 9) A-TEMP)	; negative offset
BRANCH-ADD-OFFSET-INTO-PC
	((M-PC) ADD M-PC A-TEMP LOAD-LOW-PC-BIT)		;add offset to PC
	((VMA-START-READ) M-PC OUTPUT-SELECTOR-RIGHTSHIFT-1)	;get main loop back
	(CALL-IF-PAGE-FAULT-OR-INTERRUPT INTERRUPT-SERVER)      ;into phase
	((M-GARBAGE) MICRO-STACK-DATA-POP)			;flush SPC entry
								; pushed by
								; DISPATCH-CALL
	((M-PC) M+1 M-PC LOAD-LOW-PC-BIT)			;increment PC
	(JUMP-IF-BIT-CLEAR (BYTE-FIELD 1 0) M-PC PC-ODD)
PC-EVEN	(JUMP-XCT-NEXT INSTRUCTION-LOOP-PC-EVEN)		;enter loop at
       ((M-INST-BUFFER) READ-MEMORY-DATA)			; right place
.sp
PC-ODD	(JUMP-XCT-NEXT INSTRUCTION-LOOP-PC-ODD)			; with memory word
       ((M-INST-BUFFER) READ-MEMORY-DATA)			; in M-INST-BUFFER
0
.adjust
.sp 2
Note that the definitions of the various fields in the 16-bit instruction
are in terms of a right-hand halfword, and include
LOW-PC-BIT-SELECTS-HALF-WD.  The UNCONDITIONAL-BRANCH routine
needs only to refer to M-INST-BRANCH-OFFSET to refer
to the correct field in the correct half of the instruction buffer.

.sp 2
.sect
4The SPC Stack0
.sp
	The SPC stack is 32 locations long, each location containing
15 bits (plus parity).  It is indexed by SPCPTR, a 5-bit up/down counter.
It is used primarily as a microcode subroutine return stack, but besides
the 12 bits needed to save a microcode PC there are 3 bits for arbitrary
use by software.
.sp 2
.nofill
.block 9
SPC Stack Location                      12     9     6     3     0
                                         |     |     |     |     | 
                                    |     |                       |
                                    |  3  |          12           |
                                    |     |                       |
                                       |              |
Software bits--------------------------'              |
                                                      |
Saved return address----------------------------------'
.adjust
.sp 2
	There are two ways in which to write into the SPC stack memory;
both of them also increment SPCPTR, thus causing a push operation.
A JUMP or DISPATCH performing a CALL transfer type (P bit set, R bit clear)
causes a return address to be pushed on the stack; this return address
is the location of the JUMP or DISPATCH, plus 2 if XCT-NEXT is specified
or plus 1 if it is not.  The three software bits are set to zero
for a JUMP, or to IR<36-34> for a DISPATCH.
.sp
	<<what a crock!!!>>
.sp
Writing into function destination 15 (MICRO-STACK-DATA-PUSH) pushes
the low 15 bits of the output bus data onto the SPC stack.
	The SPC stack is read by a JUMP or DISPATCH performing a RETURN
transfer type (R bit set, P bit clear); the low 12 bits popped off the
stack are put in the PC, and the software bits are ignored.
It can also be read as M multiplexor sources 05 and 15.
The first (MICRO-STACK-PNTR-AND-DATA) merely reads the data
(and SPCPTR) on the top of the stack, while the second
(MICRO-STACK-PNTR-AND-DATA-POP) pops the stack after reading the data.
	There is no way to explicitly set the contents of SPCPTR.
However, a good trick is to use the following loop:
.sp
.nofill
FOO	((M-TEMP) MICRO-STACK-POINTER-POP)	;get just SPCPTR
	(JUMP-IF-EQUAL M-TEMP A-ZERO FOO)
.adjust
.sp
A better trick may be to use the following loop, which not
only is shorter, but is recursive rather
than iterative, and has the important advantage of being more obscure:
.sp
.nofill
FOO	(CALL-NOT-EQUAL MICRO-STACK-PNTR-AND-DATA
		(A-CONSTANT (PLUS 1 (I-MEM-LOC FOO))) FOO)
.adjust
.sp
This is a good thing to do on initialization so that the stack
will begin in a known place, thus aiding debugging via the
diagnostic interface.
	There is no provision for detection of SPC stack overflow
or underflow.  It is the responsibility of the programmer to
avoid nesting subroutines to a depth greater than 32.
.sp 2
.sect
4The PDL BUFFER Memory0
.sp
	The PDL BUFFER is intended to be used as a special-purpose
cache in the LISP machine to contain the top portion of the LISP pushdown stack.
It has 1024 locations of 32 bits, and can be indexed by either the
PDL POINTER or the PDL INDEX.  PDL POINTER is a 10-bit up/down counter,
while PDL INDEX is simply a 10-bitregister.
	The PDL BUFFER is manipulated through various M multiplexor sources
and functional destinations.  M multiplexor source 4 yields
the PDL POINTER and PDL INDEX as two 10-bit bytes (PDL-BUFFER-POINTER and
PDL-BUFFER-INDEX).  They can be written into using functional destinations
13 and 14, which have the same names.  (CONSLP distinguishes the usage by
context.)
M multiplexor source 07 (C-PDL-BUFFER-INDEX) gets
the contents of the PDL BUFFER location addressed by the contents of PDL INDEX;
source 37 (C-PDL-BUFFER-POINTER)
does the same, only using PDL POINTER to address the memory.
These names also correspond to functional destinations 12 and 10, respectively.
Functional destination 11 (C-PDL-BUFFER-POINTER-PUSH)
increments PDL POINTER before writing data into the PDL BUFFER;
its inverse is source 17 (C-PDL-BUFFER-POINTER-POP)
which reads data from the location addressed by PDL POINTER and
then decrements PDL POINTER.
	It doesn't work to specify both C-PDL-BUFFER-POINTER-PUSH and
C-PDL-BUFFER-POINTER-POP in the same instruction.  On the other hand,
the same effect can always be achieved simply by using
C-PDL-BUFFER-POINTER for both source and destination instead.
.sp
	<<we could make it work by changing the AND gate
	  (PDLCTL 3B0B, produces -PDLCNT) to be an XOR gate plus inverter,
	  (inversion could be accomplished by changing the OR above
	  it producing -SRCPDL(P) to a NOR), but probably not worth it>>
.sp
	There is no provision for automatic overflow or underflow
detection on pushes and pops of the PDL BUFFER.
In the LISP machine, the PDL POINTER is checked on entry to every function;
the compiler pre-determines the maximum amount of stack each function uses,
and the function entry protocol uses this information to decide whether
to push some of the PDL BUFFER out into main memory.  Similarly,
the function exit protocol decides whether to pull some stack back in from
main memory.

.sp 2
.sect
4Shifting and Rotating0
.sp


.sp 2
.sect
4Multiplication and Division0
.sp
<< See the microcode. >>

.sp 2
.sect
4Accessing Main Memory0
.sp
   The VMA
   The MRD
   The MWD
   The Memory Map
   Page Faults


.sp 2
.sect
4Modifying the Next Instruction (The "OA Register")0
.sp


.sp 2
.sect
4Writing into the Instruction Memory0
.sp

.sp 2
.sect
4Writing into the Dispatch Memory0
.sp


.sp 2
.sect
4The PDP-11 Diagnostic Interface0
.sp
	The CONS machine has a special diagnostic interface
by means of which a PDP-11 (or a machine with a compatible I/O bus
such as another CONS machine or a pdp10 equipped with a Ten-Eleven interface.)
can start and stop the processor,
examine various internal registers, and forcibly execute
specified instructions.

	To the PDP-11, the interface looks like
a set of 8 readable registers and 4 writable registers.
It should be noted that although the writable registers
are at the same UNIBUS addresses as four of the read-only registers,
there is no logical correspondence between the two sets,
and so it does not make sense to use PDP-11 instructions
which perform a read-modify-write on these registers.
The base UNIBUS address for the diagnostic interface registers
is currently 164000, and the standard symbolic name for the
base address is CONS.
.sp 3
.nofill
READ-ONLY REGISTERS:
.sp 2
.block 10
CONS	<15>	SPC PARITY	1 => Parity error in SPC memory
	<14>	DISPATCH PARITY	1 => Parity error in dispatch memory
	<13>	HIGH ERROR	1 => Noise/lossage in HIGH run
				(or a Miscellaneous Function 1-directed 
				halt.  This is temporary.)
	<12>	INST PARITY	1 => Parity error in instruction memory
	<11>	MMEM PARITY	1 => Parity error in M memory
	<10>	AMEM PARITY	1 => Parity error in A memory
	<9>	PDL PARITY	1 => Parity error in PDL BUFFER memory
	<8>	MEM PARITY	1 => Parity error in main memory
.sp
	<7-0>	OB<23-16>	Bits <23-16> of output bus
.sp 2
.block 6
CONS+2	<15>	-ERRHALT	0 => CONS has halted
	<14>	-HIGH OK	1 => Circuit monitoring HIGH is unhappy
	<13>	SRUN		1 => Machine is trying to run
				Set on RUN=1, cleared on CLOCKRUN=0
	<12>	SSDONE		1 => Single step has completed (see below)
	<11-0>	OPC<11-0>	OPC output (see below)
.sp 2
CONS+4	<15-0>	OB<15-0>	Bits <15-0> of output bus
.sp 2
.block 2
CONS+6	<15-12>			Unused
	<11-0>	PC<11-0>	Microcode PC
.sp 2
.block 9
CONS+10	<15>	IWRITED		1 => Next write pulse will write
				into the instruction memory
				(unless IDEBUG=0 - see below)
	<14>	IMODD		1 => Data from output bus will be IOR'ed
				with next instruction ("OA register")
				(unless IDEBUG=0 - see below)
	<13>	NOP		1 => Next instruction is inhibited
	<12-0>	IR<44-32>	Bits <44-32> of instruction that will be
				executed on the next clock cycle
.sp 2
.block 14
CONS+12	<15>	OA HIGH		If IMODD=1, then 1 => OA HIGH, 0 => OA LOW
	<14>	-MWAIT		0 => Processor is waiting on main memory
	<13>	PDLWRITED	1 => Write into PDL BUFFER memory on next cycle
	<12>	SPUSHD		1 => Write into SPC memory on next cycle
	<11>	-VMAOK		1 => Map output implies page fault condition
				(main memory access mode not valid)
	<10>	COND		If IR contains a JUMP, then 1 => the
				JUMP will be successful
	<9-8>	PCS<1-0>	PC select: indicates from where PC will be
				loaded on next cycle
				0	PC + 1
				1	SPC (RETURN transfer type)
				2	Dispatch memory (DISPATCH)
				3	IR<23-12> (JUMP)
	<7-0>	OB<31-24>	Bits <31-24> of output bus
.sp 2
CONS+14	<15-0>	IR<15-0>	Bits <15-0> of next instruction
.sp 2
CONS+16	<15-0>	IR<31-16>	Bits <31-16> of next instruction
.sp 3
.block 6
WRITE-ONLY REGISTERS
.sp 2
CONS	<15-0>	DEBUG<15-0>	Bits <15-0> of diagnostic instruction
.sp 2
CONS+2	<15-0>	DEBUG<31-16>	Bits <31-16> of diagnostic instruction
.sp 2
.block 2
CONS+4	<15-12>			Unused
	<11-0>	DEBUG<43-32>	Bits <43-32> of diagnostic instruction
.sp 2
.block 22
CONS+6	<15-10>			Unused
	<9>	ERRSTOP		1 => Processor should halt on error
				(any bit in read register CONS <15-8>)
	<8>	SPEED		1 => Slow down clock cycle read phase
	<7-6>			Unused
	<5>	OPC CLK		Clocks the OPC shift register when
				changed from 0 to 1
	<4>	NOP11		Asserts the NOP signal, which prevents
				any writes from being specified (but which
				does not reset any writes already specified
				for the next cycle)
	<3>	IDEBUG		Disable instruction memory for reading
				(and writing) and disable IMODD (see above);
				the diagnostic instruction will be executed
				instead
	<2>	URESET		Clear all error flip-flops and all
				"do X during next instruction" flags
	<1>	SSTEP		Forces next clock cycle to occur when
				changed from 0 to 1
	<0>	RUN		1 => Machine runs unless an error occurs
				0 => Machine halts
